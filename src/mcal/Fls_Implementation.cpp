/*******************************************************************************
 * Autogenerated by MCALgen for FLS V1.0.54.30643: Fls_Implementation.cpp
 *******************************************************************************/

/************************************************************************************************************
 *                              Include Files
 ***********************************************************************************************************/
extern "C" {
  #include "Fls.h"
#if (FLS_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"
#endif
  #include "Fls_Implementation.h"
}
#include "Fls_Device.h"
#include "Fls_VirtualHw.h"


/*******************************************************************************
 *                              Static and Global Variable Definitions
 ******************************************************************************/
#ifdef CUSTOM_FLS_ERASE_VALUE /* Compile option  [$Fls  1253] */
Fls_FakeHW fls_hw(FLS_TOTAL_SIZE, CUSTOM_FLS_ERASE_VALUE, FLS_DEV_ERROR_DETECT); /* [$Fls  1253] */
#else
Fls_FakeHW fls_hw(FLS_TOTAL_SIZE, FLS_ERASE_VALUE, FLS_DEV_ERROR_DETECT);
#endif
/*******************************************************************************
 *                              Values
 ******************************************************************************/
/* [$Fls 1020] */
/* Version checks */
#if (FLS_AR_RELEASE_MAJOR_VERSION != (4U)) || (FLS_AR_RELEASE_MINOR_VERSION != (2U)) || (FLS_AR_RELEASE_REVISION_VERSION != (2U))
 #error "FLS AUTOSAR version in FLS.h does not match 4.2.2"
#endif
#if (FLS_SW_MAJOR_VERSION != (1U)) || (FLS_SW_MINOR_VERSION != (0U)) || (FLS_SW_PATCH_VERSION != (54U))
 #error "FLS software version in FLS.h does not match 1.0.54"
#endif
#if (FLS_VENDOR_ID !=  (11U))
 #error "FLS Vendor ID in FLS.h does not match 11"
#endif


/*******************************************************************************
 *                              Helpers
 ******************************************************************************/
static boolean PreconditionFails(boolean truth, uint8 api, uint8 err, boolean fromAction);
static Std_ReturnType ValidateWithinFls(Fls_AddressType start_addr, Fls_LengthType num_bytes, uint8 apiId, boolean fromAction);
static Std_ReturnType ValidateSectorAligned(Fls_AddressType start_addr, uint8 apiId, boolean fromAction);
static Std_ReturnType ValidateFullySectorAligned(Fls_AddressType start_addr, Fls_LengthType num_bytes, uint8 apiId, boolean fromAction);
static Std_ReturnType ValidatePageAligned(Fls_AddressType start_addr, uint8 apiId, boolean fromAction);
static Std_ReturnType ValidateFullyPageAligned(Fls_AddressType start_addr, Fls_LengthType num_bytes, uint8 apiId, boolean fromAction);

/******************************************************************************/
Std_ReturnType RaiseDetError(uint32 instance, uint32 api, uint32 err, boolean fromAction) {
  fls_hw.ErrorCode = err;
  Fls_Device_UpdateDet(instance, api, err);
#if (FLS_DEV_ERROR_DETECT == STD_ON)
  if (!fromAction) {
    Det_ReportError(FLS_MODULE_ID, instance, api, err); /* [$Fls 261] */
  }
#endif
  return E_NOT_OK;
}

/******************************************************************************/
static boolean PreconditionFails(boolean truth, uint8 api, uint8 err, boolean fromAction) {
  if (!truth) {
    RaiseDetError(0, api, err, fromAction);
    Fls_Device_UpdateJob();
  }
  return !truth;
}

/******************************************************************************/
/* Is start address to start address + num_bytes within the overall flash?    */
/******************************************************************************/
static Std_ReturnType ValidateWithinFls(Fls_AddressType start_addr, Fls_LengthType num_bytes, uint8 apiId, boolean fromAction) {
  if (start_addr >= FLS_TOTAL_SIZE) {
    return RaiseDetError(0, apiId, FLS_E_PARAM_ADDRESS, fromAction); /* [$Fls 310] [$Fls 20] [$Fls 21] [$Fls 1243] */
  } else if ((num_bytes == 0) || (start_addr + num_bytes > FLS_TOTAL_SIZE)) {
    return RaiseDetError(0, apiId, FLS_E_PARAM_LENGTH, fromAction); /* [$Fls 1244] */
  }
  return E_OK;
}

/******************************************************************************/
/* Is start address aligned to a sector start?                                */
/******************************************************************************/
static Std_ReturnType ValidateSectorAligned(Fls_AddressType start_addr, uint8 apiId, boolean fromAction) {
  const Fls_SectorType* cSector = &Fls_GetInternalConfig()->FlsSectorList[0];
  uint16 sectorIndex = 0;
  for (sectorIndex = 0; sectorIndex < Fls_GetInternalConfig()->FlsSectorListSize; sectorIndex++) {
    /* [$Fls 310] [$Fls 20] */
    if (((start_addr - cSector->FlsSectorStartaddress) / cSector->FlsSectorSize) < cSector->FlsNumberOfSectors) {
      if (0 == ((start_addr - cSector->FlsSectorStartaddress) % cSector->FlsSectorSize)) {
        return E_OK;
      }
    }
    cSector++;
  }
  return RaiseDetError(0, apiId, FLS_E_PARAM_ADDRESS, fromAction); /* [$Fls 310] [$Fls 20] [$Fls 21] */
}

/******************************************************************************/
/* Is start address aligned to a page start?                                  */
/******************************************************************************/
static Std_ReturnType ValidatePageAligned(Fls_AddressType start_addr, uint8 apiId, boolean fromAction) {
  const Fls_SectorType* cSector = &Fls_GetInternalConfig()->FlsSectorList[0];
  uint16 sectorIndex = 0;
  for (sectorIndex = 0; sectorIndex < Fls_GetInternalConfig()->FlsSectorListSize; sectorIndex++) {
    /* [$Fls 310] [$Fls 20] */
    if (((start_addr - cSector->FlsSectorStartaddress) / cSector->FlsPageSize) < cSector->FlsNumberOfPages) {
      if (0 == ((start_addr - cSector->FlsSectorStartaddress) % cSector->FlsPageSize)) {
        return E_OK;
      }
    }
    cSector++;
  }
  return RaiseDetError(0, apiId, FLS_E_PARAM_ADDRESS, fromAction); /* [$Fls 310] [$Fls 20] [$Fls 21] */
}


/******************************************************************************/
/* Are start and end address aligned to a sector?                             */
/******************************************************************************/
static Std_ReturnType ValidateFullySectorAligned(Fls_AddressType start_addr, Fls_LengthType num_bytes, uint8 apiId, boolean fromAction) {
  Std_ReturnType ret = ValidateSectorAligned(start_addr, apiId, fromAction);
  if (ret == E_OK) {
    const Fls_SectorType* cSector = &Fls_GetInternalConfig()->FlsSectorList[0];
    if (num_bytes > 0) {
      start_addr = start_addr + num_bytes;
      uint16 sectorIndex = 0;
      for (sectorIndex = 0; sectorIndex < Fls_GetInternalConfig()->FlsSectorListSize; sectorIndex++) {
        if (((start_addr - cSector->FlsSectorStartaddress) / cSector->FlsSectorSize) <= cSector->FlsNumberOfSectors) {
          if (0 == ((start_addr - cSector->FlsSectorStartaddress) % cSector->FlsSectorSize)) {
            return E_OK;
          }
        }
        cSector++;
      }
    }
    return RaiseDetError(0, apiId, FLS_E_PARAM_LENGTH, fromAction);
  }
  return ret;
}

/******************************************************************************/
/* Are start and end address aligned to a page?                               */
/******************************************************************************/
static Std_ReturnType ValidateFullyPageAligned(Fls_AddressType start_addr, Fls_LengthType num_bytes, uint8 apiId, boolean fromAction) {
  Std_ReturnType ret = ValidatePageAligned(start_addr, apiId, fromAction);
  if (ret == E_OK) {
    const Fls_SectorType* cSector = &Fls_GetInternalConfig()->FlsSectorList[0];
    if (num_bytes > 0) {
      start_addr = start_addr + num_bytes;
      uint16 sectorIndex = 0;
      for (sectorIndex = 0; sectorIndex < Fls_GetInternalConfig()->FlsSectorListSize; sectorIndex++) {
        if (((start_addr - cSector->FlsSectorStartaddress) / cSector->FlsPageSize) <= cSector->FlsNumberOfPages) {
          if (0 == ((start_addr - cSector->FlsSectorStartaddress) % cSector->FlsPageSize)) {
            return E_OK;
          }
        }
        cSector++;
      }
    }
    return RaiseDetError(0, apiId, FLS_E_PARAM_LENGTH, fromAction);
  }
  return ret;
}

/*******************************************************************************
*                         API Provided to Eep.c
 ******************************************************************************/
extern "C" {

/******************************************************************************
* Fls_Init
******************************************************************************/
void Fls_Init_helper(const Fls_ConfigType* ConfigPtr, boolean fromAction) {
  /* [$Fls 268] [$Fls 312] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY), FLS_INIT_API_ID, FLS_E_BUSY, fromAction)) {
    return;
  }

  /* [$Fls 15] Retrofit to take NULL pointer in the init function */
  if (ConfigPtr != FLS_DEFAULT_CONFIG && ConfigPtr != NULL_PTR) {
    RaiseDetError(0, FLS_INIT_API_ID, FLS_E_PARAM_CONFIG, fromAction);
    Fls_Device_UpdateJob();
    return;
  }

  fls_hw.Init(&FlsConfigData[0]);
}

/******************************************************************************
* Fls_Erase
******************************************************************************/
Std_ReturnType Fls_Erase_helper(Fls_AddressType TargetAddress, Fls_LengthType Length, boolean fromAction) {
  Std_ReturnType ret = E_NOT_OK;

  Fls_Device_StartJob(FLS_ERASE_API_ID );

  /* [$Fls 65] [$Fls 311] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_ERASE_API_ID , FLS_E_UNINIT, fromAction)) {
    return ret;
  }
  /* [$Fls 23] [$Fls 312] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY),   FLS_ERASE_API_ID , FLS_E_BUSY, fromAction)) {
    return ret;
  }

  /* [$Fls 310] [$Fls 20] [$Fls 21] */
  if ((E_OK == ValidateWithinFls(TargetAddress, Length, FLS_ERASE_API_ID, fromAction)) && (E_OK == ValidateFullySectorAligned(TargetAddress, Length, FLS_ERASE_API_ID, fromAction))) {
    ret = fls_hw.Erase(TargetAddress, Length);
  }

  Fls_Device_UpdateJob(); /* [$Fls 1089] [$Fls 1090] */
  return ret;
}

/******************************************************************************
* Fls_Write
******************************************************************************/
Std_ReturnType Fls_Write_helper(Fls_AddressType TargetAddress, const uint8* SourceAddressPtr, Fls_LengthType Length, boolean fromAction) {
  Std_ReturnType ret = E_NOT_OK;

  Fls_Device_StartJob(FLS_WRITE_API_ID);

  /* [$Fls 66] [$Fls 311] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_WRITE_API_ID, FLS_E_UNINIT, fromAction)) {
    return ret;
  }
  /* [$Fls 30] [$Fls 312] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY), FLS_WRITE_API_ID, FLS_E_BUSY, fromAction)) {
    return ret;
  }

  /* [$Fls 310] [$Fls 26] [$Fls 27] */
  if ((E_OK == ValidateWithinFls(TargetAddress, Length, FLS_WRITE_API_ID, fromAction)) && (E_OK == ValidateFullyPageAligned(TargetAddress, Length, FLS_WRITE_API_ID, fromAction))) {
    /* [$Fls 157] */
    if (PreconditionFails((SourceAddressPtr != NULL_PTR), FLS_WRITE_API_ID, FLS_E_PARAM_DATA, fromAction)) {
      return ret;
    }
    ret = fls_hw.Write(TargetAddress, SourceAddressPtr, Length);
  }

  Fls_Device_UpdateJob(); /* [$Fls 1084] [$Fls 1085] */
  return(ret);
}

/******************************************************************************
* Fls_Cancel
******************************************************************************/
void Fls_Cancel_helper(boolean fromAction) {
  Fls_Device_StartJob(FLS_CANCEL_API_ID);

  /* [$Fls 356] [$Fls 311] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_CANCEL_API_ID, FLS_E_UNINIT, fromAction)) {
    return;
  }

  fls_hw.Cancel();
  /* [$Fls 1093] [$Fls 1094] */
  Fls_Device_UpdateJob();
}

/******************************************************************************
* Fls_BlankCheck
******************************************************************************/
Std_ReturnType Fls_BlankCheck_helper(Fls_AddressType TargetAddress, Fls_LengthType Length, boolean fromAction) {
  Std_ReturnType ret = E_NOT_OK;

  Fls_Device_StartJob(FLS_BLANKCHECK_API_ID );

  /* [$Fls 1245] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_BLANKCHECK_API_ID , FLS_E_UNINIT, fromAction)) {
    return ret;
  }
  /* [$Fls 1246] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY),   FLS_BLANKCHECK_API_ID , FLS_E_BUSY, fromAction)) {
    return ret;
  }

  /* [$Fls 1244] [$Fls 1243] */
  if (E_OK == ValidateWithinFls(TargetAddress, Length, FLS_BLANKCHECK_API_ID, fromAction)) { /* [$Fls  1255] */
    ret = fls_hw.BlankCheck(TargetAddress, Length); /* [$Fls 1240] [$Fls 1236] */
  }

  Fls_Device_UpdateJob(); /* [$Fls 1242] [$Fls 1241] */
  return ret;
}

/******************************************************************************
* Fls_BaseAddress
******************************************************************************/
uint32* Fls_BaseAddress(void) {
	return ((uint32 *)fls_hw.GetBaseAddress());
}

/******************************************************************************
* Fls_GetStatus
******************************************************************************/
MemIf_StatusType Fls_GetStatus_helper(void) {
  if (fls_hw.Status == MEMIF_UNINIT) { /* [$Fls 357] [$Fls 311] */
    return MEMIF_UNINIT;
  } else {
    return fls_hw.GetStatus();
  }
}

/******************************************************************************
* Fls_GetJobResult
******************************************************************************/
MemIf_JobResultType Fls_GetJobResult_helper(boolean fromAction) {
  /* [$Fls 358] [$Fls 311] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_GETJOBRESULT_API_ID, FLS_E_UNINIT, fromAction)) {
    return MEMIF_JOB_FAILED;
  }
  return fls_hw.JobResult;
}

/******************************************************************************
* Fls_Read
******************************************************************************/
Std_ReturnType Fls_Read_helper(Fls_AddressType SourceAddress, uint8* TargetAddressPtr, Fls_LengthType Length, boolean fromAction) {
  Std_ReturnType ret = E_NOT_OK;

  Fls_Device_StartJob(FLS_READ_API_ID);

  /* [$Fls 240] [$Fls 99] [$Fls 311] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_READ_API_ID, FLS_E_UNINIT, fromAction)) {
    return ret;
  }
  /* [$Fls 100] [$Fls 312] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY), FLS_READ_API_ID, FLS_E_BUSY, fromAction)) {
    return E_NOT_OK;
  }
  if (E_OK == ValidateWithinFls(SourceAddress, Length, FLS_READ_API_ID, fromAction)) {  /* [$Fls 97] [$Fls 310] [$Fls 98] */
    if (PreconditionFails((TargetAddressPtr != NULL_PTR), FLS_READ_API_ID, FLS_E_PARAM_DATA, fromAction)) {
      return E_NOT_OK;
    }  /* [$Fls 158] */
    ret = fls_hw.Read(SourceAddress, TargetAddressPtr, Length); /* [$Fls 236] */
  }

  Fls_Device_UpdateJob(); /* [$Fls 1086] [$Fls 1087] */
  return ret;
}

/******************************************************************************
* Fls_Compare
******************************************************************************/
Std_ReturnType Fls_Compare_helper(Fls_AddressType SourceAddress, const uint8* TargetAddressPtr, Fls_LengthType Length, boolean fromAction) {
  Std_ReturnType ret = E_NOT_OK;
  Fls_Device_StartJob(FLS_COMPARE_API_ID);
  /* [$Fls 152] [$Fls 311] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_COMPARE_API_ID, FLS_E_UNINIT, fromAction)) {
    return ret;
  }
  /* [$Fls 153] [$Fls 312] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY), FLS_COMPARE_API_ID, FLS_E_BUSY, fromAction)) {
    return ret;
  }
  if (E_OK == ValidateWithinFls(SourceAddress, Length, FLS_COMPARE_API_ID, fromAction)) {  /* [$Fls 150] [$Fls 310] [$Fls 151] */
    if (PreconditionFails((TargetAddressPtr != NULL_PTR), FLS_COMPARE_API_ID, FLS_E_PARAM_DATA, fromAction)) {
      return ret;
    }  /* [$Fls 273] */
   ret = fls_hw.Compare(SourceAddress, TargetAddressPtr, Length);
  }

  Fls_Device_UpdateJob(); /* [$Fls 1091] [$Fls 1092] */
  return ret;
}

/******************************************************************************
* Fls_SetMode
******************************************************************************/
void Fls_SetMode_helper(MemIf_ModeType Mode, boolean fromAction) {
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_SETMODE_API_ID, FLS_E_UNINIT, fromAction)) {
    return;
  }
  /* [$Fls 156] [$Fls 312] */
  if (PreconditionFails((fls_hw.Status != MEMIF_BUSY), FLS_SETMODE_API_ID, FLS_E_BUSY, fromAction)) {
    return;
  }
  fls_hw.SetMode(Mode);
}

/******************************************************************************
* Fls_GetVersionInfo
******************************************************************************/
/* [$Fls 165] */
void Fls_GetVersionInfo_helper(Std_VersionInfoType* VersioninfoPtr, boolean fromAction) {
  /* [$Fls 363] */
  if (PreconditionFails((VersioninfoPtr != NULL_PTR), FLS_GETVERSIONINFO_API_ID, FLS_E_PARAM_POINTER, fromAction)) {
    return;
  }
  VersioninfoPtr->vendorID = FLS_VENDOR_ID;
  VersioninfoPtr->moduleID = FLS_MODULE_ID;
  VersioninfoPtr->sw_major_version = FLS_SW_MAJOR_VERSION;
  VersioninfoPtr->sw_minor_version = FLS_SW_MINOR_VERSION;
  VersioninfoPtr->sw_patch_version = FLS_SW_PATCH_VERSION;
}

/******************************************************************************
* Fls_MainFunction
******************************************************************************/
void Fls_MainFunction_helper(boolean fromAction) {
  Fls_Device_UpdateJob();
  /* [$Fls 117] */
  if (PreconditionFails((fls_hw.Status != MEMIF_UNINIT), FLS_MAINFUNCTION_API_ID, FLS_E_UNINIT, fromAction)) {
    return;
  }
  if (fls_hw.JobResult == MEMIF_JOB_PENDING) {
    fls_hw.MainFunction(fromAction);  /* [$Fls 37] [$Fls 38] */
    Fls_Device_UpdateJob();
  }
}

}


