/*******************************************************************************
 * Autogenerated by MCALgen for MCAL V2.0.0.30631: BOACan.cpp
 *******************************************************************************/


#define CAN_BOA_DEBUG (0)
#define DYNAMIC_LOAD (1)

/************************************************************************************************************
 *                         Include Files
 ***********************************************************************************************************/
#ifdef unix
  #define __cdecl
  #define HINSTANCE void*
  #include <sys/stat.h>
  #include <limits.h>
  #include <unistd.h>
  #include <stdio.h>
  #include <stdlib.h>
  #include <pthread.h> 
  #include <dlfcn.h>
  #include <sys/types.h>
  #define HANDLE void*

  #define MAX_PATH 256

  typedef char TCHAR;
  typedef TCHAR *PTCHAR;

  pthread_cond_t cond1 = PTHREAD_COND_INITIALIZER; 
  pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
#else
  #include <windows.h>
#endif

#undef CONST


#if (defined _MSC_VER && !defined STRICT)
  #define STRICT
#endif
extern "C" {
  #include <OCI/oci.h>
  #include <CSI/csisfs.h>
  #include "MCalLogging.h"
#ifdef  ENABLE_EST_CAN_SUPPORT
  #include <EsseAifSnfOcdBoa/EsseAifSnfOcdBoa.h>
#endif      
}

#include "Can_HwProvider.hpp"
#include "vrtaCore.h"
#include "virtualDevice.hpp"
#include "Can_Implementation.h"

/************************************************************************************************************
 *                         BOA Driver Implementation
 ***********************************************************************************************************/
#define CAN_BOA_DRIVER_NAME           "BOACan"    // Driver name.
#define CAN_BOA_MAX_TX_INDEX          (1000000U)  // Can_HwHandleType is a uint16 so there can be
                                                  // at most 65536 transmit objects so this value
                                                  // is greater than the highest transmit object handle
                                                  // or transmit object array index.
#define CAN_BOA_NO_TX_INDEX           ((unsigned) -1)
#define CAN_BOA_RX_QUEUE_SIZE         (512U)      // The maximum number of frames to receive per receive
                                                  // iteration. A CAN frame is at least 44 bits long.
                                                  // So at 1000KB/s you would get a maximum of 22727 frames.
                                                  // Which is 1 frame every 44us. Since we are polling every
                                                  // 100us receiving upto 16 frames per iteration should be
                                                  // ample even with 2 controllers.
#define NUM_URIS                      (64U)       // Determines the size of m_UriName[] array.
#define CAN_BOA_MAX_RX_PER_ITERATION  (32U)
#define URI_BUFFER_SIZE               (512)
#define NULL_CHAR                     (0)         // VS2012 does not like ''
#define BACKSLASH                     (0x5C)
#define SYNC_SEG                      (1U)        // length of the sync segment in a CAN frame
#define NUM_OF_OCI_VERSIONS           (2U)        // Number of OCI supported versions for BOA support.

/* START structures enums and values for default sample points, BTL cycles, ... and other settings for Sending FD frames */
typedef struct {
  uint32 baudrate;
  uint32 samplePoint;
  uint32 BTL_Cycles;
  uint32 SJW;
} defaultCanConfiguration;

typedef struct {
  uint32  dataBitRate ;
  uint32  dataSamplePoint ;
  uint32  dataBTL_Cycles ;
  uint32  dataSJW ;
  uint32  txSecondarySamplePointOffset;
} defaultCanFdConfiguration;

typedef enum {
  canBaud20,
  canBaud50,
  canBaud100,
  canBaud125,
  canBaud250,
  canBaud500,
  canBaud800,
  canBaud1000,
  numberOfCanBauds
} canBaud;

typedef enum {
  canFbBitRate250,
  canFbBitRate500,
  canFbBitRate800,
  canFbBitRate1000,
  canFbBitRate2000,
  canFbBitRate4000,
  canFbBitRate5000,
  canFbBitRate6666,
  canFbBitRate8000,
  canFbBitRate10000,
  numberOfCanFdBitRates
} canFdBitRate;

// baudrate, samplePoint, BTL_Cycles, SJW
static const defaultCanConfiguration canConfig[numberOfCanBauds]  = {
  {20000, 80, 160, 32},
  {50000, 80, 160, 32},   // Tested
  {100000, 80, 160, 32},
  {125000, 80, 160, 32},
  {250000, 80, 160, 32},  // Tested
  {500000, 80, 160, 32},
  {800000, 80, 160, 32},
  {1000000,75, 40, 4}    // Tested
};

// dataBitRate, dataSamplePoint, dataBTL_Cycles, dataSJW, txSecondarySamplePointOffset
static const defaultCanFdConfiguration canFdConfig[numberOfCanFdBitRates]  = {
  {250000, 80, 40, 8, 77},
  {500000, 80, 40, 8, 77},  // Tested
  {800000, 80, 40, 8, 77},
  {1000000, 80, 40, 4, 75},
  {2000000, 80, 20, 4, 75}, // Tested
  {4000000, 80, 10, 2, 80}, // Tested
  {5000000, 80, 8, 2, 80},
  {6666666, 80, 7, 1, 80},
  {8000000, 80, 5, 1, 80},
  {10000000, 80, 3, 1, 80}
};
/* END structures enums and values for default sample points, BTL cycles, ... and other settings for Sending FD frames */

extern "C" {
  #define URI_LENGTH 256
  typedef char OCI_URIName[URI_LENGTH];
  // Can_BOA_Test_UriList array takes the user supplied Uri names and FindCANController() filters the urinames according to the allow / reject options supplied in the "BOA_Device_List"
  OCI_URIName Can_BOA_Test_UriList[NUM_URIS];
  // Test flag to enable / disable the BOA hwp to use the Can_BOA_Test_UriList[] array. Used only in the "Can_BOAHwP_UserList" test.
  bool Can_BOA_TestUriFlag = false;
  // Sets the total number of Controllers that needs to be initialised. This must match total number of Uris in the Can_BOA_Test_UriList[].
  // Used only in the the "Can_BOAHwP_UserList" test.
  unsigned Can_BOA_NumTestUris = 0;
  // Test File pointer to read from different device list. The list may contain different allow / reject options.
  // Used only in the the "Can_BOAHwP_UserList" test.
  FILE *Can_BOA_Testfp = NULL;
}

typedef int (__cdecl *CreateCANRxQueue)(OCI_ControllerHandle, OCI_CANRxQueueConfiguration *, OCI_QueueHandle*);
typedef int (__cdecl *DestroyCANRxQueue)(OCI_QueueHandle);
typedef int (__cdecl *CreateCANTxQueue) (OCI_ControllerHandle, OCI_CANTxQueueConfiguration *, OCI_QueueHandle *);
typedef int (__cdecl *DestroyCANTxQueue) (OCI_QueueHandle);
typedef int (__cdecl *AddCANFrameFilter) ( OCI_QueueHandle, OCI_CANRxFilter filter[],uint32);
typedef int (__cdecl *WriteCANData) (OCI_QueueHandle,  OCI_Time, OCI_CANMessage[], uint32, uint32*);
typedef int (__cdecl *ReadCANData) (OCI_QueueHandle,  OCI_Time, OCI_CANMessage[], uint32, uint32*, uint32*);
typedef int (__cdecl *CreateCANControllerVersion) (const char *, const BOA_Version *, OCI_ControllerHandle *);
typedef int (__cdecl *CreateCANControllerNoSearch) (const char *, const BOA_Version *, CSI_Tree *, OCI_ControllerHandle *);
typedef int (__cdecl *OpenCANController) (OCI_ControllerHandle, OCI_CANConfiguration *, OCI_CANControllerProperties *);
typedef int (__cdecl *CloseCANController) (OCI_ControllerHandle);
typedef int (__cdecl *DestroyCANController) (OCI_ControllerHandle);

typedef int (__cdecl *CreateProtocolTree)(const char *, CSI_NodeRange, CSI_Tree **);
typedef int (__cdecl *DestroyProtocolTree)(CSI_Tree *);

typedef int (__cdecl *GetCANControllerCapabilities)(OCI_ControllerHandle controller, OCI_CANControllerCapabilities * capabilities);
typedef int (__cdecl *WriteCANDataEx) (OCI_QueueHandle, OCI_Time, OCI_CANMessageEx* [], uint32, uint32*);
typedef int (__cdecl *ReadCANDataEx) (OCI_QueueHandle, OCI_Time, OCI_CANMessageEx* [], uint32, uint32*, uint32*);
#ifdef ENABLE_EST_CAN_SUPPORT
	typedef int(__cdecl *BoaOcdSnfInterface) (const char* uri);
#endif

// ---------------------------------------------------------------------------
// [$CANHWP 38] We cannot detect frame loss due to overrun or underrun.
// [$CANHWP 41] Automatic bus-off recovery cannot be configured.
// [$CANHWP 44] Not relevant to real CAN hardware.
// [$CANHWP 45] Not relevant to real CAN hardware.
// ---------------------------------------------------------------------------

class Can_BOA_TxObject {
public:
  Can_HwHandleType m_Handle;
  Can_Hwp_Frame m_Frame;
  uint8 m_FdPaddingValue;
  // These are used to communicate with the worker thread - hence they are
  // volatile and should be read/written with a single instruction.
  volatile bool m_InUse;   // True if the object in use.
  volatile bool m_Cancel; // True if the transmit in this object should be cancelled.

  Can_BOA_TxObject(void)
    : m_Handle(0U),
    m_InUse(false),
    m_Cancel(false) {
    m_FdPaddingValue = 0;
    memset(&m_Frame, 0, sizeof(m_Frame));
  }
};

// ---------------------------------------------------------------------------
class Can_BOA_RxObject {
public:
  Can_HwHandleType m_Handle;
  Can_Hwp_CanRxType m_RxType;
  Can_Hwp_CanIdType m_IdType;
  uint32 m_RxId;
  uint32 m_RxFilterMask;

  Can_BOA_RxObject(void) :
    m_Handle(0U),
    m_RxType(CAN_HWP_RXTYPE_BASIC),
    m_IdType(CAN_HWP_IDTYPE_STANDARD),
    m_RxId(0U),
    m_RxFilterMask(0U) {
  }
};


// ---------------------------------------------------------------------------
class Can_BOA_Controller {
public:
  const char*                 m_CtrlName;
  OCI_ControllerHandle        m_CtrlHandle;
  Can_Hwp_UpCall              m_UpCall;
  uint32                      m_UpCallContext;
  bool                        m_Configured;
  OCI_CANConfiguration        m_CtrlConfig;     // Configuration of the CAN controller
  OCI_CANControllerProperties m_CtrlProp;       // Properties of the CAN controller
  OCI_CANRxQueueConfiguration m_rxQConf;        // Receive Queue configurations
  OCI_CANTxQueueConfiguration m_txQConf;        // Transmit Queue configuration
  OCI_QueueHandle             m_rxQueueHandle;  // Receive Queue handle
  OCI_QueueHandle             m_txQueueHandle;  // Transmit Queue handle
  OCI_CANRxFilter             m_Filter[1];
  OCI_CANRxFilter *           m_PtrFilter[1];
  OCI_CANMessage              m_RxQueue[CAN_BOA_RX_QUEUE_SIZE];
  OCI_CANMessageEx            m_RxQueueEx[CAN_BOA_RX_QUEUE_SIZE];
  OCI_CANControllerCapabilities m_CtrlCap;
  BOA_Version                 m_version; // The version of BOA used to create this controller
  bool                        m_FdTxBitRateSwitch;

  bool                        m_CancelTxLowerPriority;
  bool                        m_CancelTxEqualPriority;

  unsigned                    m_NumTxObjects;
  unsigned                    m_LowestTxHandle;
  unsigned                    m_HighestTxHandle;
  Can_BOA_TxObject*           m_TxObjects;
  Can_BOA_TxObject*           m_ShadowTxObjects;
  unsigned                    m_ShadowTxIndex;
  unsigned                    m_HighestShadowTxIndex;
  unsigned*                   m_TxObjectsMap;
  unsigned                    m_NumRxObjects;
  Can_BOA_RxObject*           m_RxObjects;

  // These are used to communicate with the worker thread - hence they are
  // volatile and should be read/written with a single instruction.
  volatile Can_Hwp_Event      m_CurrentState;
  volatile Can_Hwp_Event      m_NewState;
  volatile unsigned           m_LowestTxIndex;
  volatile unsigned           m_HighestTxIndex;
  volatile bool               m_TxPending;
  volatile bool               m_CausedWakeup;
  volatile bool               m_EnableTxProcessing;
  volatile bool               m_ForceBusOff;
  volatile bool               m_ForceWakeup;
  volatile uint32             m_RxQueueHead;
  volatile uint32             m_RxQueueTail;
#ifdef  ENABLE_EST_CAN_SUPPORT
  const OcdSnfInterface_t*	  m_OcdSnfInterface;
#endif
  
  Can_BOA_Controller(void) :
    m_CtrlName(""),
    m_CtrlHandle(NULL_CPP_PTR),
    m_UpCall(NULL_CPP_PTR),
    m_UpCallContext(0U),
    m_Configured(false),
    m_rxQueueHandle(NULL_CPP_PTR),
    m_txQueueHandle(NULL_CPP_PTR),
    m_FdTxBitRateSwitch(true),
    m_CancelTxLowerPriority(false),
    m_CancelTxEqualPriority(false),

    m_NumTxObjects(0U),
    m_LowestTxHandle(CAN_BOA_MAX_TX_INDEX),
    m_HighestTxHandle(0U),
    m_TxObjects(NULL_CPP_PTR),
    m_ShadowTxObjects(NULL_CPP_PTR),
    m_ShadowTxIndex(CAN_BOA_MAX_TX_INDEX),
    m_HighestShadowTxIndex(0U),
    m_TxObjectsMap(NULL_CPP_PTR),
    m_NumRxObjects(0U),
    m_RxObjects(NULL_CPP_PTR),
#ifdef  ENABLE_EST_CAN_SUPPORT
    m_OcdSnfInterface(NULL_CPP_PTR),
#endif
    
    // [$CANHWP 4]
    m_CurrentState(CAN_HWP_EVENT_STOPPED),
    m_NewState(CAN_HWP_EVENT_STOPPED),
    m_LowestTxIndex(CAN_BOA_MAX_TX_INDEX),
    m_HighestTxIndex(0U),
    m_TxPending(false),
    m_CausedWakeup(false),
    m_EnableTxProcessing(true),
    m_ForceBusOff(false),
    m_ForceWakeup(false),
    m_RxQueueHead(0U),
    m_RxQueueTail(0U) {
    memset(&m_CtrlCap, 0, sizeof (m_CtrlCap));
  }

  void UpCall(Can_Hwp_Event event, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
    // [$CANHWP 46]
    m_UpCall(m_UpCallContext, event, handle, frame);
  }
};


// ---------------------------------------------------------------------------
static void Can_BOA_Teardown(void);
static void Can_BOA_WorkerThread(void);
static void Can_BOA_FrameCallback(void* userData, struct OCI_CANMessage* msg);
static void Can_BOA_FrameCallbackEx(void* userData, struct OCI_CANMessageEx* msg);

// ---------------------------------------------------------------------------

class Can_BOA_Driver {
private:
#if DYNAMIC_LOAD
  HINSTANCE hinstOcdLib;
  HINSTANCE hinstCsiLib;
  CreateCANRxQueue OCI_CreateCANRxQueue;
  DestroyCANRxQueue OCI_DestroyCANRxQueue;
  CreateCANTxQueue  OCI_CreateCANTxQueue;
  DestroyCANTxQueue OCI_DestroyCANTxQueue;
  AddCANFrameFilter OCI_AddCANFrameFilter;
  WriteCANData OCI_WriteCANData;
  ReadCANData OCI_ReadCANData;
  CreateCANControllerVersion OCI_CreateCANControllerVersion;
  CreateCANControllerNoSearch OCI_CreateCANControllerNoSearch;
  OpenCANController OCI_OpenCANController;
  CloseCANController OCI_CloseCANController;
  DestroyCANController OCI_DestroyCANController;
  CreateProtocolTree CSI_CreateProtocolTree;
  DestroyProtocolTree CSI_DestroyProtocolTree;
  GetCANControllerCapabilities OCI_GetCANControllerCapabilities;
  WriteCANDataEx OCI_WriteCANDataEx;
  ReadCANDataEx OCI_ReadCANDataEx;
  //AddCANFrameFilterEx OCI_AddCANFrameFilterEx;
  #ifdef  ENABLE_EST_CAN_SUPPORT
    HINSTANCE  hinstEsseAifSnfOcdBoaLib;
    BoaOcdSnfInterface  EsseAifSnfOcdBoa_getInterface;
  #endif  
#endif
  bool m_Initialised;                 // Has the driver been initialised OK?
  bool m_InitFailed;                  // Did initialise fail?
  volatile bool m_FatalError;         // Has something fatal happened?
  BOA_Version m_version[NUM_OF_OCI_VERSIONS];           // The version of BOA to use when creating a controller
  uint32 m_NumControllers;
  uint32 m_AllowControllers;
  Can_BOA_Controller* m_Controllers;  // Per-controller information.
  OCI_URIName m_UriName[NUM_URIS];
  OCI_URIName m_AllowUriName[NUM_URIS];
  volatile bool m_ThreadRunning;      // Is our worker thread running?
  HANDLE m_ThreadEvent;               // Event used to wakeup the worker thread.
#ifdef unix
    pthread_cond_t cond1 = PTHREAD_COND_INITIALIZER; 
#endif
  typedef struct {
    char pattern[URI_BUFFER_SIZE];
    bool allow;
  } m_CanUriTokens;


public:
  // ---------------------------------------------------------------
  Can_BOA_Driver(void) :
#if DYNAMIC_LOAD
    hinstOcdLib(NULL_CPP_PTR),
    hinstCsiLib(NULL_CPP_PTR),
    OCI_CreateCANRxQueue(NULL_CPP_PTR),
    OCI_DestroyCANRxQueue(NULL_CPP_PTR),
    OCI_CreateCANTxQueue(NULL_CPP_PTR),
    OCI_DestroyCANTxQueue(NULL_CPP_PTR),
    OCI_AddCANFrameFilter(NULL_CPP_PTR),
    OCI_WriteCANData(NULL_CPP_PTR),
    OCI_ReadCANData(NULL_CPP_PTR),
    OCI_CreateCANControllerVersion(NULL_CPP_PTR),
    OCI_CreateCANControllerNoSearch(NULL_CPP_PTR),
    OCI_OpenCANController(NULL_CPP_PTR),
    OCI_CloseCANController(NULL_CPP_PTR),
    OCI_DestroyCANController(NULL_CPP_PTR),
    CSI_CreateProtocolTree(NULL_CPP_PTR),
    CSI_DestroyProtocolTree(NULL_CPP_PTR),
    OCI_GetCANControllerCapabilities(NULL_CPP_PTR),
    OCI_WriteCANDataEx(NULL_CPP_PTR),
    OCI_ReadCANDataEx(NULL_CPP_PTR),
#endif
    m_Initialised(false),
    m_InitFailed(false),
    m_FatalError(false),
    m_NumControllers(0U),
    m_AllowControllers(0U),
    m_Controllers(NULL_CPP_PTR),
    m_ThreadRunning(false),
    m_ThreadEvent(NULL_CPP_PTR) {
      // initialise the array by latest version first.
      m_version[0].majorVersion = 1;
      m_version[0].minorVersion = 3;
      m_version[0].bugfix = 0;
      m_version[0].build = 0;

      m_version[1].majorVersion = 1;
      m_version[1].minorVersion = 0;
      m_version[1].bugfix = 0;
      m_version[1].build = 0;
      // Initialise the two dimensional m_UriName[] array to zero.
      for (unsigned i = 0U; i < NUM_URIS; i++) {
        strncpy(m_UriName[i], "", sizeof (OCI_URIName));
        strncpy(m_AllowUriName[i], "", sizeof (OCI_URIName));
    }
  }

  // ---------------------------------------------------------------
  ~Can_BOA_Driver(void) {
    for (uint32 i = 0U; i < m_NumControllers; i++) {
      // Destroying the CAN Controller.  This is the ultimate cleanup stage of the Controller and any Queues that it may own.
      OCI_ErrorCode ec = OCI_DestroyCANController(m_Controllers[i].m_CtrlHandle);
      if (!OCI_SUCCEEDED(ec)) {
        mcal_error("BOA", "OCI_DestroyCANController failed, Error Code: 0x%x\n", ec);
      } else {
        mcal_error("BOA", "OCI_DestroyCANController succeeded, Error Code: 0x%x\n", ec);
      }
    }
  }

  // ---------------------------------------------------------------
 void DeInitialise(void) {
    Teardown();
    delete [] m_Controllers;
    m_Initialised = false;
  }

  // ---------------------------------------------------------------
  void standardCanConfig(Can_BOA_Controller* ctrl) {
    memset(&ctrl->m_CtrlConfig, 0, sizeof (ctrl->m_CtrlConfig));
    ctrl->m_CtrlConfig.baudrate = 1000000;
    standardBOADefaultSettings(ctrl);
    ctrl->m_CtrlConfig.samplesPerBit = OCI_CAN_ONE_SAMPLE_PER_BIT;
    ctrl->m_CtrlConfig.syncEdge = OCI_CAN_SINGLE_SYNC_EDGE;
    ctrl->m_CtrlConfig.physicalMedia = OCI_CAN_MEDIA_HIGH_SPEED;
    ctrl->m_CtrlConfig.selfReceptionMode = OCI_SELF_RECEPTION_ON;
    ctrl->m_CtrlConfig.busParticipationMode = OCI_BUSMODE_ACTIVE;
  }

  // ---------------------------------------------------------------
  void standardBOADefaultSettings(Can_BOA_Controller* ctrl) {
    ctrl->m_CtrlConfig.samplePoint = 80;
    ctrl->m_CtrlConfig.BTL_Cycles = 10;
    ctrl->m_CtrlConfig.SJW = 1;
  }

  // ---------------------------------------------------------------
  void standardFdCanConfig(Can_BOA_Controller* ctrl) {
    ctrl->m_CtrlConfig.canFDConfig.dataBitRate = 2000000;
    standardFdBOADefaultSettings(ctrl);
    ctrl->m_CtrlConfig.canFDConfig.canFdTxConfig = OCI_CANFDTX_USE_CAN_AND_CANFD_FRAMES;
    ctrl->m_CtrlConfig.canFDConfig.canFdRxConfig.canFdRxMode = OCI_CANFDRXMODE_CANFD_FRAMES_USING_CANFD_MESSAGE;
    ctrl->m_CtrlConfig.canFDConfig.canFdRxConfig.canRxMode = OCI_CAN_RXMODE_CAN_FRAMES_USING_CAN_MESSAGE;
  }

   // ---------------------------------------------------------------
  void standardFdBOADefaultSettings(Can_BOA_Controller* ctrl) {
    ctrl->m_CtrlConfig.canFDConfig.dataBTL_Cycles = 10;
    ctrl->m_CtrlConfig.canFDConfig.dataSamplePoint = 80;
    ctrl->m_CtrlConfig.canFDConfig.dataSJW = 1;
    ctrl->m_CtrlConfig.canFDConfig.txSecondarySamplePointOffset = 0;
    ctrl->m_CtrlConfig.canFDConfig.flags = 0;
  }

  // ---------------------------------------------------------------
  // Initialise the BOA driver and create our worker thread. We
  // do this here rather than in the constructor so we can be sure
  // that all of the global C++ objects associated with vrta have
  // been created first.
  void Initialise(void) {
    // We will be called by he OS thread.
    vrtaEnterUninterruptibleSection();
    m_InitFailed = true;

    if (!LoadBOA()) {
      vrtaLeaveUninterruptibleSection();
      return;
    }
        /* Container for search results */
    CSI_Tree* sfsTree = NULL;
    FindCANController(&sfsTree);

    // Verify that CAN controllers have been found.
    if (m_NumControllers == 0) {
      mcal_warn("BOA", "No ETAS CAN Controllers have been found.  Please ensure that "
        "you have installed the Open Controller Driver of your CAN device and run "
        "this program again.\n\n");
      vrtaLeaveUninterruptibleSection();
      return;
    }

    // Initialise the BOA driver.
    m_Controllers = new Can_BOA_Controller[m_NumControllers];

    // Initialise the controller's state information.
    for (unsigned hwId = 0U; hwId < m_NumControllers; hwId++) {
      Can_BOA_Controller* ctrl = &m_Controllers[hwId];

      standardCanConfig(ctrl);
      ctrl->m_CtrlProp.mode = OCI_CONTROLLER_MODE_RUNNING; // We start in Running mode. The controller will be active on the CAN BUS immediately after OCI_OpenCANController

      // try to open controller with each version in turn
      uint32 number_of_api_versions = (sizeof (m_version)/sizeof (m_version[0]));
      for (uint32  i = 0; i < number_of_api_versions; i++ ) {
        ctrl->m_version = m_version[i]; // assign a version of API to try to the controller
        // We will now create a CAN Controller on the port indicated by the URI.
        // Even though the Controller is being created, it must be opened before it can be actually used to send or receive messages.
        OCI_ErrorCode ec = OCI_CreateCANControllerNoSearch(m_UriName[hwId], &ctrl->m_version, sfsTree, &ctrl->m_CtrlHandle);

        if (OCI_SUCCEEDED(ec)) {
#if CAN_BOA_DEBUG
          mcal_printf("BOA", "OCI_CreateCANControllerNoSearch HwID: 0x%x\n", hwId);
#endif
          break;    // creating the controller succeeded with this version of the BOA API
        } else if (i == number_of_api_versions - 1U) {
          mcal_error("BOA", "OCI_CreateCANControllerNoSearch failed,\n Error Code: 0x%x HwID: 0x%x Version Major 0x%x Minor 0x%x\n", ec, hwId, ctrl->m_version.majorVersion, ctrl->m_version.minorVersion);
          if (m_Controllers[hwId].m_CtrlHandle)
          {
            OCI_DestroyCANController(m_Controllers[hwId].m_CtrlHandle);
            mcal_error("BOA", "OCI_DestroyCANController HwID: 0x%x\n", hwId);
          }
        }
      }
      /* the last in the list of BOA APIs is 1.0 it doesn't support FD */
      if  ((ctrl->m_version.majorVersion == m_version[NUM_OF_OCI_VERSIONS-1].majorVersion )
        && (ctrl->m_version.minorVersion == m_version[NUM_OF_OCI_VERSIONS-1].minorVersion )) {
#if CAN_BOA_DEBUG
        mcal_printf("BOA", "BOA version 1.0 does not support CAN-FD\n");
#endif
      }

      SetCanFdEnabledFlagIfSupportedForThisController(ctrl);
      if (ControllerHasCanFdSupportEnabled(ctrl)) {
        standardFdCanConfig(ctrl);
      }
    }
#ifndef unix
    // Send events to the worker thread.
    if (!SetupEvent(m_ThreadEvent)) {
      for (uint32 i = 0U; i < m_NumControllers; i++) {
        // Destroying the CAN Controller.  This is the ultimate cleanup stage of the Controller and any Queues that it may own.
        OCI_ErrorCode ec = OCI_DestroyCANController(m_Controllers[i].m_CtrlHandle);
        if (!OCI_SUCCEEDED(ec)) {
          mcal_error("BOA", "OCI_DestroyCANController failed, Error Code: 0x%x\n", ec);
          /* Clean up the protocol tree. */
          OCI_ErrorCode ec = CSI_DestroyProtocolTree(sfsTree);
          if (!OCI_SUCCEEDED(ec)) {
              mcal_error("BOA", "CSI_DestroyProtocolTree failed! Error Code: 0x%x\n", ec);
          }
          vrtaLeaveUninterruptibleSection();
          return;
        } else {
          mcal_error("BOA", "OCI_DestroyCANController succeeded, Error Code: 0x%x\n", ec);
        }
      }
      /* Clean up the protocol tree. */
      OCI_ErrorCode ec = CSI_DestroyProtocolTree(sfsTree);
      if (!OCI_SUCCEEDED(ec)) {
        mcal_error("BOA", "CSI_DestroyProtocolTree failed! Error Code: 0x%x\n", ec);
      }
      vrtaLeaveUninterruptibleSection();
      return;
    }
#endif /* unix */

    /* Clean up the protocol tree. */
    OCI_ErrorCode ec = CSI_DestroyProtocolTree(sfsTree);
    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "CSI_DestroyProtocolTree failed! Error Code: 0x%x\n", ec);
    }

    // Start our worker thread running.
    m_ThreadRunning = true;
    vrtaSpawnThread(Can_BOA_WorkerThread);

    // Arrange for our Teardown() function to be called when the process terminates.
    atexit(Can_BOA_Teardown);

    m_InitFailed = false;
    m_Initialised = true;

    vrtaLeaveUninterruptibleSection();
  }

  // ---------------------------------------------------------------
  // Teardown the BOA driver and stop our worker thread. We
  // do this here rather than in the destructor so we can be sure
  // that all of the global C++ objects associated with vrta are
  // still valid.

  void Teardown(void) {
#if CAN_BOA_DEBUG
    mcal_printf("BOA", "%s: Teardown starts\n", CAN_BOA_DRIVER_NAME);
#endif
    if (m_Initialised) {
      for (uint32 i = 0U; i < m_NumControllers; i++) {
        // Destroying the CAN Controller.  This is the ultimate cleanup stage of the Controller and any Queues that it may own.
        OCI_ErrorCode ec = OCI_DestroyCANController(m_Controllers[i].m_CtrlHandle);
        if (!OCI_SUCCEEDED(ec)) {
          mcal_error("BOA", "OCI_DestroyCANController failed, Error Code: 0x%x\n", ec);
        }
      }
    }

#if CAN_BOA_DEBUG
    mcal_printf("BOA", "%s: Teardown ends\n", CAN_BOA_DRIVER_NAME);
#endif
  }

  // ---------------------------------------------------------------
  void  EnsureInitialisationHasBeenDone(void) {
    // If we've not already initialised the driver (and initialisation
    // hasn't previously failed) then initialise now.
    if (!m_Initialised && !m_InitFailed) {
      Initialise();
    }
  }

  // ---------------------------------------------------------------
  bool IsControllerPresent(uint32 hwId) {
    EnsureInitialisationHasBeenDone();

    bool presence = m_Initialised && (hwId < 10) && (hwId < m_NumControllers);
    return presence;
  }

  // ---------------------------------------------------------------
  // On return *name will point to a name that contains the name
  // of the BOA device.
  void AddController(uint32 hwId, const char** name, Can_Hwp_UpCall upCall, uint32 context) {
    EnsureInitialisationHasBeenDone();

    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];

    int len = strlen(*name) + strlen(m_UriName[hwId]) + 2;
    char * fullName = new char[len];

    strcpy(fullName, *name);
    strcat(fullName, "/");
    strcat(fullName, m_UriName[hwId]);

    *name = (const char *) fullName;

    ctrl->m_CtrlName = (const char *) fullName;
    ctrl->m_UpCall = upCall;
    ctrl->m_UpCallContext = context;
#ifdef ENABLE_EST_CAN_SUPPORT
    if (ctrl->m_OcdSnfInterface == 0) {
      ctrl->m_OcdSnfInterface = (const OcdSnfInterface_t *)EsseAifSnfOcdBoa_getInterface(m_UriName[hwId]);
    #if CAN_BOA_DEBUG
      mcal_printf("ESSE", "Esse BOA interface created successfully\n");
    #endif
    }
#endif    
  }

  // ---------------------------------------------------------------
  void ConfigureController(uint32 hwId, const Can_Hwp_ChannelConfig* config) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    if (config->numTxHwObjects == 0U || config->numRxHwObjects == 0U) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];

    // [$CANHWP 6]
    ctrl->m_CancelTxLowerPriority = config->txCancelLowerPriorityEnabled;
    ctrl->m_CancelTxEqualPriority = config->txCancelEqualPriorityEnabled;

    // Create transmit objects.
    ctrl->m_NumTxObjects = config->numTxHwObjects;
    ctrl->m_LowestTxHandle = CAN_BOA_MAX_TX_INDEX;
    ctrl->m_HighestTxHandle = 0U;
    ctrl->m_TxObjects = new Can_BOA_TxObject[ctrl->m_NumTxObjects];
    ctrl->m_ShadowTxObjects = new Can_BOA_TxObject[ctrl->m_NumTxObjects];

    for (unsigned i = 0U; i < ctrl->m_NumTxObjects; i++) {
      ctrl->m_TxObjects[i].m_Handle = config->txHwObjects[i].handle;
      ctrl->m_ShadowTxObjects[i].m_Handle = config->txHwObjects[i].handle;
       ctrl->m_TxObjects[i].m_FdPaddingValue = config->txHwObjects[i].fdPaddingValue;
       ctrl->m_ShadowTxObjects[i].m_FdPaddingValue = config->txHwObjects[i].fdPaddingValue;
      if (config->txHwObjects[i].handle < ctrl->m_LowestTxHandle) {
        ctrl->m_LowestTxHandle = config->txHwObjects[i].handle;
      }
      if (config->txHwObjects[i].handle > ctrl->m_HighestTxHandle) {
        ctrl->m_HighestTxHandle = config->txHwObjects[i].handle;
      }
    }

    // Create a map to get from frame transmit handle to transmit object quickly.
    unsigned mapSize = ctrl->m_HighestTxHandle - ctrl->m_LowestTxHandle + 1U;
    ctrl->m_TxObjectsMap = new unsigned[mapSize];

    for (unsigned i = 0U; i < mapSize; i++) {
      ctrl->m_TxObjectsMap[i] = CAN_BOA_NO_TX_INDEX;
    }

    for (unsigned i = 0U; i < ctrl->m_NumTxObjects; i++) {
      ctrl->m_TxObjectsMap[ctrl->m_TxObjects[i].m_Handle - ctrl->m_LowestTxHandle] = i;
    }

    ResetTransmitObjects(ctrl);

    // Create receive objects.
    ctrl->m_NumRxObjects = config->numRxHwObjects;
    ctrl->m_RxObjects = new Can_BOA_RxObject[ctrl->m_NumRxObjects];

    for (unsigned i = 0U; i < ctrl->m_NumRxObjects; i++) {
      ctrl->m_RxObjects[i].m_Handle = config->rxHwObjects[i].handle;
      ctrl->m_RxObjects[i].m_RxType = config->rxHwObjects[i].rxType;
      ctrl->m_RxObjects[i].m_IdType = config->rxHwObjects[i].idType;
      ctrl->m_RxObjects[i].m_RxId = config->rxHwObjects[i].rxId;
      ctrl->m_RxObjects[i].m_RxFilterMask = config->rxHwObjects[i].rxFilterMask;
    }

    ctrl->m_Configured = true;
  }

  // ---------------------------------------------------------------
  void applyCanDefaultConfig(Can_BOA_Controller* ctrl, canBaud baudRate){
    ctrl->m_CtrlConfig.baudrate = canConfig[baudRate].baudrate;
    ctrl->m_CtrlConfig.samplePoint = canConfig[baudRate].samplePoint;
    ctrl->m_CtrlConfig.BTL_Cycles = canConfig[baudRate].BTL_Cycles;
    ctrl->m_CtrlConfig.SJW = canConfig[baudRate].SJW;
  }

  // ---------------------------------------------------------------
  void applyCanFdDefaultConfig(Can_BOA_Controller* ctrl, canFdBitRate bitRate){
    ctrl->m_CtrlConfig.canFDConfig.dataBitRate = canFdConfig[bitRate].dataBitRate;
    ctrl->m_CtrlConfig.canFDConfig.dataSamplePoint = canFdConfig[bitRate].dataSamplePoint ;
    ctrl->m_CtrlConfig.canFDConfig.dataBTL_Cycles = canFdConfig[bitRate].dataBTL_Cycles;
    ctrl->m_CtrlConfig.canFDConfig.dataSJW = canFdConfig[bitRate].dataSJW;
    ctrl->m_CtrlConfig.canFDConfig.txSecondarySamplePointOffset = canFdConfig[bitRate].txSecondarySamplePointOffset;
  }

  // ---------------------------------------------------------------
  void SetControllerBaudrate(uint32 hwId, const Can_Hwp_BaudrateConfig* baudrate) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];

  if(baudrate->fdBaudrateConfig != NULL_PTR) {
    if (baudrate->fdBaudrateConfig->baudrate != 0) {
      if (   (baudrate->baudrate > baudrate->fdBaudrateConfig->baudrate)
          && (ctrl->m_FdTxBitRateSwitch == TRUE )){
        mcal_error("BOA", "%s: FD baudrate %uKB is lower than CAN Baudrate %uKB\n ", ctrl->m_CtrlName, baudrate->fdBaudrateConfig->baudrate, baudrate->baudrate);
        return;
      }
    }
  }

    // [$CANHWP 6] [$CANHWP 53]
    standardBOADefaultSettings(ctrl);
    switch (baudrate->baudrate) {
      case 20U:   { applyCanDefaultConfig(ctrl, canBaud20 );  break; }
      case 50U:   { applyCanDefaultConfig(ctrl, canBaud50 );  break; }
      case 100U:  { applyCanDefaultConfig(ctrl, canBaud100 );  break; }
      case 125U:  { applyCanDefaultConfig(ctrl, canBaud125 );  break; }
      case 250U:  { applyCanDefaultConfig(ctrl, canBaud250 );  break; }
      case 500U:  { applyCanDefaultConfig(ctrl, canBaud500 );  break; }
      case 800U:  { applyCanDefaultConfig(ctrl, canBaud800 );  break; }
      case 1000U: { applyCanDefaultConfig(ctrl, canBaud1000 );  break; }
      default:    { mcal_error("BOA", "%s: Invalid baudrate %uKB/s specified", ctrl->m_CtrlName, baudrate->baudrate); break; }
    }
    // Calculations for CAN frames timings
    // [$CAN 1208] [$CAN  1209] [$CAN  1210]

/*
 * implementation of the Bit timing calculations removed until a customer requires the configuration
 * ability using default values until then
*/
//    // [$CANHWP 56]
//    if(baudrate->fdBaudrateConfig != NULL_PTR) {
//      if ((baudrate->propagationDelay !=0) && (baudrate->phaseSegment1 !=0) && (baudrate->phaseSegment2!=0))
//      {
//        uint32 BTL_Cycles = (SYNC_SEG + baudrate->propagationDelay + baudrate->phaseSegment1 + baudrate->phaseSegment2);
//        ctrl->m_CtrlConfig.samplePoint = (((SYNC_SEG + baudrate->propagationDelay + baudrate->phaseSegment1 ) * 100U)
//                                         / (BTL_Cycles));
//        ctrl->m_CtrlConfig.BTL_Cycles = BTL_Cycles;
//        ctrl->m_CtrlConfig.SJW = baudrate->syncJumpWidth;   //[$CAN  1211]
//      }
//    }
#if CAN_BOA_DEBUG
    mcal_printf("BOA","%s: baud: %d prop: %d seg1: %d seg2: %d, BTL %d, sjw: %d sample %d\n ",
      ctrl->m_CtrlName, ctrl->m_CtrlConfig.baudrate,
      baudrate->propagationDelay, baudrate->phaseSegment1, baudrate->phaseSegment2,
      ctrl->m_CtrlConfig.BTL_Cycles, ctrl->m_CtrlConfig.SJW, ctrl->m_CtrlConfig.samplePoint);
#endif

    // [$CANHWP 56]
    if(baudrate->fdBaudrateConfig != NULL_PTR) {
      if (baudrate->fdBaudrateConfig->baudrate != 0) {
        /*
         * if we have had a baudrate change that had no valid FD config the
         * canFDEnabled flag is set to false. We now have a new baudrate, check if
         * it is valid and re-enable the canFDEnabled
         */
        SetCanFdEnabledFlagIfSupportedForThisController(ctrl);
        standardFdBOADefaultSettings(ctrl);
        //[$CAN 1207] [$CANHWP 56]
        switch (baudrate->fdBaudrateConfig->baudrate) {
          case 250U:    { applyCanFdDefaultConfig(ctrl, canFbBitRate250 );    break; }
          case 500U:    { applyCanFdDefaultConfig(ctrl, canFbBitRate500 );    break; }
          case 800U:    { applyCanFdDefaultConfig(ctrl, canFbBitRate800 );    break; }
          case 1000U:   { applyCanFdDefaultConfig(ctrl, canFbBitRate1000 );   break; }
          case 2000U:   { applyCanFdDefaultConfig(ctrl, canFbBitRate2000 );   break; }
          case 4000U:   { applyCanFdDefaultConfig(ctrl, canFbBitRate4000 );   break; }
          case 5000U:   { applyCanFdDefaultConfig(ctrl, canFbBitRate5000 );   break; }
          case 6666U:   { applyCanFdDefaultConfig(ctrl, canFbBitRate6666 );   break; }
          case 8000U:   { applyCanFdDefaultConfig(ctrl, canFbBitRate8000 );   break; }
          case 10000U:  { applyCanFdDefaultConfig(ctrl, canFbBitRate10000 );  break; }
          //case 12000U:  { ctrl->m_CtrlConfig.canFDConfig.dataBitRate = 12000000;  break; }
          //case 16000U:  { ctrl->m_CtrlConfig.canFDConfig.dataBitRate = 16000000;  break; }
          default:      { mcal_error("BOA", "%s: Invalid FD baudrate %uKB/s specified", ctrl->m_CtrlName, baudrate->fdBaudrateConfig->baudrate); break; }
        }

        if (ctrl->m_CtrlConfig.canFDConfig.dataBitRate > ctrl->m_CtrlCap.canFDMaxQualifiedDataRate) {
          mcal_error("BOA", "%s: FD baudrate %uKB above maximum data rate supported by the CAN-FD controller under all possible conditions\n ", ctrl->m_CtrlName, baudrate->fdBaudrateConfig->baudrate);
        }
        if (ctrl->m_CtrlConfig.canFDConfig.dataBitRate > ctrl->m_CtrlCap.canFDMaxDataRate) {
          mcal_error("BOA", "%s: FD baudrate %uKB above maximum data rate supported by the CAN-FD controller\n ", ctrl->m_CtrlName, baudrate->fdBaudrateConfig->baudrate);
        }

/*
 * implementation of the Bit timing calculations removed until a customer requires the configuration
 * ability using default values until then
*/
//        //If we do the calculations for CAN frames correctly the following are the calculations/mappings
//        // [$CAN 1208] [$CAN 1209] [$CAN 1210]
//        if ((baudrate->fdBaudrateConfig->propagationDelay != 0) && (baudrate->fdBaudrateConfig->phaseSegment1 !=0 ) && (baudrate->fdBaudrateConfig->phaseSegment2 != 0))
//        {
//          uint32 dataBTL_Cycles = (SYNC_SEG + baudrate->fdBaudrateConfig->propagationDelay + baudrate->fdBaudrateConfig->phaseSegment1 + baudrate->fdBaudrateConfig->phaseSegment2);
//          ctrl->m_CtrlConfig.canFDConfig.dataSamplePoint = (((SYNC_SEG + baudrate->fdBaudrateConfig->propagationDelay + baudrate->fdBaudrateConfig->phaseSegment1 ) * 100U)
//                                                           / (dataBTL_Cycles));
//          ctrl->m_CtrlConfig.canFDConfig.dataBTL_Cycles = dataBTL_Cycles;
//          ctrl->m_CtrlConfig.canFDConfig.dataSJW = baudrate->fdBaudrateConfig->syncJumpWidth;   //[$CAN 1211]
//          ctrl->m_CtrlConfig.canFDConfig.txSecondarySamplePointOffset = baudrate->fdBaudrateConfig->trcvDelayCompensationOffset;
//        } else {
//          mcal_printf("BOA", "Bit timing quanta must be configured for correct functioning of CAN-FD. Default CAN-FD timings used. CAN-FD functionality not guaranteed. \n ");
//        }

        if (ctrl->m_CtrlConfig.canFDConfig.txSecondarySamplePointOffset > 0) {  // [$CAN 1212]
          ctrl->m_CtrlConfig.canFDConfig.flags |= OCI_CANFD_FLAG_TX_DELAY_COMPENSATION;
        } else {
          ctrl->m_CtrlConfig.canFDConfig.flags &= ~(OCI_CANFD_FLAG_TX_DELAY_COMPENSATION);
        }

        ctrl->m_FdTxBitRateSwitch = baudrate->fdBaudrateConfig->txBitRateSwitch;      //[$CAN 1213]
#if CAN_BOA_DEBUG
        mcal_printf("BOA","%s: Baud: %d FDprop: %d FDseg1: %d FDseg2: %d, dataBTL %d, dataSJW: %d sample %d comp %d switch %d flags: %d\n ",
          ctrl->m_CtrlName, ctrl->m_CtrlConfig.canFDConfig.dataBitRate,
          baudrate->fdBaudrateConfig->propagationDelay, baudrate->fdBaudrateConfig->phaseSegment1, baudrate->fdBaudrateConfig->phaseSegment2,
          ctrl->m_CtrlConfig.canFDConfig.dataBTL_Cycles, ctrl->m_CtrlConfig.canFDConfig.dataSJW, ctrl->m_CtrlConfig.canFDConfig.dataSamplePoint,
          ctrl->m_CtrlConfig.canFDConfig.txSecondarySamplePointOffset, ctrl->m_FdTxBitRateSwitch, ctrl->m_CtrlConfig.canFDConfig.flags);
#endif
      }
    } else {
      if (ctrl->m_CtrlConfig.canFDEnabled) {
        mcal_error("BOA", "%s: canFDEnabled but no CAN-FD config\n ", ctrl->m_CtrlName);
        ctrl->m_CtrlConfig.canFDEnabled = 0;
      }
    }
  }

  // ---------------------------------------------------------------
  void StartController(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    // [$CANHWP 5]
    // We don't need to lock here because we can write the new state atomically
    // and the worker thread "acknowledges" the change by setting the current state.
    ctrl->m_NewState = CAN_HWP_EVENT_RUNNING;

    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  void SleepController(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    // Clear any knowledge about previous wakeup events.
    // [$CANHWP 22]
    ctrl->m_CausedWakeup = false;

    // [$CANHWP 8]
    // We don't need to lock here because we can write the new state atomically
    // and the worker thread "acknowledges" the change by setting the current state.
    ctrl->m_NewState = CAN_HWP_EVENT_SLEEPING;
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  void StopController(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    // [$CANHWP 10]
    // We don't need to lock here because we can write the new state atomically
    // and the worker thread "acknowledges" the change by setting the current state.
    ctrl->m_NewState = CAN_HWP_EVENT_STOPPED;

    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  bool ControllerCausedWakeup(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return false;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return false;
    }

    // [$CANHWP 21] [$CANHWP 22]
    return ctrl->m_CausedWakeup;
  }

  // -----------------------------------------------------------------------
  Can_Hwp_Event State(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return CAN_HWP_EVENT_STOPPED;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return CAN_HWP_EVENT_STOPPED;
    }

    // [$CANHWP 48] [$CANHWP 49] [$CANHWP 50]
    return ctrl->m_CurrentState;
  }

  // -----------------------------------------------------------------------
  void ForceBusOff(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    ctrl->m_ForceBusOff = true;
    SendEvent(m_ThreadEvent);
  }

  // -----------------------------------------------------------------------
  void ForceWakeup(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return;
    }
    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }
    ctrl->m_ForceWakeup = true;
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  Can_ReturnType Write(uint32 hwId, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
    if (!m_Initialised || hwId >= m_NumControllers || m_FatalError) {
      return CAN_NOT_OK;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return CAN_NOT_OK;
    }

    if (frame->length > CAN_MAX_FRAME_LENGTH) {
      return CAN_NOT_OK;
    }

    if (handle < ctrl->m_LowestTxHandle || handle > ctrl->m_HighestTxHandle) {
      return CAN_NOT_OK;
    }

    unsigned txIndex = ctrl->m_TxObjectsMap[handle - ctrl->m_LowestTxHandle];
    if (txIndex == CAN_BOA_NO_TX_INDEX) {
      return CAN_NOT_OK;
    }

    Can_BOA_TxObject* txObj = &ctrl->m_TxObjects[txIndex];

    Can_ReturnType retCode = CAN_OK;

    // Obtain the lock to make sure that this code and the the worker thread
    // see a consistent view of the transmit object. Specifically we don't want
    // this code to claim that an object is busy but the worker thread to
    // generate a transmit completion for it.
    VECU_LOCK();

    // Silently drop transmits if we are not fully attached to the network.
    if (ctrl->m_CurrentState == CAN_HWP_EVENT_RUNNING) {

      if (txObj->m_InUse) {
        // The transmit object is busy so we need to work out if we should cancel
        // the transmit. Since frame ID's are stored in canonical form (i.e. the
        // MSB is set for an extended frame) we can just compare IDs to compare
        // priorities. The rule is that standard frames always have a higher
        // priority than extended frames and within a frame type the smaller
        // identifier has a higher priority.

        // If the transmit object contains a higher priority frame then leave it alone.
        // [$CANHWP 15]
        if (txObj->m_Frame.id < frame->id) {
          // Nothing to do - retCode is set to CAN_BUSY later.
        }
          // If the transmit object contains a lower priority frame then cancel it
          // if lower priority cancellation is enabled.
        else if (txObj->m_Frame.id > frame->id) {
          // [$CANHWP 16]
          if (ctrl->m_CancelTxLowerPriority) {
            txObj->m_Cancel = true;
          }            // [$CANHWP 17]
          else {
            // Nothing to do - retCode is set to CAN_BUSY later.
          }
        }
          // If the transmit object contains an equal priority frame then cancel it
          // if equal priority cancellation is enabled.
        else {
          // [$CANHWP 18]
          if (ctrl->m_CancelTxEqualPriority) {
            txObj->m_Cancel = true;
          }            // [$CANHWP 19]
          else {
            // Nothing to do - retCode is set to CAN_BUSY later.
          }
        }
        retCode = CAN_BUSY;
      }
      else {
        // Transmit object is not busy so put the new frame in it.
        // [$CANHWP 20]
        txObj->m_InUse = true;
        txObj->m_Cancel = false;
          if(CAN_ID_FD_BIT_SET(frame->id)) {  /* [$CAN 1163] [$CAN 1229] [$CAN 1230] [$CAN 1233] */
            uint8 frameLength = frame->length;
            if(frame->length > 8 && frame->length < 12) frame->length = 12;
            if(frame->length > 12 && frame->length < 16) frame->length = 16;
            if(frame->length > 16 && frame->length < 20) frame->length = 20;
            if(frame->length > 20 && frame->length < 24) frame->length = 24;
            if(frame->length > 24 && frame->length < 32) frame->length = 32;
            if(frame->length > 32 && frame->length < 48) frame->length = 48;
            if(frame->length > 48 && frame->length < 64) frame->length = 64;

            for(int i = frameLength; i < frame->length; i++) { /*  [$CAN 1203] [$CAN 1234] */
              frame->data[i] = txObj->m_FdPaddingValue;
            }
          }
        memcpy(&txObj->m_Frame, frame, sizeof (Can_Hwp_Frame));
        retCode = CAN_OK;
      }

      // Tell the worker thread that there is transmit work to be done.
      if (txIndex < ctrl->m_LowestTxIndex) {
        ctrl->m_LowestTxIndex = txIndex;
      }
      if (txIndex > ctrl->m_HighestTxIndex) {
        ctrl->m_HighestTxIndex = txIndex;
      }

      ctrl->m_TxPending = true;
    }

    VECU_UNLOCK();

    // Wakeup the worker thread to do the actual transmit or transmit cancellation.
    SendEvent(m_ThreadEvent);
    return retCode;
  }

  // ---------------------------------------------------------------
  bool BoaApiHasCanFdSupport(){
    // return true if there is at least one of the API's that can support CAN-FD
    return ((m_version[0].majorVersion == 1)
      && (m_version[0].minorVersion >= 3));
  }

  // ---------------------------------------------------------------
  bool ControllerHasCanFdSupport(Can_BOA_Controller* ctrl){
    bool result = false;
    if (BoaApiHasCanFdSupport())
    {
      // return true if the controller we are using supports CAN-FD
      result = ((ctrl->m_version.majorVersion == 1)
      && (ctrl->m_version.minorVersion >= 3));
  }
    return result;
  }

  // ---------------------------------------------------------------
  void SetCanFdEnabledFlagIfSupportedForThisController(Can_BOA_Controller* ctrl){
    if (ControllerHasCanFdSupport(ctrl)){
      ctrl->m_CtrlConfig.canFDEnabled = false;                 // AUTOSAR version doesn't support FD but wish to use the latest API support
      OCI_ErrorCode ec;
      ec = OCI_GetCANControllerCapabilities(ctrl->m_CtrlHandle, &ctrl->m_CtrlCap);
      if (!OCI_SUCCEEDED(ec)) {
        mcal_error("BOA", "OCI_GetCANControllerCapabilities failed, Error Code: 0x%x\n", ec);
      } else {
        if ((ctrl->m_CtrlCap.canFDSupport & OCI_CANFDSUPPORT) == OCI_CANFDSUPPORT) {
          ctrl->m_CtrlConfig.canFDEnabled = true;                 // Specifies CAN-FD configuration is used
        }
      }
    }
  }

  // ---------------------------------------------------------------
  bool ControllerHasCanFdSupportEnabled(Can_BOA_Controller* ctrl){
    bool result = false;
    if (ControllerHasCanFdSupport(ctrl)) // require wrappers so that we don't use any CAN-FD properties if the BOA API doesn't support it
    {
      // return true if the controller we are using supports CAN-FD
      result = (ctrl->m_CtrlConfig.canFDEnabled);
    }
    return result;
  }

  // ---------------------------------------------------------------
  void WorkerThread(void) {
#if CAN_BOA_DEBUG
    mcal_printf("BOA", "%s: Worker thread started\n", CAN_BOA_DRIVER_NAME);
#endif

    while (!vrtaIsAppFinished()) {

      if (!m_FatalError) {
        for (unsigned i = 0U; i < m_NumControllers; i++) {
          Can_BOA_Controller* ctrl = &m_Controllers[i];
          if (ctrl->m_Configured) {
            // Do we need to change the state of the controller?
            if (ctrl->m_NewState != ctrl->m_CurrentState) {
              ChangeControllerState(ctrl);
              if (!m_FatalError) {
                // [$CANHWP 7] [$CANHWP 9] [$CANHWP 12]
                Can_Hwp_Frame frame;
                ctrl->UpCall(ctrl->m_CurrentState, 0U, &frame);
              }
            }
            // Force bus-off if required.
            // [$CANHWP 51]
            if (ctrl->m_ForceBusOff) {
              HandleBusOff(ctrl);
              // Clear any request to go bus-off.
              // [$CANHWP 52]
              ctrl->m_ForceBusOff = false;
            }
            // Force wakeup if required.
            // [$CANHWP 54]
            if (ctrl->m_ForceWakeup && ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
              HandleWakeup(ctrl);
            }
            // We may need to transmit one or more frames.
            if (ctrl->m_TxPending && ctrl->m_EnableTxProcessing) {
              TransmitFrames(ctrl);
            }

            // Process any receives.
            if (ControllerHasCanFdSupport(ctrl)) {
              ReceiveFramesEx(ctrl);
            } else {
              ReceiveFrames(ctrl);
            }
          }
        }
      }
      // Wait until someone sends us an event.
      WaitForEvent(m_ThreadEvent);
    }

    m_ThreadRunning = false;

#if CAN_BOA_DEBUG
    mcal_printf("BOA", "%s: Worker thread ended\n", CAN_BOA_DRIVER_NAME);
#endif
  }

  // ---------------------------------------------------------------
  void EnableTransmitProcessing(uint32 hwId, bool enable) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_BOA_Controller* ctrl = &m_Controllers[hwId];
    ctrl->m_EnableTxProcessing = enable;

    if (enable) {
      SendEvent(m_ThreadEvent);
    }
  }

  // ---------------------------------------------------------------
  // this is valid for BOA API 1.0 and 1.3
  void QueueRxFrame(Can_BOA_Controller* ctrl, OCI_CANMessage* msg) {
    if (ctrl->m_CurrentState != CAN_HWP_EVENT_RUNNING &&
      ctrl->m_CurrentState != CAN_HWP_EVENT_SLEEPING) {
      // Must not receive anything when stopped.
      return;
    }

    uint32 nextQueueHead = (ctrl->m_RxQueueHead + 1) % CAN_BOA_RX_QUEUE_SIZE;

    // If the buffer is full drop frame otherwise add it
    // to the buffer.
    if (nextQueueHead != ctrl->m_RxQueueTail) {
      // Do not cache the ctrl->m_RxQueueHead in a local variable
      // because we want to stop the compiler from updating
      // ctrl->m_RxQueueHead with nextQueueHead until after
      // the memcpy (ctrl->m_RxQueueHead is volatile).
      memcpy(&ctrl->m_RxQueue[ctrl->m_RxQueueHead], msg, sizeof (OCI_CANMessage));
      ctrl->m_RxQueueHead = nextQueueHead;
    }

    // Wakeup the worker thread even if we drop the frame so that the
    // worker thread runs to handle any transmits in the shadow
    // buffers.
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  // this is valid for BOA API 1.3 and above
  void QueueRxFrameEx(Can_BOA_Controller* ctrl, OCI_CANMessageEx * msg) {
    if (ctrl->m_CurrentState != CAN_HWP_EVENT_RUNNING &&
      ctrl->m_CurrentState != CAN_HWP_EVENT_SLEEPING) {
      // Must not receive anything when stopped.
      return;
    }

    uint32 nextQueueHead = (ctrl->m_RxQueueHead + 1) % CAN_BOA_RX_QUEUE_SIZE;
     // If the buffer is full drop frame otherwise add it
    // to the buffer.
    if (nextQueueHead != ctrl->m_RxQueueTail) {
      // Do not cache the ctrl->m_RxQueueHead in a local variable
      // because we want to stop the compiler from updating
      // ctrl->m_RxQueueHead with nextQueueHead until after
      // the memcpy (ctrl->m_RxQueueHead is volatile).
      memcpy(&ctrl->m_RxQueueEx[ctrl->m_RxQueueHead], msg, sizeof (OCI_CANMessageEx));
      ctrl->m_RxQueueHead = nextQueueHead;
    }

    // Wakeup the worker thread even if we drop the frame so that the
    // worker thread runs to handle any transmits in the shadow
    // buffers.
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  bool Match(const char* pattern, const char* str) {
    for (;;) {
      // There is also a special case where pattern ends with a * and all of pattern
      // and str match up to the final *.
      if (*pattern == '*' && (NULL_CHAR == *(pattern + 1))) {
        return true;
      }
      // If we've hit the end of both pattern and str then we've got a match.
      else if (((NULL_CHAR == *pattern )) && (NULL_CHAR == *str )) {
        return true;
      }
      // If we've hit the end of one but not the other then we have a mismatch.
      else if ((NULL_CHAR == *pattern ) || (NULL_CHAR == *str )) {
        return false;
      }
      // * matches 0 or more arbitrary characters (at this point we know that the * is not
      // the last character in pattern).
      else if (*pattern == '*') {
        do {
          if (Match(pattern + 1, str)) {
            return true;
          }
          str++;
        } while (NULL_CHAR != *str );
        return false;
      }
        // # matches a digit - anything else matches itself.
      else if (*pattern == *str || (*pattern == '#' && *str >= '0' && *str <= '9')) {
        pattern++;
        str++;
      }
      else {
        return false;
      }
    }
  }

  // ---------------------------------------------------------------
  //  Recursively scans a tree of CSI nodes created by CSI_CreateProtocolTree() and copies the URI-Paths
  //  for all devices that support CAN.
  OCI_ErrorCode FindCanNodes(CSI_Tree* sfsTree, OCI_URIName uriNames[], OCI_URIName uriPrefix, uint32 size, uint32* position) {
    OCI_ErrorCode ec = OCI_SUCCESS;

    /* Does the current tree node have the URI name which begins with "CAN:"?
     * (Each node which represents a CAN port always has a URI name of the form "CAN:n". */
    if (0 == strncmp(sfsTree->item.uriName, "CAN:", 4)) {
      if (*position < size) {
        strcpy(uriNames[ *position ], uriPrefix);
        strcat(uriNames[ *position ], "/");
        strcat(uriNames[ *position ], sfsTree->item.uriName);
        (*position)++;
      } else {
        mcal_error("BOA", "Not enough space to list all connected devices.");
        return OCI_ERR_OUT_OF_MEMORY;
      }
    }

    /* If the current tree node has a child, recurse into it */
    if (sfsTree->child) {
      OCI_URIName newUriPrefix;
      strcpy(newUriPrefix, uriPrefix);
      strcat(newUriPrefix, "/");
      strcat(newUriPrefix, sfsTree->item.uriName);
      FindCanNodes(sfsTree->child, uriNames, newUriPrefix, size, position);
    }

    /* If there's a sibling, go into it */
    if (sfsTree->sibling) {
      ec = FindCanNodes(sfsTree->sibling, uriNames, uriPrefix, size, position);
    }
    return ec;
  }

  // ---------------------------------------------------------------
  // Copy the filtered/test uri names into the m_UriName buffer
  void CopyUriNames(OCI_URIName *UriSrc, uint32 AllowControlCount, bool TestFlag) {
    unsigned int k = 0;

    if(TestFlag) {
      m_NumControllers = AllowControlCount;
    }

    for (unsigned i = 0; i < m_NumControllers; i++) {
      // Clear the list so that we can store only the allowed controllers
      strncpy(m_UriName[i], "", sizeof (OCI_URIName));
      if(NULL_CHAR != UriSrc[i][0]) {
        // Copy the filtered Urinames into the m_UriName buffer
        strcpy(m_UriName[k], UriSrc[i]);
        k++;
      }
    }
  }

  // ---------------------------------------------------------------
  // Open the BOA_Device_List.txt and read the allow / reject list and extract the pattern.
  // This pattern is used to filter the Urinames.
  unsigned int ReadPatternFromList(FILE *fp, m_CanUriTokens *CanList) {

    char buffer[URI_BUFFER_SIZE];
    static unsigned ListIdx = 0;
    strcpy(buffer, "");

    while (ListIdx < NUM_URIS && fgets(buffer, URI_BUFFER_SIZE, (FILE *) fp) != NULL) {
      if (0 != strcmp(buffer, "\n")) {
        char *command = strtok(buffer, " 	");
        if (command != NULL) {
          if ((*command == '\n') || ((false == Match("allow", command)) && (false == Match("reject", command)))) {
            continue;
          }
          if (!(Match("allow", command))) {
            CanList[ListIdx].allow = false;
          }
          strcpy(CanList[ListIdx].pattern, strtok(NULL, "\r\n"));
          ListIdx++;
        }
      }
      strcpy(buffer, "");
    }

    for (unsigned i = 0; i < ListIdx; i++) {
      const char *pattern = CanList[i].pattern;
      char temp[URI_BUFFER_SIZE];
      unsigned int j = 0;
      do {
        while ((*pattern == '	') || (*pattern == ' ')) {
          pattern++;
        }
        *(temp+j) = *pattern;
        j++;
      } while (*pattern++ != NULL_CHAR);

      *(temp+j) = NULL_CHAR;
      strcpy(CanList[i].pattern, temp);
    }

    return ListIdx;
  }

  // ---------------------------------------------------------------
  // based on the allow / reject pattern filter the UriNames in the m_UriName[]
  void FilterUriNames(m_CanUriTokens *CanList, unsigned int ListIdx) {

    for (unsigned int i = 0; i < ListIdx; i++) {
      // Copy the allow UriNames into a seperate list : m_AllowUriName[]
      if (CanList[i].allow) {
        for (unsigned int j = 0; j < m_NumControllers; j++) {
          bool matchFound = Match(CanList[i].pattern, m_UriName[j]);
          if (matchFound && ((m_UriName)[j])[0] != NULL_CHAR) {
            strcpy(m_AllowUriName[m_AllowControllers], m_UriName[j]);
            strncpy(m_UriName[j], "", sizeof (OCI_URIName));
            m_AllowControllers++;
          }
        }
      } else {
        // Reject the Uris based on reject pattern.
        // Process the Main list : m_UriName[].
        for (unsigned int j = 0; j < m_NumControllers; j++) {
          bool matchFound = Match(CanList[i].pattern, m_UriName[j]);
          if (matchFound) {
            strncpy(m_UriName[j], "", sizeof (OCI_URIName));
          }
        }
        // Process the allow list : m_AllowUriName[]
        for (unsigned int k = 0; k < m_NumControllers; k++) {
          bool matchFound = Match(CanList[i].pattern, m_AllowUriName[k]);
          if (matchFound) {
            strncpy(m_AllowUriName[k], "", sizeof (OCI_URIName));
            m_AllowControllers --;
          }
        }
      }
    }
  }

  // ---------------------------------------------------------------
  //Sort the Uri list in the alphabetical order such that controllers of same type are aligned together.
  void SortUriNamesInAlphabeticalOrder(OCI_URIName *UriSrc, uint32 numControllers) {
    OCI_URIName uriTemp;
    unsigned int i = 0, j = 0;
    bool SwapFlag = false;
    for (i = 1; i < numControllers; i++) {
      for (j = 1; j < numControllers; j++) {
        if (strcmp(UriSrc[j - 1], UriSrc[j]) > 0) {
          SwapFlag = true;
          strcpy(uriTemp, UriSrc[j - 1]);
          strcpy(UriSrc[j - 1], UriSrc[j]);
          strcpy(UriSrc[j], uriTemp);
        }
      }
      if(SwapFlag == false) {
        return;
      }
    }
  }

  // ---------------------------------------------------------------
  // Search for the available CAN controllers connected via BOA. Filter the CAN controllers
  // based on the allow / reject options supplied through the BOA_Device_List.txt. If such
  // device list doesn't exist, then the FindCANController returns all the devices conneted via BOA.
  void FindCANController(CSI_Tree** sfsTree) {
    FILE *fp = NULL;
    OCI_ErrorCode ec = OCI_SUCCESS;

    if (!Can_BOA_TestUriFlag) {
      TCHAR szPath[MAX_PATH];
      PTCHAR p;
      // Locates where the virtual device is present and adds the "BOA_Device_List.txt" name to the path
#ifndef unix
      if( !GetModuleFileName( NULL, szPath, MAX_PATH ) ) {
        mcal_printf("BOA", "Cannot install service \n");
      } else {
#else
        readlink("/proc/self/exe", szPath, MAX_PATH);
#endif
        p = szPath;
        do {
          p++;
        } while( *p != NULL_CHAR);

        do{
          p--;
#ifndef unix
        } while(*p != BACKSLASH);
#else
        } while(*p != '/');
#endif
        p++;
        *p = NULL_CHAR;
        strcat(szPath, "BOA_Device_List.txt");
        fp = fopen(szPath, "r");
#ifndef unix
      }
#endif
    } else {
      fp = Can_BOA_Testfp;
    }

    static unsigned ListIdx = 0; // Index to allow / reject options in the BOA_Device_List.txt
    m_CanUriTokens CanList[NUM_URIS]; // Stores the allow / reject pattern

    if (NULL == fp) {
      mcal_error("BOA", "BOA_Device_List.txt file not found.\n");
      // process it as an empty list.
      // BOA_Device_List.txt does not exist and so the index is zero.
      ListIdx = 0;
    } else {
      // By default set the allow flag it to true
      for (unsigned i = 0; i < NUM_URIS; i++) {
        CanList[i].allow = true;
      }
      ListIdx = ReadPatternFromList(fp, CanList);

      fclose((FILE *) fp);
    }
    /* Specify that we want to search for physical hardware nodes */
    const CSI_NodeRange nodeRange = {CSI_NODE_MIN, CSI_NODE_MAX};
    OCI_URIName uriPrefix = "ETAS:/"; /* The prefix of the URI of the root of the device tree */

    /* Search for all connected hardware and latch the result for further processing */
    ec = CSI_CreateProtocolTree("", nodeRange, sfsTree);
    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "CSI_CreateProtocolTree failed! Error Code: 0x%x\n", ec);
      return;
    }

    /* Browse tree and fill array with the results */
    m_NumControllers = 0;
    ec = FindCanNodes(*sfsTree, m_UriName, uriPrefix, (uint32) NUM_URIS, &m_NumControllers);
    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "Scanning the Protocol Tree failed! Error Code: 0x%x\n", ec);
      return;
    }

    SortUriNamesInAlphabeticalOrder(m_UriName, m_NumControllers);
    // Print the UriNames so that the user can know the BOA devices connected to the PC.
    char* enVar = getenv("DISPLAY_BOA_URI_LIST");
    if (enVar != NULL) {
      for (uint32 loop = 0; loop < m_NumControllers; loop++) {
        mcal_printf("BOA UriList", "[%d]: %s \n", loop, m_UriName[loop]);
      }
    }

    if (Can_BOA_TestUriFlag) {
      SortUriNamesInAlphabeticalOrder(Can_BOA_Test_UriList, Can_BOA_NumTestUris);
      CopyUriNames(Can_BOA_Test_UriList, Can_BOA_NumTestUris, TRUE);
    }
    // Filter UriNames only of there are any allow / reject patterns available in the BOA_Device_List.txt file
    if (0 != ListIdx) {
      // Filtering the UriNames according to the UserList. perform the filtering only if there are any allow / reject options in the list.
      FilterUriNames(CanList, ListIdx);

      // Copy the allowed controllers to m_UriName buffer. TestFlag is set to FALSE
      CopyUriNames(m_AllowUriName, m_AllowControllers, FALSE);

      m_NumControllers = m_AllowControllers;
    }

    if (Can_BOA_TestUriFlag) {
      // The Can_BOA_Test_UriList is used in the Can_BOAHwP_UserList test
      if (0 != Can_BOA_NumTestUris) {
        for (unsigned i = 0; i < Can_BOA_NumTestUris; i++) {
          // Clear the list so that we can store only the allowed devices
          strncpy(Can_BOA_Test_UriList[i], "", sizeof (OCI_URIName));
        }
        // Copy the final uri list back to the Can_BOA_Test_UriList array.
        for (unsigned i = 0; i < m_NumControllers; i++) {
          strcpy(Can_BOA_Test_UriList[i], m_UriName[i]);
        }
        Can_BOA_NumTestUris = m_NumControllers;
      } else {
        mcal_error("BOA", "Can_BOA_NumTestUris cannot be empty.");
        // Clean up the protocol tree.
        ec = CSI_DestroyProtocolTree(*sfsTree);
        if (!OCI_SUCCEEDED(ec)) {
          mcal_error("BOA", "CSI_DestroyProtocolTree failed! Error Code: 0x%x\n", ec);
        }
        return;
      }
    }
    if (0 == m_NumControllers) {
      mcal_error("BOA", "No Controllers found.");
    /* Clean up the protocol tree. */
      ec = CSI_DestroyProtocolTree(*sfsTree);
      if (!OCI_SUCCEEDED(ec)) {
        mcal_error("BOA", "CSI_DestroyProtocolTree failed! Error Code: 0x%x\n", ec);
      }
      return;
    }

#if CAN_BOA_DEBUG
    for (unsigned i = 0; i < m_NumControllers; i++) {
      mcal_printf("BOA", "m_UriName[%d] = %s\n", i, m_UriName[i]);
    }
    mcal_printf("BOA", "Number of controllers = %u\n", m_NumControllers);
#endif

  }

  // ---------------------------------------------------------------
  bool LoadBOA() {
#if DYNAMIC_LOAD
    //-------------- LoadLibrary and get the OCI function addresses from dll ----------------
#ifdef unix
    hinstOcdLib = dlopen("libocdproxy.so", RTLD_NOW);
    hinstCsiLib = dlopen("libcsiBind.so", RTLD_NOW);
    #define GetProcAddress dlsym
#else
    hinstOcdLib = LoadLibrary("dll-ocdProxy.dll");
    hinstCsiLib = LoadLibrary("dll-csiBind.dll");
#endif

    if (hinstOcdLib) {
      OCI_CreateCANControllerVersion = (CreateCANControllerVersion) GetProcAddress(hinstOcdLib, "OCI_CreateCANControllerVersion");
      OCI_CreateCANControllerNoSearch = (CreateCANControllerNoSearch) GetProcAddress(hinstOcdLib, "OCI_CreateCANControllerNoSearch");
      OCI_OpenCANController = (OpenCANController) GetProcAddress(hinstOcdLib, "OCI_OpenCANController");
      OCI_CreateCANRxQueue = (CreateCANRxQueue) GetProcAddress(hinstOcdLib, "OCI_CreateCANRxQueue");
      OCI_AddCANFrameFilter = (AddCANFrameFilter) GetProcAddress(hinstOcdLib, "OCI_AddCANFrameFilter");
      OCI_CreateCANTxQueue = (CreateCANTxQueue) GetProcAddress(hinstOcdLib, "OCI_CreateCANTxQueue");
      OCI_WriteCANData = (WriteCANData) GetProcAddress(hinstOcdLib, "OCI_WriteCANData");
      OCI_ReadCANData = (ReadCANData) GetProcAddress(hinstOcdLib, "OCI_ReadCANData");
      OCI_DestroyCANRxQueue = (DestroyCANRxQueue) GetProcAddress(hinstOcdLib, "OCI_DestroyCANRxQueue");
      OCI_DestroyCANTxQueue = (DestroyCANTxQueue) GetProcAddress(hinstOcdLib, "OCI_DestroyCANTxQueue");
      OCI_CloseCANController = (CloseCANController) GetProcAddress(hinstOcdLib, "OCI_CloseCANController");
      OCI_DestroyCANController = (DestroyCANController) GetProcAddress(hinstOcdLib, "OCI_DestroyCANController");
    }
  if (hinstOcdLib && BoaApiHasCanFdSupport()) {
      OCI_GetCANControllerCapabilities = (GetCANControllerCapabilities) GetProcAddress(hinstOcdLib, "OCI_GetCANControllerCapabilities");
      OCI_WriteCANDataEx = (WriteCANDataEx) GetProcAddress(hinstOcdLib, "OCI_WriteCANDataEx");
      OCI_ReadCANDataEx = (ReadCANDataEx) GetProcAddress(hinstOcdLib, "OCI_ReadCANDataEx");
    }

    if (hinstCsiLib) {
      CSI_CreateProtocolTree = (CreateProtocolTree) GetProcAddress(hinstCsiLib, "CSI_CreateProtocolTree");
      CSI_DestroyProtocolTree = (DestroyProtocolTree) GetProcAddress(hinstCsiLib, "CSI_DestroyProtocolTree");
    }

    if (
      !hinstOcdLib ||
      !hinstCsiLib ||
      !OCI_CreateCANControllerVersion ||
      !OCI_CreateCANControllerNoSearch ||
      !OCI_OpenCANController ||
      !OCI_CreateCANRxQueue ||
      !OCI_AddCANFrameFilter ||
      !OCI_CreateCANTxQueue ||
      !OCI_WriteCANData ||
      !OCI_ReadCANData ||
      !OCI_DestroyCANRxQueue ||
      !OCI_DestroyCANTxQueue ||
      !OCI_CloseCANController ||
      !OCI_DestroyCANController ||
      !CSI_CreateProtocolTree ||
      !CSI_DestroyProtocolTree ||
      (!OCI_GetCANControllerCapabilities  && BoaApiHasCanFdSupport()) ||
      (!OCI_WriteCANDataEx && BoaApiHasCanFdSupport()) ||
      (!OCI_ReadCANDataEx  && BoaApiHasCanFdSupport()
      )
    ) {
      mcal_error("BOA", "BOA DLLs could not be loaded. Please check your PATH or reinstall BOA.");
      return FALSE;
    }
  #ifdef  ENABLE_EST_CAN_SUPPORT
    system("taskkill /IM LoopbackServer.exe /F");
    hinstEsseAifSnfOcdBoaLib = LoadLibrary("EsseAifSnfOcdBoa.dll");
    if (hinstEsseAifSnfOcdBoaLib)
    {
      EsseAifSnfOcdBoa_getInterface = (BoaOcdSnfInterface)GetProcAddress(hinstEsseAifSnfOcdBoaLib, "EsseAifSnfOcdBoa_getInterface");
    #if CAN_BOA_DEBUG
      mcal_printf("ESSE", "ESSE Dlls is loaded\n");
    #endif
    } else {
        mcal_error("ESSE", "ESSE DLLs could not be loaded. Please check your PATH or reinstall ESSE drivers.");
        return FALSE;
    }
  #endif    
#endif
    return TRUE;
  }

private:
  // ---------------------------------------------------------------
  void HandleBusOff(Can_BOA_Controller* ctrl) {
    if (m_FatalError) {
      return;
    }

    //Can_Hwp_Event oldState = ctrl->m_CurrentState;

    // [$CANHWP 42]
    ctrl->m_NewState = CAN_HWP_EVENT_STOPPED;
    ChangeControllerState(ctrl);

    // [$CANHWP 43]
    Can_Hwp_Frame frame;
    ctrl->UpCall(CAN_HWP_EVENT_BUSOFF, 0U, &frame);
  }

  // ---------------------------------------------------------------
  void HandleWakeup(Can_BOA_Controller* ctrl) {
    if (m_FatalError) {
      return;
    }

    // [$CANHWP 39]
    ctrl->m_NewState = CAN_HWP_EVENT_STOPPED;
    ChangeControllerState(ctrl);

    // [$CANHWP 21]
    ctrl->m_CausedWakeup = true;

    Can_Hwp_Frame frame;
    ctrl->UpCall(CAN_HWP_EVENT_WAKEUP, 0U, &frame);
  }

  // ---------------------------------------------------------------
  OCI_ErrorCode SetupCanRxQueue(Can_BOA_Controller* ctrl) {
    if ( ControllerHasCanFdSupport(ctrl) ) {
      ctrl->m_rxQConf.onFrame.functionEx = Can_BOA_FrameCallbackEx; // Frame reception call-back for OCI 1.3.
      ctrl->m_rxQConf.onEvent.functionEx = NULL;
    } else {
      ctrl->m_rxQConf.onFrame.function = Can_BOA_FrameCallback; // Frame reception call-back for BOA API 1.0.
      ctrl->m_rxQConf.onEvent.function = NULL;
    }
    ctrl->m_rxQConf.onFrame.userData = (void*) ctrl; // Userdata for the frame reception.
    ctrl->m_rxQConf.onEvent.userData = NULL; // Userdata for the event reception - may be used to use one callback implementation for several CAN port instances. Not used here
    ctrl->m_rxQConf.selfReceptionMode = OCI_SELF_RECEPTION_ON; // We do want to receive our own frames

    // Create the Rx Queue on the Controller, using the Configuration defined above.
    return (OCI_ErrorCode)OCI_CreateCANRxQueue(ctrl->m_CtrlHandle, &ctrl->m_rxQConf, &ctrl->m_rxQueueHandle);
  }

  // ---------------------------------------------------------------
  void StartUpController(Can_BOA_Controller* ctrl, bool *failed) {
    // If there are frames in m_RxQueue[] when we enter the stopped state they
    // will stay there (ReceiveFrames will not process m_RxQueue in the stopped
    // state) so we need to reset the receive buffer pointers before we
    // re-enter a running state.
    ctrl->m_RxQueueHead = 0U;
    ctrl->m_RxQueueTail = 0U;

    // [$CANHWP 6]
    // Open the controller with new configuration...
    OCI_ErrorCode ec = OCI_OpenCANController(ctrl->m_CtrlHandle, &ctrl->m_CtrlConfig, &ctrl->m_CtrlProp);

    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "OCI_OpenCANController failed, Error Code: 0x%x\n", ec);
      *failed = true;
    }

    if (!(*failed)) {
      OCI_ErrorCode ec = SetupCanRxQueue(ctrl);
      if (OCI_FAILED(ec)) {
        mcal_error("BOA", "OCI_CreateCANRxQueue failed, Error Code: 0x%x\n", ec);
        *failed = true;
      }
    }

    if (!(*failed)) {
      // In order to receive a frame, or an event message, we must add some White Filters to the Rx Queue. white filter condition enables the reception of
      // CAN frames for a specific CAN receive queue. Any message that matches the criteria of the filter will be passed to the callback function of the client.
      ctrl->m_Filter[0].frameIDMask = 0; // The ID of a received frame will be ANDed with this value (will always result in 0 in this example).
      ctrl->m_Filter[0].frameIDValue = 0; // The ID of a received frame ANDed with frameIDMask will be compared against this value.
      ctrl->m_Filter[0].tag = 0; // We need no tag in this application. We can set any value. It will be ignored by the application.

      ec = OCI_AddCANFrameFilter(ctrl->m_rxQueueHandle, ctrl->m_Filter, 1);
      if (!OCI_SUCCEEDED(ec)) {
        mcal_error("BOA", "OCI_AddCANFrameFilter failed, Error Code: 0x%x\n", ec);
        *failed = true;
      }
    }
    if (!(*failed)) {
      ec = OCI_CreateCANTxQueue(ctrl->m_CtrlHandle, &ctrl->m_txQConf, &ctrl->m_txQueueHandle);
      if (!OCI_SUCCEEDED(ec)) {
        mcal_error("BOA", "OCI_CreateCANTxQueue failed, Error Code: 0x%x\n", ec);
        *failed = true;
      }
    }
  }

  // ---------------------------------------------------------------
  void ShutdownController(Can_BOA_Controller* ctrl, bool *failed) {
    // Destroy the Transmit / Receive queues before destroying the controller
    OCI_ErrorCode ec = OCI_DestroyCANRxQueue(ctrl->m_rxQueueHandle);
    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "OCI_DestroyCANRxQueue failed, Error Code: 0x%x\n", ec);
    }

    ec = OCI_DestroyCANTxQueue(ctrl->m_txQueueHandle);
    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "OCI_DestroyCANTxQueue failed, Error Code: 0x%x\n", ec);
    }

    // Closing the CAN Controller.  This step may be skipped at this stage since the Controller is about to be destroyed.
    // When an open controller is destroyed, it is first closed internally ensuring that the Queues are destroyed.
    ec = OCI_CloseCANController(ctrl->m_CtrlHandle);

    if (!OCI_SUCCEEDED(ec)) {
      mcal_error("BOA", "OCI_CloseCANController failed, Error Code: 0x%x\n", ec);
      *failed = true;
    }
  }

  // ---------------------------------------------------------------
  void ChangeControllerState(Can_BOA_Controller* ctrl) {
    if (m_FatalError) {
      return;
    }
#if CAN_BOA_DEBUG
    mcal_printf("BOA", "ChangeControllerState %s current 0x%x new 0x%x\n", ctrl->m_CtrlName, ctrl->m_CurrentState, ctrl->m_NewState);
#endif
    // Copy the new state to avoid it changing under our feet.
    Can_Hwp_Event newState = ctrl->m_NewState;
    bool failed = false;

    if (ctrl->m_CurrentState == CAN_HWP_EVENT_STOPPED) {
      // For both the RUNNING and the SLEEPING states we want to open the controller and
      // start it running on the network.
      // [$CANHWP 5][$CANHWP 8]
      if (newState == CAN_HWP_EVENT_RUNNING || newState == CAN_HWP_EVENT_SLEEPING) {
        StartUpController(ctrl, &failed);
      }
      else if (newState == CAN_HWP_EVENT_STOPPED) {
        // Nothing to do.
      }
    }
    else if (ctrl->m_CurrentState == CAN_HWP_EVENT_RUNNING || ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
      // To switch to STOPPED state we want to stop the controller running on the network
      // and close it.
      // [$CANHWP 10]
      if (newState == CAN_HWP_EVENT_STOPPED) {
        ShutdownController(ctrl, &failed);
      }
      else if (newState == CAN_HWP_EVENT_RUNNING || newState == CAN_HWP_EVENT_SLEEPING) {
        // Nothing to do.
      }
    }

    if (failed) {
      // Not being able to change the state is a catastrophic failed.
      m_FatalError = true;
    } else {
      // Once we've set m_CurrentState to CAN_HWP_EVENT_STOPPED or CAN_HWP_EVENT_SLEEPING
      // no more writes will be accepted.
      ctrl->m_CurrentState = newState;

      if (newState != CAN_HWP_EVENT_RUNNING) {
        // Hold the lock to force this code to wait until Write has finished in the event that
        // Write has claimed the lock and tested ctrl->m_CurrentState before we set it to
        // something other than CAN_HWP_EVENT_RUNNING.
        // [$CANHWP 11] [$CANHWP 42]
        VECU_LOCK();
        ResetTransmitObjects(ctrl);
        VECU_UNLOCK();
      }

      // Clear any request to wakeup.
      // [$CANHWP 55]
      ctrl->m_ForceWakeup = false;
    }
  }

  // ---------------------------------------------------------------
  void ResetTransmitObjects(Can_BOA_Controller* ctrl) {
    for (unsigned i = 0U; i < ctrl->m_NumTxObjects; i++) {
      ctrl->m_TxObjects[i].m_InUse = false;
    }

    ctrl->m_LowestTxIndex = CAN_BOA_MAX_TX_INDEX;
    ctrl->m_HighestTxIndex = 0U;
    ctrl->m_ShadowTxIndex = CAN_BOA_MAX_TX_INDEX;
    ctrl->m_HighestShadowTxIndex = 0U;
    ctrl->m_TxPending = false;
  }

#if CAN_BOA_DEBUG
  // ---------------------------------------------------------------
  void DisplayTransmitFDExDebug(Can_BOA_Controller* ctrl, Can_BOA_TxObject* txObj, OCI_CANMessageEx *txMsg)  {
    mcal_printf("BOA", "%s: TransmitFDEx: index= handle=%u ID=%08x length=%u Baudrate: %d dataBitRate: %d flags %d\n",
      ctrl->m_CtrlName,
      /*i,*/ txObj->m_Handle,
      txMsg->data.canFDTxMessage.frameID, txMsg->data.canFDTxMessage.size,
      ctrl->m_CtrlConfig.baudrate, ctrl->m_CtrlConfig.canFDConfig.dataBitRate,
      txMsg->data.canFDTxMessage.flags);
    for (int i = 0; i <= 63; i+=8)
    {
      mcal_printf("BOA", "data=%02x %02x %02x %02x %02x %02x %02x %02x\n",
      txMsg->data.canFDTxMessage.data[i], txMsg->data.canFDTxMessage.data[i+1],
      txMsg->data.canFDTxMessage.data[i+2], txMsg->data.canFDTxMessage.data[i+3],
      txMsg->data.canFDTxMessage.data[i+4], txMsg->data.canFDTxMessage.data[i+5],
      txMsg->data.canFDTxMessage.data[i+6], txMsg->data.canFDTxMessage.data[i+7]);
    }
  }
#endif

#if CAN_BOA_DEBUG
  // ---------------------------------------------------------------
  void DisplayTransmitExDebug(Can_BOA_Controller* ctrl, Can_BOA_TxObject* txObj, OCI_CANMessageEx *txMsg)  {
    mcal_printf("BOA", "%s: Transmit: index= handle=%u ID=%08x length=%u\n",
      ctrl->m_CtrlName,
      /*i,*/ txObj->m_Handle,
      txMsg->data.txMessage.frameID, txMsg->data.txMessage.dlc);
      int i = 0;
      mcal_printf("BOA", "data=%02x %02x %02x %02x %02x %02x %02x %02x\n",
      txMsg->data.txMessage.data[i], txMsg->data.txMessage.data[i+1],
      txMsg->data.txMessage.data[i+2], txMsg->data.txMessage.data[i+3],
      txMsg->data.txMessage.data[i+4], txMsg->data.txMessage.data[i+5],
      txMsg->data.txMessage.data[i+6], txMsg->data.txMessage.data[i+7]);
  }
#endif

#if CAN_BOA_DEBUG
  // ---------------------------------------------------------------
  void DisplayTransmitDebug(Can_BOA_Controller* ctrl, Can_BOA_TxObject* txObj, OCI_CANMessage *txMsg)  {
    mcal_printf("BOA", "%s: Transmit: index= handle=%u ID=%08x length=%u\n",
      ctrl->m_CtrlName,
      /*i,*/ txObj->m_Handle,
      txMsg->data.txMessage.frameID, txMsg->data.txMessage.dlc);
      int i = 0;
      mcal_printf("BOA", "data=%02x %02x %02x %02x %02x %02x %02x %02x\n",
      txMsg->data.txMessage.data[i], txMsg->data.txMessage.data[i+1],
      txMsg->data.txMessage.data[i+2], txMsg->data.txMessage.data[i+3],
      txMsg->data.txMessage.data[i+4], txMsg->data.txMessage.data[i+5],
      txMsg->data.txMessage.data[i+6], txMsg->data.txMessage.data[i+7]);
  }
#endif

  // ---------------------------------------------------------------
  OCI_ErrorCode writeCANDataEx(Can_BOA_Controller* ctrl, Can_BOA_TxObject* txObj){
    OCI_CANMessageEx txMsg[1];
    OCI_CANMessageEx* ptrTxMsg[1];
    ptrTxMsg[0] = &txMsg[0];
    memset(&txMsg[0], 0, sizeof (txMsg[0]));

    if (ControllerHasCanFdSupportEnabled(ctrl) && CAN_ID_FD_BIT_SET(txObj->m_Frame.id))
    {
      txMsg[0].type = OCI_CANFDTX_MESSAGE; // The Message type is a CAN FD Tx Message.
      txMsg[0].reserved = 0; // Reserved field. (should always be zero).
      txMsg[0].data.canFDTxMessage.flags = OCI_CAN_MSG_FLAG_FD_DATA; // Flags of the Tx Message.  Refer to the struct OCI_CANTxMessage for more information.
      if (ctrl->m_FdTxBitRateSwitch) {
        txMsg[0].data.canFDTxMessage.flags |= OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE;  // if bit rate switching is enabled set the flag
      }
      txMsg[0].data.canFDTxMessage.res = 0; // Reserved field. (should always be zero
      txMsg[0].data.canFDTxMessage.size = txObj->m_Frame.length; // The Message Data Length.
      // For AUTOSAR can the MSB of the frame ID is set for extended frames.
      // [$CANHWP 13]
      // txMsg.u.sCanMessage.u.V0.dwMsgId  = (DWORD) (txObj->m_Frame.id & ~CAN_EXTENDED_ID_BIT);
      /* When testing with the 523 controller we found that if the upper bits are not masked
       * when we transmit a frame, that frame is received at the other controller but not self received
       * what appears to happen is the 32bit frame id is loaded into the compare registers
       * when the self received frame is received it is different as the frame only has 29 or 11 bits.
       */
      txMsg[0].data.canFDTxMessage.frameID = (txObj->m_Frame.id & ~(CAN_EXTENDED_ID_BIT | CAN_ID_FD_BIT)); // The CAN Message Frame ID.
      if (CAN_CANONICAL_ID_IS_EXTENDED(txObj->m_Frame.id)) {
        txMsg[0].data.canFDTxMessage.flags |= OCI_CAN_MSG_FLAG_EXTENDED;
      }
      // [$CANHWP 14]
      memcpy(txMsg[0].data.canFDTxMessage.data, txObj->m_Frame.data, txObj->m_Frame.length);
#if CAN_BOA_DEBUG
      DisplayTransmitFDExDebug (ctrl, txObj, txMsg);
#endif
    } else {
      txMsg[0].type = OCI_CAN_TX_MESSAGE; // The Message type is a CAN Tx Message.
      txMsg[0].reserved = 0; // Reserved field. (should always be zero).
      txMsg[0].data.txMessage.flags = 0; // Flags of the Tx Message.  Refer to the struct OCI_CANTxMessage for more information.
      txMsg[0].data.txMessage.res = 0; // Reserved field. (should always be zero
      txMsg[0].data.txMessage.dlc = txObj->m_Frame.length; // The Message Data Length.
      // For AUTOSAR can the MSB of the frame ID is set for extended frames.
      // [$CANHWP 13]
      // txMsg.u.sCanMessage.u.V0.dwMsgId  = (DWORD) (txObj->m_Frame.id & ~CAN_EXTENDED_ID_BIT);
      txMsg[0].data.txMessage.frameID = (txObj->m_Frame.id & ~CAN_EXTENDED_ID_BIT); // The CAN Message Frame ID.
      if (CAN_CANONICAL_ID_IS_EXTENDED(txObj->m_Frame.id)) {
        txMsg[0].data.txMessage.flags |= OCI_CAN_MSG_FLAG_EXTENDED;
      }
      // [$CANHWP 14]
      memcpy(txMsg[0].data.txMessage.data, txObj->m_Frame.data,  txObj->m_Frame.length);
#if CAN_BOA_DEBUG
      DisplayTransmitExDebug (ctrl, txObj, txMsg);
#endif
    }
#ifdef ENABLE_EST_CAN_SUPPORT
    if (ctrl->m_OcdSnfInterface != 0) {
  		ctrl->m_OcdSnfInterface->mPreStepSnf(ctrl->m_OcdSnfInterface->mpData);
    }
#endif    
    OCI_ErrorCode ec =  OCI_WriteCANDataEx(ctrl->m_txQueueHandle, OCI_NO_TIME, ptrTxMsg, 1, NULL);
#ifdef ENABLE_EST_CAN_SUPPORT
    if (ctrl->m_OcdSnfInterface != 0) {
  		ctrl->m_OcdSnfInterface->mPostStepSnf(ctrl->m_OcdSnfInterface->mpData);
    }
#endif    
#if CAN_BOA_DEBUG
    mcal_printf("BOA", "OCI_WriteCANDataEx 0x%x\n",ec);
#endif
    return ec;
  }

  // ---------------------------------------------------------------
  OCI_ErrorCode writeCANData(Can_BOA_Controller* ctrl, Can_BOA_TxObject* txObj){
    OCI_CANMessage txMsg;
    memset(&txMsg, 0, sizeof (txMsg));
    txMsg.type = OCI_CAN_TX_MESSAGE; // The Message type is a CAN Tx Message.
    txMsg.reserved = 0; // Reserved field. (should always be zero).
    txMsg.data.txMessage.flags = 0; // Flags of the Tx Message.  Refer to the struct OCI_CANTxMessage for more information.
    txMsg.data.txMessage.res = 0; // Reserved field. (should always be zero
    txMsg.data.txMessage.dlc = txObj->m_Frame.length; // The Message Data Length.
    // For AUTOSAR can the MSB of the frame ID is set for extended frames.
    // [$CANHWP 13]
    // txMsg.u.sCanMessage.u.V0.dwMsgId  = (DWORD) (txObj->m_Frame.id & ~CAN_EXTENDED_ID_BIT);
    txMsg.data.txMessage.frameID = (txObj->m_Frame.id & ~CAN_EXTENDED_ID_BIT); // The CAN Message Frame ID.
    if (CAN_CANONICAL_ID_IS_EXTENDED(txObj->m_Frame.id)) {
      txMsg.data.txMessage.flags |= OCI_CAN_MSG_FLAG_EXTENDED;
    }
    // [$CANHWP 14]
    memcpy(txMsg.data.txMessage.data, txObj->m_Frame.data,  txObj->m_Frame.length);

#if CAN_BOA_DEBUG
    DisplayTransmitDebug(ctrl, txObj, &txMsg);
#endif
#ifdef ENABLE_EST_CAN_SUPPORT
    if (ctrl->m_OcdSnfInterface != 0) {
  		ctrl->m_OcdSnfInterface->mPreStepSnf(ctrl->m_OcdSnfInterface->mpData);
	}
#endif
    OCI_ErrorCode ec = OCI_WriteCANData(ctrl->m_txQueueHandle, 0, &txMsg, 1, NULL);
#ifdef ENABLE_EST_CAN_SUPPORT
    if (ctrl->m_OcdSnfInterface != 0) {
  		ctrl->m_OcdSnfInterface->mPostStepSnf(ctrl->m_OcdSnfInterface->mpData);
	}
#endif   
    return ec;
  }

  // ---------------------------------------------------------------
  void TransmitFrames(Can_BOA_Controller* ctrl) {
    if (m_FatalError) {
      return;
    }

    // If we did not manage to send all of the frames in the shadow transmit
    // objects the last time we ran then we will try to send those before we
    // copy any more frames from the main transmit objects.
    if (ctrl->m_ShadowTxIndex > ctrl->m_HighestShadowTxIndex) {
      // With the lock held make shadow copies of the transmit objects that are in use
      // and need processing. The externally visible transmit objects are freed.
      VECU_LOCK();

      ctrl->m_ShadowTxIndex = ctrl->m_LowestTxIndex;
      ctrl->m_HighestShadowTxIndex = ctrl->m_HighestTxIndex;

      for (unsigned i = ctrl->m_ShadowTxIndex; i <= ctrl->m_HighestShadowTxIndex; i++) {
        if (ctrl->m_TxObjects[i].m_InUse) {
          memcpy(&ctrl->m_ShadowTxObjects[i], &ctrl->m_TxObjects[i], sizeof (Can_BOA_TxObject));
          // [$CANHWP 23] [$CANHWP 26]
          ctrl->m_TxObjects[i].m_InUse = false;
        } else {
          ctrl->m_ShadowTxObjects[i].m_InUse = false;
        }
      }

      ctrl->m_LowestTxIndex = CAN_BOA_MAX_TX_INDEX;
      ctrl->m_HighestTxIndex = 0U;
      ctrl->m_TxPending = false;
      // Now drop the lock so that we don't hold up anything else while we are
      // processing the shadow objects.
      VECU_UNLOCK();
    }

    while (ctrl->m_ShadowTxIndex <= ctrl->m_HighestShadowTxIndex) {

      Can_BOA_TxObject* txObj = &ctrl->m_ShadowTxObjects[ctrl->m_ShadowTxIndex];
      if (txObj->m_InUse) {
        OCI_ErrorCode ec;

        if (txObj->m_Cancel) {
          // The frame has been cancelled so do not transmit it.
          // [$CANHWP 25]
          // [$CANHWP 27]
          ctrl->UpCall(CAN_HWP_EVENT_TX_CANCELLED, txObj->m_Handle, &txObj->m_Frame);
        } else {
          if (ControllerHasCanFdSupport(ctrl)) {
            ec = writeCANDataEx(ctrl, txObj);
            } else {
            ec = writeCANData(ctrl, txObj);
          }

          if (ec == OCI_ERR_QUEUE_IS_FULL) {
            ctrl->m_TxPending = true;
            break; // Leave the while loop.
          }
            // If we failed for any other reason then drop the frame.
          else if (!OCI_SUCCEEDED(ec)) {
              mcal_error("BOA", "OCI_WriteCANData failed, Error Code: 0x%x\n", ec);
          }
          // [$CANHWP 24]
          ctrl->UpCall(CAN_HWP_EVENT_TX_COMPLETED, txObj->m_Handle, &txObj->m_Frame);
        }
      }
      // We've finished with this shadow transmit object.
      ctrl->m_ShadowTxIndex++;
    }
  }

  // ---------------------------------------------------------------
  void CanBusEvent(Can_BOA_Controller* ctrl, bool* carryOn, OCI_CANRxMessage * rxMessage) {
    // If we detect a bus-off we switch to the stopped state (we do this in sleeping
    // state since we are really simulating sleeping and are active on the bus).
    if (rxMessage->data[0] == OCI_CAN_STATE_BUSOFF) {
      HandleBusOff(ctrl);
    }
    // If we detect a wakeup when we are sleeping then we switch to the stopped state and upcall.
    if (ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
      HandleWakeup(ctrl);
      // Ignore the received frame and all subsequent received frames.
      // [$CANHWP 40]
      *carryOn = false;
    }
  }

#if CAN_BOA_DEBUG
  // ---------------------------------------------------------------
  void DisplayReceiveFdExDebug(Can_BOA_Controller* ctrl, OCI_CANMessageEx *rxMsg)  {
    mcal_printf("BOA", "%s: ReceiveFDEx: ID=%08x length=%u Baudrate: %d dataBitRate: %d flags %d\n",
      ctrl->m_CtrlName,
      rxMsg->data.canFDRxMessage.frameID, rxMsg->data.canFDRxMessage.size,
      ctrl->m_CtrlConfig.baudrate, ctrl->m_CtrlConfig.canFDConfig.dataBitRate,
      rxMsg->data.canFDRxMessage.flags);
    for (int i = 0; i <= rxMsg->data.canFDRxMessage.size; i+=8)
    {
      mcal_printf("BOA", "data=%02x %02x %02x %02x %02x %02x %02x %02x\n",
      rxMsg->data.canFDTxMessage.data[i], rxMsg->data.canFDRxMessage.data[i+1],
      rxMsg->data.canFDTxMessage.data[i+2], rxMsg->data.canFDRxMessage.data[i+3],
      rxMsg->data.canFDTxMessage.data[i+4], rxMsg->data.canFDRxMessage.data[i+5],
      rxMsg->data.canFDTxMessage.data[i+6], rxMsg->data.canFDRxMessage.data[i+7]);
    }
  }
#endif

#if CAN_BOA_DEBUG
  // ---------------------------------------------------------------
  void DisplayReceiveExDebug(Can_BOA_Controller* ctrl, OCI_CANMessageEx *rxMsg)  {
    mcal_printf("BOA", "%s: ReceiveEx: ID=%08x length=%u\n",
      ctrl->m_CtrlName,
      rxMsg->data.rxMessage.frameID, rxMsg->data.rxMessage.dlc);
      int i = 0;
      mcal_printf("BOA", "data=%02x %02x %02x %02x %02x %02x %02x %02x\n",
      rxMsg->data.rxMessage.data[i], rxMsg->data.rxMessage.data[i+1],
      rxMsg->data.rxMessage.data[i+2], rxMsg->data.rxMessage.data[i+3],
      rxMsg->data.rxMessage.data[i+4], rxMsg->data.rxMessage.data[i+5],
      rxMsg->data.rxMessage.data[i+6], rxMsg->data.rxMessage.data[i+7]);
  }
#endif

#if CAN_BOA_DEBUG
  // ---------------------------------------------------------------
  void DisplayReceiveDebug(Can_BOA_Controller* ctrl, OCI_CANMessage *rxMsg)  {
    mcal_printf("BOA", "%s: Receive: ID=%08x length=%u\n",
      ctrl->m_CtrlName,
      rxMsg->data.rxMessage.frameID, rxMsg->data.rxMessage.dlc);
    int i = 0;
    mcal_printf("BOA", "data=%02x %02x %02x %02x %02x %02x %02x %02x\n",
    rxMsg->data.rxMessage.data[i], rxMsg->data.rxMessage.data[i+1],
    rxMsg->data.rxMessage.data[i+2], rxMsg->data.rxMessage.data[i+3],
    rxMsg->data.rxMessage.data[i+4], rxMsg->data.rxMessage.data[i+5],
    rxMsg->data.rxMessage.data[i+6], rxMsg->data.rxMessage.data[i+7]);
  }
#endif

  // ---------------------------------------------------------------
  void ReceiveFramesEx(Can_BOA_Controller* ctrl) {
    bool carryOn = true;
    unsigned RxRemaining = CAN_BOA_MAX_RX_PER_ITERATION;

    if (m_FatalError) {
      return;
    }
#if CAN_BOA_DEBUG
    mcal_printf("BOA", "ReceiveFramesEx %s state: 0x%x\n", ctrl->m_CtrlName, ctrl->m_CurrentState);
#endif
    // The OCI controller is only in a state to receive frames when we are in running
    // or sleeping states.
    if (ctrl->m_CurrentState != CAN_HWP_EVENT_RUNNING &&
      ctrl->m_CurrentState != CAN_HWP_EVENT_SLEEPING) {
      return;
    }

    while (ctrl->m_RxQueueHead != ctrl->m_RxQueueTail && carryOn) {
      OCI_CANMessageEx* rxMsg = &ctrl->m_RxQueueEx[ctrl->m_RxQueueTail];
      ctrl->m_RxQueueTail = (ctrl->m_RxQueueTail + 1) % CAN_BOA_RX_QUEUE_SIZE;

      switch (rxMsg->type) {
        case OCI_CAN_BUS_EVENT:   {
          CanBusEvent(ctrl, &carryOn, &rxMsg->data.rxMessage);
          break;
        }
        case OCI_CAN_RX_MESSAGE:  {
#if CAN_BOA_DEBUG
          DisplayReceiveExDebug(ctrl, rxMsg);
#endif
          CanRxMessage(ctrl, &carryOn, &rxMsg->data.rxMessage);
          break;
        }
        case OCI_CAN_TX_MESSAGE:  { break; }
        case OCI_CAN_ERROR_FRAME: { break; }
        case OCI_CAN_INTERNAL_ERROR_EVENT: { break; }
        case OCI_CAN_QUEUE_EVENT: { break; }
        case OCI_CAN_TIMER_EVENT: { break; }
        case OCI_CANFDRX_MESSAGE: {
#if CAN_BOA_DEBUG
          DisplayReceiveFdExDebug(ctrl, rxMsg);
#endif
          CanFdRxMessage(ctrl, &carryOn, &rxMsg->data.canFDRxMessage);
          break;
        }
        case OCI_CANFDTX_MESSAGE: { break; }
        default: { break; }
      }

      RxRemaining--;
      // Avoid getting stuck in this loop when the receive load is heavy.
      if (RxRemaining == 0u) {
        carryOn = false;
        SendEvent(m_ThreadEvent);
      }
    }
  }

  // ---------------------------------------------------------------
  void ReceiveFrames(Can_BOA_Controller* ctrl) {
    bool carryOn = true;
    unsigned RxRemaining = CAN_BOA_MAX_RX_PER_ITERATION;

    if (m_FatalError) {
      return;
    }
#if CAN_BOA_DEBUG
    mcal_printf("BOA", "ReceiveFrames %s state: 0x%x\n", ctrl->m_CtrlName, ctrl->m_CurrentState);
#endif
    // The OCI controller is only in a state to receive frames when we are in running
    // or sleeping states.
    if (ctrl->m_CurrentState != CAN_HWP_EVENT_RUNNING &&
      ctrl->m_CurrentState != CAN_HWP_EVENT_SLEEPING) {
      return;
    }

    while (ctrl->m_RxQueueHead != ctrl->m_RxQueueTail && carryOn) {
      OCI_CANMessage* rxMsg = &ctrl->m_RxQueue[ctrl->m_RxQueueTail];
      ctrl->m_RxQueueTail = (ctrl->m_RxQueueTail + 1) % CAN_BOA_RX_QUEUE_SIZE;

      switch (rxMsg->type) {
          case OCI_CAN_BUS_EVENT: {
            CanBusEvent(ctrl, &carryOn, &rxMsg->data.rxMessage);
            break;
          }
          case OCI_CAN_RX_MESSAGE:  {
#if CAN_BOA_DEBUG
            DisplayReceiveDebug(ctrl, rxMsg);
#endif
            CanRxMessage(ctrl, &carryOn, &rxMsg->data.rxMessage);
            break;
          }
          case OCI_CAN_TX_MESSAGE:  { break; }
          case OCI_CAN_ERROR_FRAME: { break; }
          case OCI_CAN_INTERNAL_ERROR_EVENT: { break; }
          case OCI_CAN_QUEUE_EVENT: { break; }
          case OCI_CAN_TIMER_EVENT: { break; }
          default: { break; }
      }

      RxRemaining--;
      // Avoid getting stuck in this loop when the receive load is heavy.
      if (RxRemaining == 0u) {
        carryOn = false;
        SendEvent(m_ThreadEvent);
      }
    }
  }

  // ---------------------------------------------------------------
#ifndef unix
  bool SetupEvent(HANDLE& event) {
    event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (event == NULL) {
      mcal_error("BOA", "%s: CreateEvent() failed", CAN_BOA_DRIVER_NAME);
      return false;
    }
    return true;
  }
#endif

  // ---------------------------------------------------------------
  void WaitForEvent(HANDLE event) {
#ifdef unix
    pthread_cond_wait(&cond1, &lock);
#else
    // Wait until either someone sets the event.
    WaitForSingleObject(event, INFINITE);
#endif
  }

  // ---------------------------------------------------------------
  void SendEvent(HANDLE event) {
#ifdef unix
    pthread_mutex_lock(&lock);
    pthread_cond_signal(&cond1);
    pthread_mutex_unlock(&lock);
#else
    SetEvent(event);
#endif
  }

  // ---------------------------------------------------------------
  void CanRxMessage(Can_BOA_Controller* ctrl, bool* carryOn, OCI_CANRxMessage * rxMessage) {
    // If we detect a frame when we are sleeping then we switch to the stopped state and upcall.
    if (ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
      HandleWakeup(ctrl);
      // Ignore the received frame and all subsequent received frames.
      // [$CANHWP 40]
      *carryOn = false;
    } else {
      // For AUTOSAR can the MSB of the frame ID is set for extended frames.
      // [$CANHWP 34]
      uint32 frameId = (uint32) rxMessage->frameID;
      bool isExtended = false;

      if ((rxMessage->flags & OCI_CAN_MSG_FLAG_EXTENDED) != 0) {
        isExtended = true;
        frameId |= CAN_EXTENDED_ID_BIT;
      }

      // Look for one or more receive objects that will accept this frame.
      for (unsigned j = 0U; j < ctrl->m_NumRxObjects; j++) {
        Can_BOA_RxObject* rxObj = &ctrl->m_RxObjects[j];

        // The frame type must match the receive object type.
        // [$CANHWP 28] [$CANHWP 29] [$CANHWP 30]
        if ((rxObj->m_IdType == CAN_HWP_IDTYPE_STANDARD && !isExtended) ||
            (rxObj->m_IdType == CAN_HWP_IDTYPE_EXTENDED && isExtended) ||
            (rxObj->m_IdType == CAN_HWP_IDTYPE_MIXED)) {
          // For FULL can we need an exact ID match. For BASIC can we allow a filtered match.
          // [$CANHWP 31] [$CANHWP 32] [$CANHWP 47]
          if ((rxObj->m_RxType == CAN_HWP_RXTYPE_FULL &&
                 frameId == rxObj->m_RxId) ||
              (rxObj->m_RxType == CAN_HWP_RXTYPE_BASIC &&
                 ((frameId & rxObj->m_RxFilterMask) == (rxObj->m_RxId & rxObj->m_RxFilterMask)))) {

            Can_Hwp_Frame frame;
            frame.injected = FALSE;
            frame.txConfirm = FALSE;
            frame.id = frameId;
            frame.length = rxMessage->dlc;
            // [$CANHWP 35]
            memcpy(frame.data, rxMessage->data, frame.length);

            // [$CANHWP 33] [$CANHWP 36]
            ctrl->UpCall(CAN_HWP_EVENT_RX, rxObj->m_Handle, &frame);
            break;  // we only want acknowledge one received frame for one hardware object.
          }
        }
        // Nothing to do to allow the Rx object to receive another frame.
        // [$CANHWP 37]
      }
    }
  }

  // ---------------------------------------------------------------
  void CanFdRxMessage(Can_BOA_Controller* ctrl, bool* carryOn, OCI_CANFDRxMessage * rxMessage) {
    // If we detect a frame when we are sleeping then we switch to the stopped state and upcall.
    if (ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
      HandleWakeup(ctrl);
      // Ignore the received frame and all subsequent received frames.
      // [$CANHWP 40]
      *carryOn = false;
    } else {
      // For AUTOSAR can the MSB of the frame ID is set for extended frames.
      // [$CANHWP 34]
      uint32 frameId = (uint32) rxMessage->frameID;
      bool isExtended = false;

      if ( (  (rxMessage->flags & OCI_CAN_MSG_FLAG_FD_DATA_BIT_RATE) != 0) /* [$CAN 1213] */
           && ( ctrl->m_FdTxBitRateSwitch == FALSE)) {
        mcal_printf("BOA", "%s: Received Message with BitRateSwitch set but controller m_FdTxBitRateSwitch not set.\n", ctrl->m_CtrlName );
        return;
      }
      if ((rxMessage->flags & OCI_CAN_MSG_FLAG_FD_DATA) != 0) {
        frameId |= CAN_ID_FD_BIT;
      }
      if ((rxMessage->flags & OCI_CAN_MSG_FLAG_EXTENDED) != 0) {
        isExtended = true;
        frameId |= CAN_EXTENDED_ID_BIT;
      }
      // Look for one or more receive objects that will accept this frame.
      for (unsigned j = 0U; j < ctrl->m_NumRxObjects; j++) {
        Can_BOA_RxObject* rxObj = &ctrl->m_RxObjects[j];

        // The frame type must match the receive object type.
        // [$CANHWP 28] [$CANHWP 29] [$CANHWP 30]
        if ((rxObj->m_IdType == CAN_HWP_IDTYPE_STANDARD && !isExtended) ||
            (rxObj->m_IdType == CAN_HWP_IDTYPE_EXTENDED && isExtended) ||
            (rxObj->m_IdType == CAN_HWP_IDTYPE_MIXED)) {

          // For FULL can we need an exact ID match. For BASIC can we allow a filtered match.
          // [$CANHWP 31] [$CANHWP 32] [$CANHWP 47]
#if CAN_BOA_DEBUG
          mcal_printf("BOA", "rxObj->m_RxType: 0x%x rxObj->m_RxId: 0x%x frameId: 0x%x rxObj->m_RxFilterMask: 0x%x\n", rxObj->m_RxType, rxObj->m_RxId, frameId, rxObj->m_RxFilterMask);
#endif
          if ((rxObj->m_RxType == CAN_HWP_RXTYPE_FULL &&
                 frameId == rxObj->m_RxId) ||
              (rxObj->m_RxType == CAN_HWP_RXTYPE_BASIC &&
                 ((frameId & rxObj->m_RxFilterMask) == (rxObj->m_RxId & rxObj->m_RxFilterMask)))) {
            Can_Hwp_Frame frame;
            frame.injected = FALSE;
            frame.txConfirm = FALSE;
            frame.id = frameId;
            frame.length = rxMessage->size;
            // [$CANHWP 35]
            memcpy(frame.data, rxMessage->data, frame.length);

            // [$CANHWP 33] [$CANHWP 36]
            ctrl->UpCall(CAN_HWP_EVENT_RX, rxObj->m_Handle, &frame);
            break;  // we only want acknowledge one received frame for one hardware object.
          }
        }
        // Nothing to do to allow the Rx object to receive another frame.
        // [$CANHWP 37]
      }
    }
  }
};

// ---------------------------------------------------------------------------
static Can_BOA_Driver Can_BOA;

// ---------------------------------------------------------------------------
static void Can_BOA_WorkerThread(void) {
  Can_BOA.WorkerThread();
}

// ---------------------------------------------------------------------------
static void Can_BOA_Teardown(void) {
  Can_BOA.Teardown();
}

// ---------------------------------------------------------------------------
static void Can_BOA_FrameCallback(void* userData, OCI_CANMessage* msg) {
  Can_BOA.QueueRxFrame((Can_BOA_Controller*) userData, msg);
}

// ---------------------------------------------------------------------------
static void Can_BOA_FrameCallbackEx(void* userData, OCI_CANMessageEx * msg) {
  Can_BOA.QueueRxFrameEx((Can_BOA_Controller*) userData, msg);
}

/************************************************************************************************************
 *                         Hardware Names
 ***********************************************************************************************************/
static const char* Names[] = {
  "BOACan1",
  "BOACan2",
  "BOACan3",
  "BOACan4",
  "BOACan5",
  "BOACan6",
  "BOACan7",
  "BOACan8",
  "BOACan9",
  "BOACan10",
  "?"
};

/************************************************************************************************************
 *                         Channel Implementation
 ***********************************************************************************************************/
class Can_BOAHw : public Can_Hw {
public:
  // ---------------------------------------------------------------
  Can_BOAHw(Can_Hwp_UpCall upCall, uint32 context, uint32 HwId) : Can_Hw(upCall, context) {
    m_Name = Names[HwId];
    m_HwId = HwId;

    Can_BOA.AddController(HwId, &m_Name, upCall, context);
  }

  // -----------------------------------------------------------------------
  void Configure(const Can_Hwp_ChannelConfig* config) {
    Can_BOA.ConfigureController(m_HwId, config);
  }

  // -----------------------------------------------------------------------
  void SetBaudrate(const Can_Hwp_BaudrateConfig* baudrate) {
    Can_BOA.SetControllerBaudrate(m_HwId, baudrate);
  }

  // -----------------------------------------------------------------------
  void Start(void) {
    Can_BOA.StartController(m_HwId);
  }

  // -----------------------------------------------------------------------
  void Sleep(void) {
    Can_BOA.SleepController(m_HwId);
  }

  // -----------------------------------------------------------------------
  void Stop(void) {
    Can_BOA.StopController(m_HwId);
  }

  // -----------------------------------------------------------------------
  Can_ReturnType Write(Can_HwHandleType handle, Can_Hwp_Frame* frame) {
    return Can_BOA.Write(m_HwId, handle, frame);
  }

  // -----------------------------------------------------------------------
  bool CausedWakeup(void) {
    return Can_BOA.ControllerCausedWakeup(m_HwId);
  }

  // -----------------------------------------------------------------------
  Can_Hwp_Event State(void) {
    return Can_BOA.State(m_HwId);
  }

  // -----------------------------------------------------------------------
  void ForceBusOff(void) {
    Can_BOA.ForceBusOff(m_HwId);
  }

  // -----------------------------------------------------------------------
  void ForceWakeup(void) {
    Can_BOA.ForceWakeup(m_HwId);
  }

  // -----------------------------------------------------------------------
  void EnableTransmitProcessing(bool enable) {
    return Can_BOA.EnableTransmitProcessing(m_HwId, enable);
  }

  // -----------------------------------------------------------------------
  void DeInit(void) {
    Can_BOA.DeInitialise();
  }

};

/************************************************************************************************************
 *                         Provider Implementation
 ***********************************************************************************************************/

static class Can_BOA_HwProvider : public Can_HwProvider {

  // ---------------------------------------------------------------
  bool IsHardwareHere(uint32 HwId) {
    return Can_BOA.IsControllerPresent(HwId);
  }

  // ---------------------------------------------------------------
  bool IsHardwarePresent(uint32 HwId) {
    return Can_BOA.IsControllerPresent(HwId);
  }

  // ---------------------------------------------------------------
  Can_Hw *GetHardware(Can_Hwp_UpCall UpCall, uint32 Context, uint32 HwId) {
    if (!Can_BOA.IsControllerPresent(HwId)) {
      return NULL_CPP_PTR;
    }
    Can_BOAHw *hw = new Can_BOAHw(UpCall, Context, HwId);
    return hw;
  }

} hw_provider;

// Make this provider available
Can_HwProvider* Can_BOA_HwProviderPtr = &hw_provider;



