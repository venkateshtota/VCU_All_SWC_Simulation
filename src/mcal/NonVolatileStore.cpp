/*******************************************************************************
 * Autogenerated by MCALgen for FLS V1.0.54.30643: NonVolatileStore.cpp
 *******************************************************************************/

/************************************************************************************************************
*		NonVolatileStore - used by Fls and Eep
 ***********************************************************************************************************/
#include <sys/types.h>
#include <sys/stat.h>

#ifdef unix
  #include <unistd.h>
  #include <fcntl.h>
  #include <sys/mman.h>
  #include <string.h>
#else
  #include <stdlib.h>
  #include <io.h>
  #include <process.h> /* for getpid() and the exec..() family */
  #define srandom srand
  #define random rand
  #define R_OK    4       /* Test for read permission.  */
  #define W_OK    2       /* Test for write permission.  */
  #define F_OK    0       /* Test for existence.  */

  #define access _access
  #define ftruncate _chsize

  #define ssize_t int

  #define STDIN_FILENO 0
  #define STDOUT_FILENO 1
  #define STDERR_FILENO 2
  #if defined(_MSC_VER) && (_MSC_VER < 1900)
    /* should be in some equivalent to <sys/types.h> */
    typedef __int8            int8_t;
    typedef __int16           int16_t;
    typedef __int32           int32_t;
    typedef __int64           int64_t;
    typedef unsigned __int8   uint8_t;
    typedef unsigned __int16  uint16_t;
    typedef unsigned __int32  uint32_t;
    typedef unsigned __int64  uint64_t;
  #endif

  #include <fcntl.h>
  #include <windows.h>
  #undef CONST
#endif
#include <iostream>
using namespace std;
#include "NonVolatileStore.h"

/******************************************************************************/
NonVolatileStore::NonVolatileStore(const char *name, unsigned size) {
  m_Size = size;
  m_Filename = name;
  m_MappedFile = NULL;
  m_FileHandle = -1;
  m_HMapFile = -1;
  if (m_Size > 0) {
#ifdef unix
    // Open the file for writing.
    //  - Create the file if it doesn't exist.
    m_FileHandle = open(m_Filename, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);

    if (m_FileHandle != -1) {
      /* Truncate the file to have size of exactly 'm_Size' bytes. */
      if (ftruncate(m_FileHandle, m_Size) == 0) {
        m_MappedFile = (uint8*) mmap(0, m_Size, PROT_READ | PROT_WRITE, MAP_SHARED, m_FileHandle, 0);
      }
    }
#else
    // Open the file for writing.
    //  - Create the file if it doesn't exist.
    m_FileHandle = (int)CreateFile(m_Filename, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_FLAG_RANDOM_ACCESS, NULL);

    if ((HANDLE)m_FileHandle != INVALID_HANDLE_VALUE) {
      m_HMapFile = (int)CreateFileMapping((HANDLE)m_FileHandle, NULL, PAGE_READWRITE, 0, m_Size, NULL);
      if ((HANDLE)m_HMapFile != INVALID_HANDLE_VALUE) {
        m_MappedFile = (uint8*)MapViewOfFile((HANDLE)m_HMapFile, FILE_MAP_WRITE, 0, 0, 0);
      }
    }
#endif
  }
}

/******************************************************************************/
NonVolatileStore::~NonVolatileStore(void) {
}

/******************************************************************************/
void NonVolatileStore::MemoryDeAllocation(void) {
#ifdef unix
  if (m_FileHandle >= 0) {
    close(m_FileHandle);
    m_FileHandle = -1;
  }
#else
  if (m_MappedFile != NULL) {
    UnmapViewOfFile(m_MappedFile);
    m_MappedFile = NULL;
  }
  if (m_HMapFile >= 0) {
    CloseHandle((HANDLE)m_HMapFile);
    m_HMapFile = -1;
  }
  if (m_FileHandle >= 0) {
    SYSTEMTIME thesystemtime;
    FILETIME thefiletime;
    GetSystemTime(&thesystemtime);
    SystemTimeToFileTime(&thesystemtime,&thefiletime);
    SetFileTime((HANDLE)m_FileHandle, (LPFILETIME) NULL,&thefiletime, &thefiletime);
    CloseHandle((HANDLE)m_FileHandle);
    m_FileHandle = -1;
  }
#endif
}

/******************************************************************************/
bool NonVolatileStore::Exists(void) {
  return (m_MappedFile != NULL);
}

/******************************************************************************/
void NonVolatileStore::memset(unsigned start, uint8 value, unsigned length) {
  ::memset(&m_MappedFile[start], value, length);
}

/******************************************************************************/
void NonVolatileStore::memcpy(unsigned start, uint8 *src, unsigned length) {
  ::memcpy(&m_MappedFile[start], src, length);
}

/******************************************************************************/
void NonVolatileStore::memcpy(uint8 *dst, unsigned start, unsigned length) {
  ::memcpy(dst, &m_MappedFile[start], length);
}
/******************************************************************************/
uint8 NonVolatileStore::peek(unsigned offset) {
  return m_MappedFile[offset];
}

/******************************************************************************/
void NonVolatileStore::poke(unsigned offset, uint8 value) {
  m_MappedFile[offset] = value;
}

/******************************************************************************/
void NonVolatileStore::Flush(unsigned offset, unsigned length) {
#ifndef unix
  FlushViewOfFile((LPCVOID) &m_MappedFile[offset], length);
#endif
}

