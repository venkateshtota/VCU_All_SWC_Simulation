/*******************************************************************************
 * Autogenerated by MCALgen for FLS V1.0.54.30643: Fls_Device.cpp
 *******************************************************************************/

extern "C" {
#include "Fls.h"
#if (FLS_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"
#endif
#include "Fls_Implementation.h"
#include "Fls_VirtualHw.h"
#include "Fls_Internal.h"
}
#include "Fls_Device.h"
#include "virtualDevice.hpp"

/* This is non AUTOSAR result type. This is returned to external application if E_NOT_OK is returned from AUTOSAR API calls */
#define JOB_UNSUCCESSFUL (MemIf_JobResultType)6

#include <vrtaIdleHandling.hpp>
class FlsIdleHandler: public vrtaIdleSubscriber {
  int Idle(unsigned core);
};

/************************************************************************************************************
 *                         Virtual Device
 ***********************************************************************************************************/
#define FLASH_DEVICE_RESULT     "JOB_OK|JOB_FAILED|JOB_PENDING|JOB_CANCELLED|JOB_INCONSISTENT|JOB_INVALID|JOB_UNSUCCESSFUL"
#define FLASH_DEVICE_STATUS     "Uninitialized|Idle|Busy|BusyInternal"
#define FLASH_DEVICE_CURRENTJOB "NONE|WRITE|READ|ERASE|COMPARE|CANCEL"
#define FLASH_DEVICE_APIS       "None|Fls_Init|Fls_Erase|Fls_Write|Fls_Cancel|Fls_GetStatus|Fls_GetJobResult|Fls_Mainfunction|Fls_Read|Fls_Compare|Fls_SetMode|Fls_BlankCheck|Fls_GetVersionInfo"
#define FLASH_DEVICE_DETS       "NONE|FLS_E_PARAM_CONFIG|FLS_E_PARAM_ADDRESS|FLS_E_PARAM_LENGTH|FLS_E_PARAM_DATA|FLS_E_UNINIT|FLS_E_BUSY|FLS_E_VERIFY_ERASE_FAILED|FLS_E_VERIFY_WRITE_FAILED|FLS_E_TIMEOUT|FLS_E_PARAM_POINTER"
#define FLASH_HARDWARE_STATES   "Normal|Error"
#define TIME_OUT_SWITCH         "Off|On"
#define TIME_OUT_JOBS           "WRITE|READ|ERASE|COMPARE"
#define VERIFY_ERROR_SWITCH     "Off|On"
#define VERIFY_ERROR_JOBS       "ERASE|WRITE"

typedef enum {flsnone, flswrite, flsread, flserase, flscompare, flscancel, flsjobpending} Actions;
typedef enum {WRITE, READ, ERASE, COMPARE} TimeOutJobs;
typedef enum {VERIFY_ERASE, VERIFY_WRITE} VerifyErrorJobs;

class FlsDevice : public VirtualDevice {
  protected:
    vrtaUInt    m_DetInstance;
    vrtaUInt    m_DetApi;
    vrtaUInt    m_DetError;
    vrtaUInt    m_FlsAction;
    vrtaUInt    m_FlsAddress;
    vrtaUInt    m_FlsLength;
    vrtaUInt    m_Result;
    vrtaUInt    m_Status;
    vrtaUInt    m_InjectedResult;
    vrtaUInt    m_InjectedStatus;
    vrtaUInt    m_CurrentJob;
//    vrtaUInt    m_InjectedFlsRead;
    vrtaBoolean m_FlsError;
    uint32      m_DemEvent;
    uint32      m_DemError;
    unsigned char   m_FlsBuffer[0x10000] ; /* Limited by max packet size */

    vrtaBoolean prevent_result_duplicates;
    vrtaBoolean prevent_status_duplicates;

public:
  // -------------------------------------------------------------------------
  FlsDevice(const char *name) {
    m_DetInstance = 0;
    m_DetApi      = 0;
    m_DetError    = 0;
    m_FlsAction   = flsnone;
    m_FlsAddress  = 0;
    m_FlsLength   = 0;
    m_Result      = 0;
    m_Status      = 0;
    m_InjectedResult = 0;
    m_InjectedStatus = 0;
    m_CurrentJob = 0;
//    m_InjectedFlsRead = 0;
    m_FlsError = 0;
    m_DemEvent = 0;
    m_DemError = 0;
    RegisterAs(name);
    m_FlsBuffer[0] = '\0'; // So Sonar thinks it is initialized..

    vrtaIdleSubscriber::Subscribe(new FlsIdleHandler());
  }

  vrtaBoolean m_JobPending;



protected:
// -------------------------------------------------------------------------

  void GetDeviceInfo(OptList &info) {
    info.Add("Type",        "Fls");
    info.Add("Description", "Implementation of AUTOSAR Flash Virtual Device");
    info.Add("Version",     "1.0.54"); /* [$Fls 1006] */
  }

  void ExecuteJob(void) {
    m_JobPending = TRUE;
    m_FlsAction = flsjobpending;
    Fls_MainFunction_helper(TRUE);
    if (Fls_InternalJobResult() != MEMIF_JOB_PENDING) {
      RaiseInjectedEvents();
    }
  }

/*
 * When an injected action is processed from the OS thread the below function is called to update the Result and status of that action.
 * This function also reset the flags to allow actions to be processed from external application
 */
  void RaiseInjectedEvents() {
//    if (m_InjectedFlsRead && Fls_InternalJobResult() == MEMIF_JOB_OK) { /* [$Fls 1088] */
    if (Fls_InternalJobResult() == MEMIF_JOB_OK) { /* [$Fls 1088] */
      //m_InjectedFlsRead = false;
      Raise(EVENT_HANDLER(FlsDevice::InjectedReadEvent));
    }
    if (m_FlsError) {
      m_InjectedResult = JOB_UNSUCCESSFUL;
    } else {
      m_InjectedResult = Fls_InternalJobResult();
    }
    m_InjectedStatus = Fls_InternalMemStatus();
    m_FlsError  = false;
    m_JobPending = false;
    m_FlsAction = flsnone;
    Raise(EVENT_HANDLER(FlsDevice::InjectedResultEvent));
    Raise(EVENT_HANDLER(FlsDevice::InjectedStatusEvent));
  }

  // -----------------------------------------
  void Starting(void) {
  }

  // -----------------------------------------
  void Stopping(void) {
    Fls_DeAllocateMemory(); /* [$Fls 1254] */
  }
  
  // -------------------------------------------------------------------------
  // Called during RegisterAs() to build the action handlers and descriptions
  void GetDeviceActions(ActionList &actions) {

    ADD_ACTION_HANDLER(FlsDevice::WriteAction);
    actions.Add("InjectWrite", "Writes to Flash device", "Raises InjectedStatus and InjectedResult events"). /* [$Fls 1014] */
      In("StartAddress", "Start address for the write", "%x").
      In("Data",  "Data to be written", "%a");

    ADD_ACTION_HANDLER(FlsDevice::ReadAction);
    actions.Add("InjectRead", "Reads from a Flash device", "Raises InjectedStatus, InjectedResult and InjectedRead events"). /* [$Fls 1015] */
      In("StartAddress", "Start address for the read","%x").
      In("Length", "Number of bytes to read", "%u");

    ADD_ACTION_HANDLER(FlsDevice::EraseAction);
    actions.Add("InjectErase", "Erases Flash device", "Raises Injected Status and Injected result events"). /* [$Fls 1016] */
      In("StartAddress","Start address for the erase", "%x").
      In("Length", "Number of bytes to erase", "%u");

#if ( FLS_COMPARE_API == STD_ON )
    ADD_ACTION_HANDLER(FlsDevice::CompareAction);
    actions.Add("InjectCompare", "Compares data in Flash device", "Raises Injected Status and Injected result events"). /* [$Fls 1017] */
      In("StartAddress","Start address for the compare","%x").
      In("Length", "Number of bytes to be compared", "%u").
      In("Data",  "Data to be compared", "%a");
#endif

#if ( FLS_CANCEL_API == STD_ON )
    ADD_ACTION_HANDLER(FlsDevice::CancelAction);
      actions.Add("InjectCancel", "Cancels a job", "Raises Injected Status and Injected result events"); /* [$Fls 1018] */
#endif

    ADD_ACTION_HANDLER(FlsDevice::InjectHardwareState);
    actions.Add("InjectHardwareState", "Switches the Flash hardware State", "Does not raise any event").
      In("HardwareState","Sets Flash Hardware to Error or Normal state",FLASH_HARDWARE_STATES);

    ADD_ACTION_HANDLER(FlsDevice::InjectTimeout);
    actions.Add("InjectTimeoutError", "Switches the Timeout Error for a job", "Does not raise any event").
      In("Job","Job for which the Timeout Error needs to be set",TIME_OUT_JOBS).
      In("Timeout","Switches Timeout Error",TIME_OUT_SWITCH);

     ADD_ACTION_HANDLER(FlsDevice::InjectVerifyError);
     actions.Add("InjectVerifyError", "Switches the Verification Error for a job", "Does not raise any event").
      In("Job","Job for which the Verification Error needs to be set",VERIFY_ERROR_JOBS).
      In("VerifyError","Switches Verification Error",VERIFY_ERROR_SWITCH);
  }

  vrtaErrType WriteAction(const vrtaAction &action) {
      m_FlsAddress = UnsignedValueFor(action);
      m_FlsLength = action.devActionLen - (sizeof(vrtaUInt));
      memcpy(m_FlsBuffer,((uint8 *)(action.devActionData) + (sizeof(vrtaUInt))), m_FlsLength);
      m_FlsAction = flswrite; // Set this last
      return RTVECUErr_NONE;
  }

  struct AddrAndLength { vrtaUInt address; vrtaUInt length; };

  vrtaErrType ReadAction(const vrtaAction &action) {
      struct AddrAndLength params;
      UnpackData(action, params);
      m_FlsAddress = params.address;
      m_FlsLength  = params.length;
      m_FlsAction = flsread; // Set this last
      return RTVECUErr_NONE;
  }

  vrtaErrType EraseAction(const vrtaAction &action) {
      struct AddrAndLength params;
      UnpackData(action, params);
      m_FlsAddress = params.address;
      m_FlsLength  = params.length;
      m_FlsAction  = flserase; // Set this last
      return RTVECUErr_NONE;
  }

  vrtaErrType CompareAction(const vrtaAction &action) {
      struct AddrAndLength params;
      UnpackData(action, params);
      m_FlsAddress = params.address;
      m_FlsLength  = params.length;
      memcpy(m_FlsBuffer,((uint8 *)(action.devActionData) + 2 *(sizeof(vrtaUInt))), m_FlsLength);
      m_FlsAction = flscompare; // Set this last
      return RTVECUErr_NONE;
  }

  vrtaErrType CancelAction(const vrtaAction &action) {
      m_FlsAction = flscancel;
      return RTVECUErr_NONE;
  }

  /* [$Fls 1114] */
  vrtaErrType InjectHardwareState(const vrtaAction &action) {
      Fls_InjectHardwareError(UnsignedValueFor(action));
      return RTVECUErr_NONE;
  }

   /* [$Fls 1115] */
  struct Timeout { vrtaUInt job; vrtaUInt state; };
  vrtaErrType InjectTimeout(const vrtaAction &action) {
      struct Timeout params;
      UnpackData(action, params);
      switch (params.job) {
        case WRITE:
          Fls_InjectWriteTimeoutError(params.state);
          break;
        case READ:
          Fls_InjectReadTimeoutError(params.state);
          break;
        case ERASE:
          Fls_InjectEraseTimeoutError(params.state);
          break;
        case COMPARE:
          Fls_InjectCompareTimeoutError(params.state);
          break;
        default:
          break;
      }
      return RTVECUErr_NONE;
  }
  /* [$Fls 1116] */
  struct VerifyState { vrtaUInt job; vrtaUInt state; };
  vrtaErrType InjectVerifyError(const vrtaAction &action) {
      struct Timeout params;
      UnpackData(action, params);
      switch (params.job) {
        case VERIFY_ERASE:
          Fls_InjectEraseVerifyError(params.state);
          break;
        case VERIFY_WRITE:
          Fls_InjectWriteVerifyError(params.state);
          break;
        default:
          break;
      }
      return RTVECUErr_NONE;
  }

  // -------------------------------------------------------------------------
  // Called during RegisterAs() to build the event handlers and descriptions
  void GetDeviceEvents(EventList &events) {

    ADD_EVENT_HANDLER(FlsDevice::ResultEvent);  /* [$Fls 1007] */
    events.Add("Result", "This event gets raised when the job result gets updated", "Poll,Raise").
      Out("JobResult", "Result of a Job", FLASH_DEVICE_RESULT);

    ADD_EVENT_HANDLER(FlsDevice::StatusEvent); /* [$Fls 1008] */
    events.Add("Status", "This event gets raised when status gets updated", "Poll,Raise").
      Out("JobStatus", "Status of a Job", FLASH_DEVICE_STATUS);

    ADD_EVENT_HANDLER(FlsDevice::CurrentJobEvent); /* [$Fls 1010] */
    events.Add("CurrentJob", "This event gets raised when a job starts", "Poll,Raise").
      Out("CurrentJob", "Current job", FLASH_DEVICE_CURRENTJOB);

    ADD_EVENT_HANDLER(FlsDevice::InjectedResultEvent); /* [$Fls 1012] */
    events.Add("InjectedResult", "This event is raised when an injected action completes", "Poll,Raise").
      Out("InjectedResult", "Result of an Injected job", FLASH_DEVICE_RESULT);

    ADD_EVENT_HANDLER(FlsDevice::InjectedStatusEvent); /* [$Fls 1013] */
    events.Add("InjectedStatus", "This event is raised when the status corresponding to an injected action changes", "Poll,Raise").
      Out("InjectedStatus", "Status of a Injected job", FLASH_DEVICE_STATUS);

    ADD_EVENT_HANDLER(FlsDevice::InjectedReadEvent); /* [$Fls 1011] */
    events.Add("InjectedRead", "This event is raised when an Injected Read completes" , "Poll,Raise").
      Out("InjectedRead", "The data read", "%a");

    ADD_EVENT_HANDLER(FlsDevice::HardwareStateEvent);
    events.Add("HardwareState", "Gets the State of the Hardware" , "Poll").
      Out("HardwareState", "Flash Hardware State", FLASH_HARDWARE_STATES);

    ADD_EVENT_HANDLER(FlsDevice::TimeOutEvent);
    events.Add("TimeoutError", "Gets the Timeout Error Config for a job" , "Poll").
      In("Jobs", "Job for which the Timeout state needs to be checked", TIME_OUT_JOBS).
      Out("TimeoutState", "Gets the Injected Time out Error state", TIME_OUT_SWITCH);

    ADD_EVENT_HANDLER(FlsDevice::VerifyErrorEvent);
    events.Add("VerifyError", "Gets the Verification Error for a job" , "Poll").
      In("Jobs", "Job for which the Verification Error needs to be checked", VERIFY_ERROR_JOBS).
      Out("VerifyError", "Gets the Injected Verification Error State", VERIFY_ERROR_SWITCH);

    ADD_EVENT_HANDLER(FlsDevice::DEMEvent);
    events.Add("DEM", "DEM error raised in Fls", "Poll,Raise").
      Out("Event",  "The event ID",      "NONE|FLS_E_ERASE_FAILED|FLS_E_WRITE_FAILED|FLS_E_READ_FAILED|FLS_E_COMPARE_FAILED").
      Out("Status", "The error status", "NONE|PASSED|FAILED|PREPASSED|PREFAILED");

#if (FLS_DEV_ERROR_DETECT == STD_ON) /* [$Fls 1009] */
    ADD_EVENT_HANDLER(FlsDevice::DETEvent);
    events.Add("DET", "DET error raised in Fls", "Poll,Raise").
      Out("Instance", "The Fls instance",          "%u").
      Out("API",      "The API causing the error", FLASH_DEVICE_APIS).
      Out("Error",    "The most recent error",     FLASH_DEVICE_DETS);
#endif

  }

  vrtaErrType DETEvent(vrtaEvent &event) {
    SetValue(event, m_DetInstance, m_DetApi, m_DetError);
    return RTVECUErr_NONE;
  }

  /* [$Fls 1049] [$Fls 1050] [$Fls 1051] [$Fls 1052] [$Fls 1053] [$Fls 1054] [$Fls 1056] */
  vrtaErrType ResultEvent(vrtaEvent &event) {
    SetValue(event, m_Result);
    return RTVECUErr_NONE;
  }

  /* [$Fls 1057] [$Fls 1059] [$Fls 1060] [$Fls 1061] */
  vrtaErrType StatusEvent(vrtaEvent &event) {
    SetValue(event, m_Status);
    return RTVECUErr_NONE;
  }

  /* [$Fls 1104] [$Fls 1063] [$Fls 1064] [$Fls 1065] [$Fls 1066] [$Fls 1067] */
  vrtaErrType CurrentJobEvent(vrtaEvent &event) {
    SetValue(event, m_CurrentJob);
    return RTVECUErr_NONE;
  }

  /* [$Fls 1070] [$Fls 1072] [$Fls 1073] [$Fls 1075] [$Fls 1076] [$Fls 1078] */
  vrtaErrType InjectedResultEvent(vrtaEvent &event) {
    SetValue(event, m_InjectedResult);
    return RTVECUErr_NONE;
  }

  /* [$Fls 1079] [$Fls 1080] [$Fls 1081] [$Fls 1082] */
  vrtaErrType InjectedStatusEvent(vrtaEvent &event) {
    SetValue(event, m_InjectedStatus);
    return RTVECUErr_NONE;
  }

   /* [$Fls 1068] [$Fls 1069] */
  vrtaErrType InjectedReadEvent(vrtaEvent &event) {
    PackData(event, m_FlsBuffer, m_FlsLength);
    return RTVECUErr_NONE;
  }

 /* [$Fls 1117] [$Fls 1118] */
  vrtaErrType DEMEvent(vrtaEvent &event) {
    SetValue(event, m_DemEvent, m_DemError);
    return RTVECUErr_NONE;
  }

  /* [$Fls 1111] */
  vrtaErrType HardwareStateEvent(vrtaEvent &event) {
    SetValue(event, Fls_InternalHardwareErrorState());
    return RTVECUErr_NONE;
  }

   /* [$Fls 1112] */
  vrtaErrType TimeOutEvent(vrtaEvent &event) {
    vrtaUInt job = UnsignedValueFor(event);
    switch (job) {
     case WRITE:
          SetValue(event, Fls_InternalWriteTimeoutErrorState());
          break;
        case READ:
          SetValue(event, Fls_InternalReadTimeoutErrorState());
          break;
        case ERASE:
          SetValue(event, Fls_InternalEraseTimeoutErrorState());
          break;
        case COMPARE:
          SetValue(event, Fls_InternalCompareTimeoutErrorState());
          break;
        default:
          return RTVECUErr_VAL;
          break;
    }
    return RTVECUErr_NONE;
  }

  /* [$Fls 1113] */
  vrtaErrType VerifyErrorEvent(vrtaEvent &event) {
    vrtaUInt job = UnsignedValueFor(event);
    switch (job) {
        case VERIFY_ERASE:
          SetValue(event, Fls_InternalEraseVerifyErrorState());
          break;
        case VERIFY_WRITE:
          SetValue(event, Fls_InternalWriteVerifyErrorState());
          break;
        default:
          return RTVECUErr_VAL;
          break;
    }
    return RTVECUErr_NONE;
  }

public:

    void FlashIdleHandler(void) {

      switch(m_FlsAction) {

        case flswrite:
          if (E_OK == Fls_Write_helper(m_FlsAddress, m_FlsBuffer, m_FlsLength, TRUE)) {
            ExecuteJob();
          } else {
            m_FlsError = TRUE;
            RaiseInjectedEvents();
          }
        break;

        case flsread:
          if (E_OK == Fls_Read_helper(m_FlsAddress, m_FlsBuffer, m_FlsLength, TRUE)) {
            ExecuteJob();
          } else {
            m_FlsError = TRUE;
            RaiseInjectedEvents();
          }
        break;

        case flserase:
          if (E_OK == Fls_Erase_helper(m_FlsAddress, m_FlsLength, TRUE)) {
            ExecuteJob();
          } else {
            m_FlsError = TRUE;
            RaiseInjectedEvents();
          }
        break;

        case flscompare:
#if ( FLS_COMPARE_API == STD_ON )
          if (E_OK == Fls_Compare_helper(m_FlsAddress, m_FlsBuffer, m_FlsLength, TRUE)) {
            ExecuteJob();
          } else {
            m_FlsError = TRUE;
            RaiseInjectedEvents();
          }
#endif
        break;

        case flscancel:
#if ( FLS_CANCEL_API == STD_ON )
          Fls_Cancel_helper(TRUE);
          if (m_JobPending && Fls_InternalJobResult() != MEMIF_JOB_CANCELED) {
            m_FlsAction = flsjobpending;
            Raise(EVENT_HANDLER(FlsDevice::InjectedResultEvent));
            Raise(EVENT_HANDLER(FlsDevice::InjectedStatusEvent));
          } else {
            RaiseInjectedEvents();
          }
#endif
        break;

        case flsjobpending:
          ExecuteJob();
          break;

        default:
          break;
     }
   }

  /*
   * The code below is called when an injected action is in progress and if an
   * higher priority task tries to access the Flash MCAL module.
   * It will finish the injected action first and then start its own job.
   * The user won't be informed.
   */
  void FinishInjectedJob() {
    do {
      if (m_FlsAction == flscancel) {
#if ( FLS_CANCEL_API == STD_ON )
        Fls_Cancel_helper(TRUE);
        RaiseInjectedEvents();
#endif
        m_FlsAction = flsjobpending;
      }
      Fls_MainFunction_helper(TRUE);
    } while ((Fls_InternalJobResult() == MEMIF_JOB_PENDING) && (Fls_InternalJobResult() != MEMIF_JOB_CANCELED));
    RaiseInjectedEvents();
  }

  /*
   * Raises Result Event to inform  external application if a job result is updated in the MCAL flash module
   */
  void UpdateJobResult(MemIf_JobResultType result) {
    if ((m_Result != (vrtaUInt)result) || prevent_result_duplicates == FALSE) {
      prevent_result_duplicates = TRUE;
      m_Result = (vrtaUInt)result;
      Raise(EVENT_HANDLER(FlsDevice::ResultEvent));
    }
  }

  /*
   * Raises Status Event to inform  external application if Flash status is updated in the MCAL flash module
   */
  void UpdateJobStatus(MemIf_StatusType status) {
    if ((m_Status != (vrtaUInt)status) || prevent_status_duplicates == FALSE) {
      prevent_status_duplicates = TRUE;
      m_Status = (vrtaUInt)status;
      Raise(EVENT_HANDLER(FlsDevice::StatusEvent));
    }
  }

  /*
   * Raises DET Errors to inform  external application if an error is occurred in the MCAL flash module
   */

  /* [$Fls 1105] [$Fls 1106] [$Fls 1107] [$Fls 1108] */
  void UpdateDetErrors(uint32 instance, uint32 api, uint32 err) {
    m_DetInstance = instance;
    m_DetError = err;
    if (api > 10) {
      m_DetApi = api - 4; // VersionInfo
    }
    else {
      m_DetApi = api + 1;
    }
    Raise(EVENT_HANDLER(FlsDevice::DETEvent));
  }

  /*
   * Raises Current Job event to inform external application if a job is processed in the MCAL flash module
   */
  void UpdateCurrentJob(uint8 job) {
    m_CurrentJob = job;
    prevent_result_duplicates = FALSE;
    prevent_status_duplicates = FALSE;
    Raise(EVENT_HANDLER(FlsDevice::CurrentJobEvent));
  }

  /* [$Fls 1026] */
  void DemError(uint32 EventId, uint32 EventStatus) {
    m_DemEvent = 0;
#ifdef FLS_E_COMPARE_FAILED
    if (EventId == FLS_E_COMPARE_FAILED) m_DemEvent = 4;
#endif    
#ifdef FLS_E_READ_FAILED
    if (EventId == FLS_E_READ_FAILED) m_DemEvent = 3;
#endif    
#ifdef FLS_E_WRITE_FAILED
    if (EventId == FLS_E_WRITE_FAILED) m_DemEvent = 2;
#endif    
#ifdef FLS_E_ERASE_FAILED
    if (EventId == FLS_E_ERASE_FAILED) m_DemEvent = 1;
#endif    
    m_DemError = EventStatus == DEM_EVENT_STATUS_PASSED ? 1 :
      EventStatus == DEM_EVENT_STATUS_FAILED ? 2 :
      EventStatus == DEM_EVENT_STATUS_PREPASSED ? 3 :
      EventStatus == DEM_EVENT_STATUS_PREFAILED ? 4 : 0;
    Raise(EVENT_HANDLER(FlsDevice::DEMEvent));
  }

};

FlsDevice Fls("Fls");/* [$Fls 1005] */ /* [$Fls 1002] */


/* Called from an OS thread to process injected actions*/
int FlsIdleHandler::Idle(unsigned core) {
  if (core == 0) {
    Fls.FlashIdleHandler();
  }
  return 0;
}

/* Called from Flash MCAL to raise DET error event */
/* [$Fls 1105] [$Fls 1106] [$Fls 1107] [$Fls 1108] */
void Fls_Device_UpdateDet(uint32 instance, uint32 api, uint32 err) {
#if (FLS_DEV_ERROR_DETECT == STD_ON) /* [$Fls 1009] */
 Fls.UpdateDetErrors(instance,api,err);
#endif
}

/*
 * Called from Flash MCAL to raise Current job event. If an existing Injected action is on progress
 * then the injected job will be completed first before stating its job
 */
void Fls_Device_StartJob(uint8 api) {
  if (Fls.m_JobPending) {
    Fls.FinishInjectedJob();
  }

  /* These values must match the virtual device FLASH_DEVICE_CURRENTJOB	*/
  switch (api) {
    case FLS_WRITE_API_ID:
      Fls.UpdateCurrentJob(1);
      break;
    case FLS_READ_API_ID:
      Fls.UpdateCurrentJob(2);
      break;
    case FLS_ERASE_API_ID:
      Fls.UpdateCurrentJob(3);
      break;
    case FLS_COMPARE_API_ID:
      Fls.UpdateCurrentJob(4);
      break;
    case FLS_CANCEL_API_ID:
      Fls.UpdateCurrentJob(5);
      break;
  }
}

void Fls_Device_UpdateJob(void) {
  Fls.UpdateJobStatus(Fls_InternalMemStatus());
  Fls.UpdateJobResult(Fls_InternalJobResult());
}

/* [$Fls 1026] */
void Fls_Device_UpdateDem(Dem_EventIdType EventId, Dem_EventStatusType EventStatus) { /* [$Fls 260] */
  Fls.DemError(EventId, EventStatus);
  return Dem_ReportErrorStatus(EventId, EventStatus);
}

