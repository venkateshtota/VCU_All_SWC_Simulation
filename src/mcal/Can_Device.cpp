/*******************************************************************************
 * Autogenerated by MCALgen for CAN V1.0.54.30643: Can_Device.cpp
 *******************************************************************************/

extern "C" {
  #include "Can.h"
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"
#endif
  #include "Os.h"
  #include "Can_Implementation.h"
}
#include "virtualDevice.hpp"
#include "Can_Device.hpp"


#define CAN_APIS     "None|Can_Init|Can_MainfunctionWrite|Can_InitController|Can_SetMode|"\
                     "Can_DisableInterrupts|Can_EnableInterrupts|Can_Write|Can_GetVersionInfo|"\
                     "Can_MainfunctionRead|Can_MainfunctionBusoff|Can_MainfunctionWakeup|Can_CheckWakeup|"\
                     "Can_MainfunctionMode|Can_ChangeBaudrate|Can_CheckBaudrate|Can_DeInit|Can_GetControllerMode|Can_GetControllerErrorState"
#define CAN_DETS     "None|CAN_E_PARAM_POINTER|CAN_E_PARAM_HANDLE|CAN_E_PARAM_DLC|CAN_E_PARAM_CONTROLLER|"\
                     "CAN_E_UNINIT|CAN_E_TRANSITION|CAN_E_DATALOST|CAN_E_PARAM_BAUDRATE"
//------------------------------------------------------------------------------
class CanControllerDevice :  public VirtualDevice { /* [$CAN 1111]  */
  protected:
    vrtaDevID    _parent;
    uint8        _id;
    uint8        _index;

    struct StatusEventType {vrtaUInt state; char name[1024];};
    struct WriteEventType { vrtaUInt _source; vrtaUInt _result;  vrtaUInt _hth; vrtaUInt _txpduid; vrtaUInt _id; vrtaUInt _length; uint8 _data[CAN_MAX_DATA_LENGTH];};
    struct TxEventType {vrtaUInt _source;  vrtaUInt _hth; vrtaUInt _txpduid; vrtaUInt _id; vrtaUInt _length; uint8 _data[CAN_MAX_DATA_LENGTH];};
    struct RxEventType {vrtaUInt _source; vrtaUInt _hrh; vrtaUInt _id; vrtaUInt _length; uint8 _data[CAN_MAX_DATA_LENGTH];};

    WriteEventType _write;
    TxEventType    _tx;
    RxEventType    _rx;
    StatusEventType _status;
    vrtaUInt _errorState;

  public:
    CanControllerDevice(const char *name, uint8 id, uint8 index, vrtaDevID parent) {
      _parent = parent;
      _id = id;
      _index = index;
      _write._source  = 0;
      _write._result  = 0;
      _write._txpduid = 0;
      _write._hth     = 0;
      _write._id      = 0;
      _write._length  = 0;
      memset(_write._data, 0, CAN_MAX_DATA_LENGTH);
      _rx._source     = 0;
      _rx._hrh        = 0;
      _rx._id         = 0;
      _rx._length     = 0;
      memset(_rx._data, 0, CAN_MAX_DATA_LENGTH);
      _tx._source     = 0;
      _tx._txpduid    = 0;
      _tx._hth        = 0;
      _tx._id         = 0;
      _tx._length     = 0;
      memset(_tx._data, 0, CAN_MAX_DATA_LENGTH);
      _status.state   = 0;
      memcpy(&_status.name[0], "?", 2);
      _errorState     = 0;
      RegisterAs(name);
    }

    //------------------------------------------------------------------------------
    void RaiseStateEvent(int index, Can_EventState state, const char* hardwarename) {
      _status.state = state;
      if (hardwarename == NULL_PTR || (strlen(hardwarename)+1 > sizeof(_status.name))){
        strcpy(_status.name, "?");
      }else{
        strcpy(_status.name, hardwarename);
      }
      Raise(EVENT_HANDLER(CanControllerDevice::StateEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseErrorStateEvent(vrtaUInt errorState) {
      _errorState = errorState;
      Raise(EVENT_HANDLER(CanControllerDevice::ErrorStateEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseWriteEvent(int index,  boolean source, uint8 result, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
       switch(source) { /* [$CAN 1035] */
         case false: _write._source = 1; break; // fromApi
         case true: _write._source = 2; break; // fromAction
         default: _write._source = 0; break; // None
       }
       switch(result) { /* [$CAN 1026] */
         case CAN_OK: _write._result = 1; break;
         case CAN_NOT_OK: _write._result = 2; break;
         case CAN_BUSY: _write._result = 3; break;
         case CAN_FRAME_DROPPED: _write._result = 4; break;
         default: _write._result = 0; break;
       }
       _write._hth     = handle;
       _write._txpduid = frame->swPduHandle;
       _write._id      = frame->id;
       _write._length  = frame->length;
       memcpy(_write._data, frame->data, _write._length);
       Raise(EVENT_HANDLER(CanControllerDevice::WriteEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseRxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
       _rx._source  = (uint32)(frame->injected)+1; /* [$CAN 1038] */
       _rx._hrh     = handle;
       _rx._id      = frame->id;
       _rx._length  = frame->length;
       memcpy(_rx._data, frame->data, _rx._length);
       Raise(EVENT_HANDLER(CanControllerDevice::RxEvent));
    }

    //------------------------------------------------------------------------------
    void RaiseTxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
       _tx._source  = (uint32)(frame->injected)+1; /* [$CAN 1112] */
       _tx._txpduid = frame->swPduHandle;
       _tx._hth     = handle;
       _tx._id      = frame->id;
       _tx._length  = frame->length;
       memcpy(_tx._data, frame->data, _tx._length);
       Raise(EVENT_HANDLER(CanControllerDevice::TxEvent));
    }

  protected:
    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the basic information about the device
    void GetDeviceInfo(OptList &info) {
      info.Add("Type", "CanController");
      info.Add("Description", "Implementation of AUTOSAR Can Controller");
      info.Add("Version", "1.0.54");
    }

    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the action handlers and descriptions
    void GetDeviceActions(ActionList &actions) {
      /* [$CAN 1041] */
      ADD_ACTION_HANDLER(CanControllerDevice::DropWriteAction);
      actions.Add("DropWrites", "Drop frames before transmission", "").
      In("Dropwrites","Drop Writes with Can_Write API when true","false|true");

      /* [$CAN 1042] */
      ADD_ACTION_HANDLER(CanControllerDevice::DropReceiveAction);
      actions.Add("DropReceives", "Drop received frames on a controller", "").
      In("Dropreceives","Drop receives on the controller when true","false|true");

       /* [$CAN 1114] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectWriteAction);
      actions.Add("InjectWrite", "Injects a CAN frame to be transmitted on a controller", "").
      In("TxConfirmation","Option to enable or disable txconfirmation","false|true").
      In("Hth","Transmit object handle","%u").
      In("CanTxPduId","Pdu Handle Id","%u").
      In("Id","Frame Id","%u").
      In("Length","Number of bytes of data","%u").
          In("Data","Data bytes","%a:64");
    
      /* [$CAN 1115] */
      ADD_ACTION_HANDLER(CanControllerDevice::InjectRxAction);
      actions.Add("InjectRx", "Simulate reception of a specified frame", "").
      In("Hrh","Received object handle","%u").
      In("Id","Frame Id","%u").
      In("Length","Number of bytes of data","%u").
          In("Data","Data bytes","%a:64");
          /* [$CAN 1116] */
      ADD_ACTION_HANDLER(CanControllerDevice::ForceBusOffAction);
      actions.Add("ForceBusOff", "Force the controller to go bus-off", "");

      /* [$CAN 1286] */
      ADD_ACTION_HANDLER(CanControllerDevice::ForceBusOnAction);
      actions.Add("ForceBusOn", "Force a controller that is in bus-off mode to become active again only use to undo a ForceBusOff action", "");
      /* [$CAN 1117] */
      ADD_ACTION_HANDLER(CanControllerDevice::ForceWakeupAction);
      actions.Add("ForceWakeup", "Force the controller to wakeup", "");

      /* [$CAN 1120] */
      ADD_ACTION_HANDLER(CanControllerDevice::StateAction);
      actions.Add("InjectState", "Force the controller to change state", "Raises the state event").
            In("State","Option to change the state of the controller","Start|Stop|Sleep|Wakeup");
      
    }

    //--------------------------------------------------------------------------
    vrtaErrType DropWriteAction(const vrtaAction &action) {
      vrtaUInt DropWrite;
      UnpackData(action, DropWrite);
      Can_Drop_Write_Action_helper(_index, DropWrite); /* [$CAN 1043] [$CAN 1044] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType DropReceiveAction(const vrtaAction &action) {
      vrtaUInt DropReceive;
      UnpackData(action, DropReceive);
      Can_Drop_Receive_Action_helper(_index, DropReceive); /* [$CAN 1045] [$CAN 1046] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    struct WriteActionType {vrtaUInt txconfirmation; vrtaUInt hth; vrtaUInt txpduid;  vrtaUInt id; vrtaUInt length; uint8 data[CAN_MAX_DATA_LENGTH];};
    vrtaErrType InjectWriteAction(const vrtaAction &action) {
      WriteActionType write;
      UnpackData(action, write);
      Can_PduType pduInfo;
      pduInfo.swPduHandle = write.txpduid;
      pduInfo.length = write.length;
      pduInfo.id = write.id;
      pduInfo.sdu = write.data;
      Can_Inject_Write_helper(_index, write.hth, &pduInfo, write.txconfirmation, TRUE);  /* [$CAN 1052] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    struct RxActionType {vrtaUInt hrh; vrtaUInt id; vrtaUInt length; uint8 data[CAN_MAX_DATA_LENGTH];};
    vrtaErrType InjectRxAction(const vrtaAction &action) {
      RxActionType receive;
      UnpackData(action, receive);
      Can_Hwp_Frame frame;
      frame.injected = TRUE;
      frame.txConfirm = FALSE;
      frame.swPduHandle = 0;
      frame.id = receive.id;
      frame.length = receive.length;
      memcpy(frame.data, receive.data, receive.length);
      Can_Inject_Rxaction_helper(_index, receive.hrh, &frame); /* [$CAN 1055] */
      return RTVECUErr_NONE;
    }
    
    //--------------------------------------------------------------------------
    vrtaErrType ForceBusOffAction(const vrtaAction &action) {
      Can_Force_Busoff(_id ); /* [$CAN 1118] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType ForceBusOnAction(const vrtaAction &action) {
      Can_Force_Buson(_id ); /* [$CAN 1287] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType ForceWakeupAction(const vrtaAction &action) {
      Can_Force_Wakeup(_id ); /* [$CAN 1119] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType StateAction(const vrtaAction &action) {
      vrtaUInt state;
            Can_StateTransitionType canState;
      UnpackData(action, state);
      canState = (Can_StateTransitionType)state;
            Can_SetControllerMode_helper(_id, canState, TRUE); /* [$CAN 1122] */
      return RTVECUErr_NONE;
    }


    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the event handlers and descriptions
    void GetDeviceEvents(EventList &events) {
      /* [$CAN 1022] */
      ADD_EVENT_HANDLER(CanControllerDevice::StateEvent);
        events.Add("State",  "Can controller state", "Poll,Raise").
          Out("State", "Can controller State", "Uninit|Stopped|Started|Sleep").
          Out("Name", "Can controller name","%s");
      ADD_EVENT_HANDLER(CanControllerDevice::Parent);
        events.Add("_Parent", "ID of the Device that owns this device", "Poll").
          Out("Id", "Parent ID", "%u");
      /* [$CAN 1024] */
      ADD_EVENT_HANDLER(CanControllerDevice::WriteEvent);
        events.Add("Write",  "Returns the last written frame", "Poll,Raise").
          Out("Source","Raised from an action or API","None|Api|Action").
          Out("Result","Last Transmit result","None|Ok|NotOk|Busy|Dropped").
          Out("Hth","Transmit object handle","%u").
          Out("CanTxPduId","Pdu Handle Id","%u").
          Out("Id","Frame Id","%u").
          Out("Length","Number of bytes of data","%u").
          Out("Data","Data bytes","%a");
      /* [$CAN 1030] */
      ADD_EVENT_HANDLER(CanControllerDevice::TxEvent);
        events.Add("Tx",  "Returns the last completed transmit frame", "Poll,Raise").
          Out("Source", "Raised from an action or API", "None|Api|Action").
          Out("Hth","Transmit object handle","%u").
          Out("CanTxPduId","Pdu Handle Id","%u").
          Out("Id","Frame Id","%u").
          Out("Length","Number of bytes of data","%u").
          Out("Data","Data bytes","%a");
      /* [$CAN 1033] */
      ADD_EVENT_HANDLER(CanControllerDevice::RxEvent);
        events.Add("Rx",  "Returns the last received frame", "Poll,Raise").
          Out("Source", "Raised from an action or API", "None|Network|Action").
          Out("Hrh","Receive object handle","%u").
          Out("Id","Frame Id","%u").
          Out("Length","Number of bytes of data","%u").
          Out("Data","Data bytes","%a");
    }

    //--------------------------------------------------------------------------
    vrtaErrType Parent(vrtaEvent &event) {
      VECU_LOCK();
      SetValue(event, _parent);
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType StateEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _status, (sizeof(_status.state)+ strlen(_status.name) + 1)); /* [$CAN 1028] */
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType WriteEvent(vrtaEvent &event) {
      VECU_LOCK();
      if(CAN_MAX_DATA_LENGTH == 64)
        PackData(event, _write, (sizeof(_write)- (CAN_MAX_DATA_LENGTH - _write._length)));  /* [$CAN 1029] */
      else
        PackData(event, _write, sizeof(_write));  /* [$CAN 1029] */
     
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType TxEvent(vrtaEvent &event) {
      VECU_LOCK();
      if(CAN_MAX_DATA_LENGTH == 64)
        PackData(event, _tx, (sizeof(_tx)-(CAN_MAX_DATA_LENGTH - _tx._length)));  /* [$CAN 1031] */
      else
         PackData(event, _tx, sizeof(_tx));
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType RxEvent(vrtaEvent &event) {
      VECU_LOCK();
      if(CAN_MAX_DATA_LENGTH == 64)
        PackData(event, _rx, (sizeof(_rx)-(CAN_MAX_DATA_LENGTH - _rx._length))); /* [$CAN 1037] */
      else
        PackData(event, _rx, sizeof(_rx));
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType ErrorStateEvent(vrtaEvent &event) {
      VECU_LOCK();
      PackData(event, _errorState, sizeof(_errorState));  /* [$CAN  1280] */ 
      VECU_UNLOCK();
      return RTVECUErr_NONE;
    }

};

//------------------------------------------------------------------------------
class CanDevice : public VirtualDevice {
  protected:
    uint32 _det_instance;
    uint32 _det_api;
    uint32 _det_error;
    uint8  _can_state;
    CanControllerDevice* _Controller[1];

  public:
    CanDevice(const char *name) {
      _det_instance = 0;
      _det_api = 0;
      _det_error = 0;
      _can_state = 0;
      RegisterAs(name);
      
      _Controller[0] = new CanControllerDevice("Can_Network_CANNODE_0", CanConf_CanController_Can_Network_CANNODE_0, 0, m_ID); /* [$CAN 1111]  */
      
    }

//------------------------------------------------------------------------------
#if (CAN_DEV_ERROR_DETECT == STD_ON)
    void ReportDETError(uint32 instanceId, uint32 apiId, uint32 errorId) {  /* [$CAN 1058] */
      _det_instance = instanceId;

      _det_api = apiId + 1U;
      switch (errorId) {
        case CAN_E_PARAM_POINTER: _det_error = 1U; break;
        case CAN_E_PARAM_HANDLE: _det_error = 2U; break;
        case CAN_E_PARAM_DLC: _det_error = 3U; break;
        case CAN_E_PARAM_CONTROLLER: _det_error = 4U; break;
        case CAN_E_UNINIT: _det_error = 5U; break;
        case CAN_E_TRANSITION: _det_error = 6U; break;
        case CAN_E_DATALOST: _det_error = 7U; break;
        case CAN_E_PARAM_BAUDRATE: _det_error = 8U; break;
      }
      Raise(EVENT_HANDLER(CanDevice::DETEvent));
    }
#endif

   void RaiseCanState(Can_DriverStatus state) {
      switch (state) {
        case CAN_UNINIT: _can_state = 0U; break;
        case CAN_READY:  _can_state = 1U; break;
      }
      Raise(EVENT_HANDLER(CanDevice::StateEvent));
   }

    //--------------------------------------------------------------------------
   void RaiseIsr(void){
#ifdef OS_ISR_VECTOR_Can_IrqHandler
     RaiseInterrupt(OS_ISR_VECTOR_Can_IrqHandler);
#endif
   }

    //--------------------------------------------------------------------------
    void UpdateStateEvent(int index, Can_EventState state, const char* hardwarename) {
      _Controller[index]->RaiseStateEvent(index, state, hardwarename);
    }

    void UpdateErrorState(int index, vrtaUInt errorState) {
      _Controller[index]->RaiseErrorStateEvent(errorState);
    }

    //--------------------------------------------------------------------------
   void UpdateWriteEvent(int index, boolean source, uint8 result, Can_HwHandleType Hth, Can_Hwp_Frame* frame) {
      _Controller[index]->RaiseWriteEvent(index, source, result, Hth, frame);
    }

    //--------------------------------------------------------------------------
    void UpdateRxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
      _Controller[index]->RaiseRxEvent(index, handle, frame);
    }

    //--------------------------------------------------------------------------
    void UpdateTxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
      _Controller[index]->RaiseTxEvent(index, handle, frame);
    }

  protected:
    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the basic information about the device
    void GetDeviceInfo(OptList &info) {
      info.Add("Type", "Can");
      info.Add("Description", "Implementation of AUTOSAR Can");
      info.Add("Version", "1.0.54"); /* [$CAN 1009] */
    }

    //--------------------------------------------------------------------------
    void GetDeviceActions(ActionList &actions) {

    }

    //--------------------------------------------------------------------------
    // Called during RegisterAs() to build the event handlers and descriptions
    void GetDeviceEvents(EventList &events) {
#if (CAN_DEV_ERROR_DETECT == STD_ON)  /* [$CAN 1014] */
      /* [$CAN 1056] */
      ADD_EVENT_HANDLER(CanDevice::DETEvent);
        events.Add("DET", "DET error raised in Can", "Poll,Raise").
          Out("Instance", "The Can instance",          "%u").
          Out("API",      "The API causing the error", CAN_APIS).
          Out("Error",    "The most recent error",     CAN_DETS);
#endif
      /* [$CAN 1019] */
      ADD_EVENT_HANDLER(CanDevice::StateEvent);
      events.Add("State",  "Can Driver State", "Poll,Raise").
        Out("State", "Can Driver State", "Uninit|Ready");
    }

    //--------------------------------------------------------------------------
    vrtaErrType DETEvent(vrtaEvent &event) {
      SetValue(event, _det_instance, _det_api, _det_error); /* [$CAN 1057] */
      return RTVECUErr_NONE;
    }

    //--------------------------------------------------------------------------
    vrtaErrType StateEvent(vrtaEvent &event) {
      SetValue(event, _can_state); /* [$CAN 1027] */
      return RTVECUErr_NONE;
    }
};

/*******************************************************************************
 *                         Global Variables
 ******************************************************************************/
static CanDevice Can("Can"); /* [$CAN 1005] [$CAN 1020] [$CAN 1008] */

/*******************************************************************************
 *                         Interface
 ******************************************************************************/

// -----------------------------------------------------------------------------
void Can_ReportDETError(uint32 instanceId, uint32 apiId, uint32 errorId) { /* [$CAN 1058] */
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  Can.ReportDETError(instanceId, apiId, errorId);
#endif
}

// -----------------------------------------------------------------------------
void Can_RaiseInterrupt(void) {
  Can.RaiseIsr();
}

//------------------------------------------------------------------------------
void Can_RaiseWriteEvent(int index, boolean source, uint8 result, Can_HwHandleType Hth, Can_Hwp_Frame* frame) {
   Can.UpdateWriteEvent(index, source, result, Hth, frame);
}

//------------------------------------------------------------------------------
void Can_RaiseRxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
   Can.UpdateRxEvent(index, handle, frame);
}

//------------------------------------------------------------------------------
void Can_RaiseTxEvent(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
   Can.UpdateTxEvent(index, handle, frame);
}

//------------------------------------------------------------------------------
void Can_RaiseStateEvent(int index, Can_EventState state, const char* hardwarename) {
  Can.UpdateStateEvent(index, state, hardwarename);
}

//------------------------------------------------------------------------------
void Can_RaiseCanState(Can_DriverStatus state) {
  Can.RaiseCanState(state);
}

void Can_RaiseErrorState(int index, vrtaUInt errorState) {
  Can.UpdateErrorState(index, errorState);
}

