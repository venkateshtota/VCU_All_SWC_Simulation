/*******************************************************************************
 * Autogenerated by MCALgen for CAN V1.0.54.30643: Can_Implementation.cpp
 *******************************************************************************/
 /* [$Satisfies $CAN 1003] */
 /* [$Satisfies $CAN 1004] */

// ---------------------------------------------------------------------
// Compile Options:
//  CAN_ALLOW_STOP_FROM_SLEEP : In Can_SetControllerMode_helper
//  CAN_SYNCHRONOUS_SETCONTROLLERMODE : In Can_SetControllerMode_helper
// ---------------------------------------------------------------------

extern "C" {
  #include "Can.h"
  #include "Os.h"
  #include "Can_Implementation.h"
#if (CAN_DEV_ERROR_DETECT == STD_ON)
  #include "Det.h"       /* [$CAN 393] */
#endif
  #include "EcuM_Cbk.h"  /* [$CAN 390] */
  #include "CanIf.h"
  #include "CanIf_Cbk.h" /* [$CAN 36] */
}
#include "virtualDevice.hpp"
#include "Can_Device.hpp"
#include "Can_HwProvider.hpp"
#include <string.h>
#include <limits.h>

#ifndef unix
#include <intrin.h>
#endif

/*******************************************************************************
 *                         Global Variables
 ******************************************************************************/
static Can_ConfigType* Can_CurrentConfigData = ((Can_ConfigType*) NULL_PTR);
static Can_DriverStatus Can_DriverState = CAN_UNINIT;  /* [$CAN 103] */

static Can_Hw** Can_ChannelHw;
static uint16 Can_hwobj_maxcount = 0;

static volatile bool Can_global_read_running = false;
static volatile bool Can_global_mode_running = false;
static volatile bool Can_global_wakeup_running = false;
static volatile bool Can_global_busoff_running = false;
static volatile bool Can_global_write_running = false;

class Can_ChannelStateType {
public:
  volatile bool            started;
  volatile bool            stopped;
  volatile bool            sleeping;
  volatile bool            busoff;

  volatile bool            wakeup;
  volatile bool            has_wokenup;
  volatile boolean         drop_write;
  volatile boolean         drop_receive;
  volatile uint32          disableinterruptcount;
  volatile Can_Hwp_Event   state;
  volatile bool            awaiting_completion;
  
  volatile uint16          active_baudrate;
  Can_ChannelStateType(void) {
    started          = false;
    stopped          = false;
    sleeping         = false;
    busoff           = false;
    wakeup           = false;
    has_wokenup      = false;
    drop_write       = FALSE;
    drop_receive     = FALSE;
    disableinterruptcount = 0;
    state            = CAN_HWP_EVENT_STOPPED;
    awaiting_completion = false;
    
    active_baudrate = 0;
  }
};

typedef uint8 Can_Buffer_Idx;
static const Can_Buffer_Idx RX_FRAME_BUFFER_SIZE = 16;

class Can_HwobjStateType {
  public:
    // rx frames are placed in a ring buffer
    Can_Hwp_Frame   rxFrames[RX_FRAME_BUFFER_SIZE];
    Can_Buffer_Idx  rxFrameNextIn;
    Can_Buffer_Idx  rxFrameNextOut;
    volatile Can_Buffer_Idx rxFrameCount;
    volatile uint16 rxHandles[RX_FRAME_BUFFER_SIZE];

    // tx frames have a single element buffer
    volatile bool   txInuse;
    Can_Hwp_Frame   txFrame;
    volatile bool   txcancel;
    volatile bool   deterror;
    bool            usesPolling;

  Can_HwobjStateType(void) {
    deterror = false;
    txcancel = false;
    usesPolling = false;
    txInuse = false;
    rxFrameNextIn = 0;
    rxFrameNextOut = 0;
    rxFrameCount = 0;

    /* [$CAN 1296] */
    for (Can_Buffer_Idx frameIndex = 0; frameIndex < RX_FRAME_BUFFER_SIZE; frameIndex++) {
      rxFrames[frameIndex].id = 55;
      rxFrames[frameIndex].swPduHandle = 55;
      rxFrames[frameIndex].injected = false;
      rxFrames[frameIndex].txConfirm = false;
      rxFrames[frameIndex].length = 8;
      rxHandles[frameIndex] = 0;
      memset(&rxFrames[frameIndex].data,55,8);
    }

    memcpy(&txFrame, &rxFrames[0], sizeof(rxFrames[0]) );
  }

  /* [$CAN 1294] */
  void enqueue(const Can_Hwp_Frame* frame, Can_HwHandleType handle) {
    VECU_LOCK();

    if (rxFrameCount != 0) {
      // ring buffer is non-empty (TEST)
#ifdef unix
      asm volatile ("nop");
#else
      __nop();
#endif
    }

    if (frameBufferIsFull()) {
      deterror = true;
    } else {
      // add incoming frame to rxFrames ring buffer
      rxFrames[rxFrameNextIn] = *frame;
      rxHandles[rxFrameNextIn] = handle;

      // calculate the position of the next frame to be added
      rxFrameNextIn = (rxFrameNextIn + 1) % RX_FRAME_BUFFER_SIZE;
      rxFrameCount = rxFrameCount + 1;
    }

    VECU_UNLOCK();
  }
  
  void removeNextFrame(PduInfoType& pduInfo, Can_HwType& mailbox, uint32 controllerIndex) {
      VECU_LOCK();

      // remove incoming frame from rxFrames ring buffer (BSW-10269)
      // and then make a copy of the frame data before leaving the critical section (BSW-10267)
      uint8 sduCopy[CAN_MAX_FRAME_LENGTH];
      memcpy(sduCopy, rxFrames[rxFrameNextOut].data, CAN_MAX_FRAME_LENGTH); /* [$CAN 1296] */
      pduInfo.SduDataPtr = sduCopy;
      pduInfo.SduLength = rxFrames[rxFrameNextOut].length;

      mailbox.Hoh = rxHandles[rxFrameNextOut];
      mailbox.CanId = rxFrames[rxFrameNextOut].id;
      mailbox.ControllerId = Can_CurrentConfigData->Controllers[controllerIndex].hwId;

      rxFrameNextOut = (rxFrameNextOut + 1) % RX_FRAME_BUFFER_SIZE;
      rxFrameCount = rxFrameCount - 1;

      VECU_UNLOCK();
  }

private:
  bool frameBufferIsFull() const {
    return rxFrameCount >= RX_FRAME_BUFFER_SIZE;
  }
};

static Can_ChannelStateType* Can_ChannelState = ((Can_ChannelStateType*) NULL_PTR);
static Can_HwobjStateType* Can_HwobjState = ((Can_HwobjStateType*) NULL_PTR);

/*******************************************************************************
*                         API Provided to Can.c
 ******************************************************************************/
extern "C" {

//-----------------------------------------------------------------------------
Std_ReturnType Can_DETError(uint32 instanceId, uint32 apiId, uint32 errorId, boolean fromAction) {
#if (CAN_DEV_ERROR_DETECT == STD_ON)  /* [$CAN 83] [$CAN 424]*/
  if (!fromAction) {
    Det_ReportError(CAN_MODULE_ID, instanceId, apiId, errorId);  /* [$CAN 27] [$CAN 28] [$CAN 235] */
  }
  Can_ReportDETError(instanceId, apiId, errorId); /* [$CAN 1058] [$CAN 1013] */
#endif
  return E_NOT_OK; /* [$CAN 89]  [$CAN 91] */
}


// -----------------------------------------------------------------------------
uint32 Can_Get_Controller_Index(uint8 ctrlId) {
  for (uint32 index = 0U; index < Can_CurrentConfigData->ControllerCount; index++) {
    if (ctrlId == (Can_CurrentConfigData->Controllers[index].ControllerId)) {
      return index;
    }
  }
  return CAN_NO_CONTROLLER_INDEX;
}

// -----------------------------------------------------------------------------
uint32 Can_Check_Valid_Baudrate(uint32 ctrlIndex, uint16 baudrate, uint32 apiId) {
 const Can_ControllerConfigType* ctrl = &Can_CurrentConfigData->Controllers[ctrlIndex];
  for (uint32 baudrate_index = 0U; baudrate_index < ctrl->BaudrateConfigCount; baudrate_index++ ) {
    if((apiId == CAN_CHANGEBAUDRATE_API_ID) || (apiId == CAN_CHECKBAUDRATE_API_ID) || (apiId == CAN_INITCONTROLLER_API_ID)) {
      if (ctrl->BaudrateConfigs[baudrate_index].Baudrate == baudrate) {
        return baudrate_index;
      }
    }
    if(apiId == CAN_SETBAUDRATE_API_ID) { // AR 4.2.1 specific
      if (ctrl->BaudrateConfigs[baudrate_index].BaudrateConfigId == baudrate) {
        return baudrate_index;
      }
    }
  }
  return CAN_NO_BAUDRATE_INDEX;
}


// -----------------------------------------------------------------------------
Can_DriverStatus Can_Get_Driver_State(void) {
  return Can_DriverState;
}

// -----------------------------------------------------------------------------
uint32 Can_Get_Controller_Index_From_Hth(Can_HwHandleType hth) {
  if (hth >= Can_CurrentConfigData->TxObjectIdToControllerIndexLength) {
    return CAN_NO_CONTROLLER_INDEX;
  }
  return Can_CurrentConfigData->TxObjectIdToControllerIndex[hth];
}

// -----------------------------------------------------------------------------
uint32 Can_Get_Controller_Index_From_Hrh(Can_HwHandleType hrh) {
  if (hrh >= Can_CurrentConfigData->RxObjectIdToControllerIndexLength) {
    return CAN_NO_CONTROLLER_INDEX;
  }
  return Can_CurrentConfigData->RxObjectIdToControllerIndex[hrh];
}

// -----------------------------------------------------------------------------
void Can_Rxupcall(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {   /* [$CAN 59] [$CAN 423]*/
  Can_RaiseRxEvent(index, handle, frame); // Raise Rx Event /* [$CAN 1039] [$CAN 1050] */

  if ((Can_ChannelState[index].drop_receive) && !frame->injected) { /* [$CAN 1045]  [$CAN 1046] [$CAN 1049] */
    return;
  }

  Can_HwobjStateType& hwObj = Can_HwobjState[handle];

  /* [$CAN 1294] */
  hwObj.enqueue(frame, handle);

  if (!hwObj.deterror) {
#ifdef OS_ISR_VECTOR_Can_IrqHandler
    const Can_Mode rxProcessMode = Can_CurrentConfigData->Controllers[index].RxProcessing;

    if ((rxProcessMode == CAN_INTERRUPT || (rxProcessMode == CAN_MIXED && hwObj.usesPolling == 0)) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] */
      Can_RaiseInterrupt(); /* [$CAN 33] */
    }
#endif
  }
}

// -----------------------------------------------------------------------------
void Can_TxConfirm(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
  Can_RaiseTxEvent(index, handle, frame); // Raise Tx Event  /* [$CAN 1032] */
  VECU_LOCK();
  Can_HwobjState[handle].txFrame = *frame;
  Can_HwobjState[handle].txInuse = true;
  Can_HwobjState[handle].txcancel = false;
  VECU_UNLOCK();
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if((Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_INTERRUPT || (Can_CurrentConfigData->Controllers[index].RxProcessing == CAN_MIXED && Can_HwobjState[handle].usesPolling == 0)) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] */
    Can_RaiseInterrupt(); /* [$CAN 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
void Can_TxCancel(int index, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
  VECU_LOCK();
  Can_HwobjState[handle].txFrame = *frame;
  Can_HwobjState[handle].txcancel = true;
  Can_HwobjState[handle].txInuse = true;
  VECU_UNLOCK();
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if ((Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_INTERRUPT || (Can_CurrentConfigData->Controllers[index].RxProcessing == CAN_MIXED && Can_HwobjState[handle].usesPolling == 0)) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] */
    Can_RaiseInterrupt(); /* [$CAN 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
void Can_Wakeupcall(int index, const char* hardwarename) {
  Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED; /* [$CAN 270] */
  Can_RaiseStateEvent(index, CAN_STATE_STOPPED, hardwarename); /* [$CAN 1023] */
  Can_ChannelState[index].wakeup = true;
  Can_ChannelState[index].has_wokenup = true;
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if((Can_CurrentConfigData->Controllers[index].WakeupProcessing == CAN_INTERRUPT) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] */
    Can_RaiseInterrupt(); /* [$CAN 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
void Can_Busoffcall(int index, const char* hardwarename) {
  Can_ChannelState[index].state = CAN_HWP_EVENT_BUSOFF;
    Can_RaiseStateEvent(index, CAN_STATE_STOPPED, hardwarename); /* [$CAN 1023] */
  Can_ChannelState[index].busoff = true;
#ifdef OS_ISR_VECTOR_Can_IrqHandler
  if((Can_CurrentConfigData->Controllers[index].BusoffProcessing == CAN_INTERRUPT) && (Can_ChannelState[index].disableinterruptcount == 0)) { /* [$CAN 202] [$CAN 33] */
    Can_RaiseInterrupt(); /* [$CAN 33] */
  }
#endif
}

// -----------------------------------------------------------------------------
/*Can ISR calls this API and process the Main functions */
void Can_Isr_handler() {
  Can_MainFunction_BusOff_helper(TRUE);
  Can_MainFunction_Wakeup_helper(TRUE);
  Can_MainFunction_Read_helper(TRUE);
  Can_MainFunction_Write_helper(TRUE);
}

// -----------------------------------------------------------------------------
void Can_Callback(uint32 index, Can_Hwp_Event event, Can_HwHandleType handle, Can_Hwp_Frame* frame) {

  if (Can_CurrentConfigData == NULL_PTR) {
    return;
  }
  if (index >= Can_CurrentConfigData->ControllerCount) {
    return;
  }
  const char* hardwarename = Can_ChannelHw[index]->Name();
  switch(event) {
    case CAN_HWP_EVENT_RUNNING:
      Can_ChannelState[index].state = event;
      Can_RaiseStateEvent(index, CAN_STATE_STARTED, hardwarename); /* [$CAN 1023] */
      Can_ChannelState[index].started = true;
      break;

    case CAN_HWP_EVENT_SLEEPING:
      Can_ChannelState[index].state = event;
      Can_RaiseStateEvent(index, CAN_STATE_SLEEP, hardwarename); /* [$CAN 1023] */
      Can_ChannelState[index].sleeping = true;
      break;

    case CAN_HWP_EVENT_STOPPED:
      Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      Can_RaiseStateEvent(index, CAN_STATE_STOPPED, hardwarename); /* [$CAN 1023] */
      Can_ChannelState[index].stopped = true;
      break;

    case CAN_HWP_EVENT_WAKEUP:
      Can_Wakeupcall(index, hardwarename);
      break;

    case CAN_HWP_EVENT_BUSOFF:
      Can_Busoffcall(index, hardwarename);
      break;

    case CAN_HWP_EVENT_RX:
      Can_Rxupcall(index, handle, frame);
      break;

    case CAN_HWP_EVENT_DATALOST:
      Can_HwobjState[index].deterror = true;
      break;

    case CAN_HWP_EVENT_TX_COMPLETED:
      Can_TxConfirm(index, handle, frame);
      break;

    case CAN_HWP_EVENT_TX_CANCELLED:
      Can_TxCancel(index, handle, frame);
      break;

    default:
      break;
  }
}

// -----------------------------------------------------------------------------
void Can_DiscardPendingInterrupts(uint32 controllerIndex) {
  // The VECU lock must be held when this function is called.
  bool txInterrupts     = (Can_CurrentConfigData->Controllers[controllerIndex].TxProcessing == CAN_INTERRUPT);
  bool rxInterrupts     = (Can_CurrentConfigData->Controllers[controllerIndex].RxProcessing == CAN_INTERRUPT);
  bool busOffInterrupts = (Can_CurrentConfigData->Controllers[controllerIndex].BusoffProcessing == CAN_INTERRUPT);
  bool wakeupInterrupts = (Can_CurrentConfigData->Controllers[controllerIndex].WakeupProcessing == CAN_INTERRUPT);

  for (uint16 i = 0U; i < Can_hwobj_maxcount; i++) {
    if (txInterrupts && Can_Get_Controller_Index_From_Hth(i) == controllerIndex) {
      Can_HwobjState[i].txInuse = false;
      Can_HwobjState[i].rxFrameCount = 0;
    }
    if (rxInterrupts && Can_Get_Controller_Index_From_Hrh(i) == controllerIndex) {
      Can_HwobjState[i].txInuse = false;
      Can_HwobjState[i].rxFrameCount = 0;
    }
  }

  if (busOffInterrupts) {
    Can_ChannelState[controllerIndex].busoff = false;
  }

  if (wakeupInterrupts) {
    Can_ChannelState[controllerIndex].wakeup = false;
  }
}

// -----------------------------------------------------------------------------
void SetBaudrateParameters(uint32& controller_index, uint32& baudrate_index){

  Can_Hwp_BaudrateConfig canHwpBaudrateConfig;
  const Can_ControllerBaudrateConfigType *baudrateConfig;
  baudrateConfig = &Can_CurrentConfigData->Controllers[controller_index].BaudrateConfigs[baudrate_index];
  canHwpBaudrateConfig.baudrate = baudrateConfig->Baudrate; /* [$CAN 384] */
  canHwpBaudrateConfig.phaseSegment1 = baudrateConfig->Seg1;
  canHwpBaudrateConfig.phaseSegment2 = baudrateConfig->Seg2;
  canHwpBaudrateConfig.propagationDelay = baudrateConfig->PropSeg;
  canHwpBaudrateConfig.syncJumpWidth = baudrateConfig->SyncJumpWidth;
    Can_HwpFdbaudrateConfig fdBaudrateConfig;
    canHwpBaudrateConfig.fdBaudrateConfig = &fdBaudrateConfig;
    canHwpBaudrateConfig.fdBaudrateConfig->baudrate = 0; 
    if(baudrateConfig->FdBaudrateConfig != NULL_PTR) {
      canHwpBaudrateConfig.fdBaudrateConfig->baudrate = baudrateConfig->FdBaudrateConfig->BaudRate;
      canHwpBaudrateConfig.fdBaudrateConfig->txBitRateSwitch = baudrateConfig->FdBaudrateConfig->TxBitRateSwitch;
      canHwpBaudrateConfig.fdBaudrateConfig->phaseSegment1 = baudrateConfig->FdBaudrateConfig->Seg1;
      canHwpBaudrateConfig.fdBaudrateConfig->phaseSegment2 = baudrateConfig->FdBaudrateConfig->Seg2;
      canHwpBaudrateConfig.fdBaudrateConfig->propagationDelay = baudrateConfig->FdBaudrateConfig->PropSeg;
      canHwpBaudrateConfig.fdBaudrateConfig->syncJumpWidth = baudrateConfig->FdBaudrateConfig->SyncJumpWidth;    
      canHwpBaudrateConfig.fdBaudrateConfig->trcvDelayCompensationOffset = baudrateConfig->FdBaudrateConfig->TrcvDelayCompensationOffset;    
    }
  Can_ChannelState[controller_index].active_baudrate = baudrate_index;
  Can_ChannelHw[controller_index]->SetBaudrate(&canHwpBaudrateConfig);
}

// -----------------------------------------------------------------------------
// Initializes all the Can Controllers
void Can_Init_helper(const Can_ConfigType* configData) { /* [$CAN 250] */
  uint32 index = 0;

  if (Can_Get_Driver_State() != CAN_UNINIT) {
    Can_DETError(0U, CAN_INIT_API_ID, CAN_E_TRANSITION, FALSE); /* [$CAN 174] */
    return;  /* [$CAN 91] */
  }
  if (configData != &Can_ConfigData && configData != CAN_DEFAULT_CONFIG) {
    Can_DETError(0U, CAN_INIT_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 175] */
    return;  /* [$CAN 91] */
  }

  Can_CurrentConfigData = &Can_ConfigData; /* [$CAN 245] */

  Can_ChannelHw = new Can_Hw*[Can_CurrentConfigData->ControllerCount];
  Can_ChannelState = new Can_ChannelStateType[Can_CurrentConfigData->ControllerCount];

  if (Can_CurrentConfigData->RxObjectIdToControllerIndexLength > Can_CurrentConfigData->TxObjectIdToControllerIndexLength){
    Can_hwobj_maxcount = Can_CurrentConfigData->RxObjectIdToControllerIndexLength + 1;
  } else {
    Can_hwobj_maxcount = Can_CurrentConfigData->TxObjectIdToControllerIndexLength + 1;
  }

  Can_HwobjState = new Can_HwobjStateType[Can_hwobj_maxcount];
  
  for(index = 0U; index < Can_CurrentConfigData->ControllerCount; index++){
    Can_ChannelHw[index] = Can_GetHw(Can_Callback,
                               index,
                               Can_CurrentConfigData->Controllers[index].providerId,
                               Can_CurrentConfigData->Controllers[index].hwId,
                               Can_CurrentConfigData->Controllers[index].fallbackProviderId,
                               Can_CurrentConfigData->Controllers[index].fallbackHwId);

    Can_ChannelHw[index]->Configure(Can_CurrentConfigData->Controllers[index].HwpConfig);
    Can_RaiseStateEvent(index, CAN_STATE_STOPPED, Can_ChannelHw[index]->Name());  /* [$CAN 1023] [$CAN 259] */

    /* Set default baudrate for controller */
    uint32  baudrate_index =  Can_CurrentConfigData->Controllers[index].DefaultBaudrateRefId;
    SetBaudrateParameters(index, baudrate_index);
  }

  Can_DriverState = CAN_READY; /* [$CAN 246] */
  Can_RaiseCanState(Can_DriverState);  /* [$CAN 1021] */
}

// -----------------------------------------------------------------------------
/* [$CAN 1010] */
void Can_InitController_helper(uint8 controller, const Can_ControllerBaudrateConfigType* config) {
  if (config == NULL_PTR) {
    Can_DETError(0U, CAN_INITCONTROLLER_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 1103] */
    return; /* [$CAN 91] */
  }
  Can_ChangeBaudrate_helper(controller, config->Baudrate, CAN_INITCONTROLLER_API_ID); /* [$CAN 1107] */
}

// -----------------------------------------------------------------------------
// Returns the version information
void Can_GetVersionInfo_helper(Std_VersionInfoType* versionInfo) {
  if (versionInfo == NULL_PTR) {
    Can_DETError(0U, CAN_GETVERSIONINFO_API_ID, CAN_E_PARAM_POINTER, FALSE); /* [$CAN 177] */
    return; /* [$CAN 91] */
  }
  /* [$CAN 105] */
  versionInfo->vendorID = CAN_VENDOR_ID;
  versionInfo->moduleID = CAN_MODULE_ID;
  versionInfo->sw_major_version = CAN_SW_MAJOR_VERSION;
  versionInfo->sw_minor_version = CAN_SW_MINOR_VERSION;
  versionInfo->sw_patch_version = CAN_SW_PATCH_VERSION;
}
// -----------------------------------------------------------------------------
Std_ReturnType Can_CheckBaudrate_helper(uint8 controller, const uint16 baudrate) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_CHECKBAUDRATE_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 456] */
    return E_NOT_OK; /* [$CAN 91] */
  }

  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    return Can_DETError(0U, CAN_CHECKBAUDRATE_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 457] [$CAN 91] */
  }

  if (Can_Check_Valid_Baudrate(index, baudrate, CAN_CHECKBAUDRATE_API_ID) == CAN_NO_BAUDRATE_INDEX) {
    return Can_DETError(0U, CAN_CHECKBAUDRATE_API_ID, CAN_E_PARAM_BAUDRATE, FALSE); /* [$CAN 458] [$CAN 91] */
  }
  return E_OK;
}

// -----------------------------------------------------------------------------
/* [$CAN 1011] */
Std_ReturnType Can_ChangeBaudrate_helper (uint8 controller, const uint16 baudrate, uint32 apiId) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    return Can_DETError(0U, apiId, CAN_E_UNINIT, FALSE); /* [$CAN 450] [$CAN 1104] [$CAN 91] [$CAN 1131] */
  }

  uint32 controller_index =  Can_Get_Controller_Index(controller);
  if (controller_index == CAN_NO_CONTROLLER_INDEX) {
    return Can_DETError(0U, apiId, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 452] [$CAN 1105] [$CAN 91] [$CAN 1133] */
  }

  uint32 baudrate_index = Can_Check_Valid_Baudrate(controller_index, baudrate, apiId);

  if (baudrate_index == CAN_NO_BAUDRATE_INDEX) {
    return Can_DETError(0U, apiId, CAN_E_PARAM_BAUDRATE, FALSE); /* [$CAN 451] [$CAN 91] [$CAN 1132] */
  }

  if (Can_ChannelState[controller_index].state != CAN_HWP_EVENT_STOPPED) {
    return Can_DETError(0U, apiId, CAN_E_TRANSITION, FALSE); /* [$CAN 453] [$CAN 1106] [$CAN 91] [$CAN 260] [$CAN 422] */
  }

  SetBaudrateParameters(controller_index, baudrate_index);
  return E_OK;
}



// -----------------------------------------------------------------------------
// [$CAN 230]
Can_ReturnType Can_SetControllerMode_helper(uint8 controller, Can_StateTransitionType transition, boolean fromAction) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_UNINIT, fromAction); /* [$CAN 198] */
    return CAN_NOT_OK;  /* [$CAN 91] */
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_PARAM_CONTROLLER, fromAction); /* [$CAN 199] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }
  // If Can has been stopped by ForceBusOff then we should not start the controller again.
  if (Can_ChannelState[index].state == CAN_HWP_EVENT_BUSOFF) {
    return CAN_NOT_OK;
  }
  /* [$CAN 17] */
  switch(transition) {
    case CAN_T_START:
      /* [$CAN 261] */
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Start();
        Can_ChannelState[index].state = CAN_HWP_EVENT_RUNNING;
      } else {
        Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 409] [$CAN 200] */
        return CAN_NOT_OK; /* [$CAN 91] */
      }
      break;

    case CAN_T_STOP:
      /* [$CAN 263] */
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        if (!Can_ChannelState[index].awaiting_completion) {
          CanIf_ControllerModeIndication(controller, CANIF_CS_STOPPED);
        }
#ifdef CAN_ALLOW_STOP_FROM_SLEEP  /* Compile option */
  
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_SLEEPING) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Stop();
        Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
#endif
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_RUNNING) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Stop();
        Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      } else {
        Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 410] [$CAN 200] */
        return CAN_NOT_OK; /* [$CAN 91] */
      }
      break;

    case CAN_T_SLEEP:
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_SLEEPING) {
        if (!Can_ChannelState[index].awaiting_completion) {
            CanIf_ControllerModeIndication(controller, CANIF_CS_SLEEP);
        }
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelState[index].has_wokenup = false; /* [$CAN 361] Clear the wakeup flag before going to SLEEP. */
        Can_ChannelState[index].state = CAN_HWP_EVENT_SLEEPING;  /* [$CAN 265] */
        Can_ChannelHw[index]->Sleep();  /* [$CAN 257] */
      } else {
         Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 411] [$CAN 200] */
         return CAN_NOT_OK; /* [$CAN 91] */
      }
      break;
        case CAN_T_WAKEUP:
      if (Can_ChannelState[index].state == CAN_HWP_EVENT_STOPPED) {
        if (!Can_ChannelState[index].awaiting_completion) {
            CanIf_ControllerModeIndication(controller, CANIF_CS_STOPPED);
        }
      } else if (Can_ChannelState[index].state == CAN_HWP_EVENT_SLEEPING) { /* [$CAN 267] */
        Can_ChannelState[index].awaiting_completion = true;
        Can_ChannelHw[index]->Stop();
        Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
      } else {
        Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 200] [$CAN 412] */
        return CAN_NOT_OK; /* [$CAN 48] [$CAN 91] */
      }
      break;
        default:
      Can_DETError(0U, CAN_SETCONTROLLERMODE_API_ID, CAN_E_TRANSITION, fromAction); /* [$CAN 200] */
      return CAN_OK; /* [$CAN 91] */
  }

#ifdef CAN_SYNCHRONOUS_SETCONTROLLERMODE /* Compile option */
  while (Can_ChannelState[index].awaiting_completion) {
    Can_MainFunction_Mode_helper();
    vrtaYield(0);
  }
#endif

  return CAN_OK;
}

// -----------------------------------------------------------------------------
void Can_DisableControllerInterrupts_helper(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_DETError(0U, CAN_DISABLECONTROLLERINTERRUPTS_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 205] */
     return; /* [$CAN 91] */
  }

  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     Can_DETError(0U, CAN_DISABLECONTROLLERINTERRUPTS_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 206] */
     return;
  }

  VECU_LOCK();
  Can_ChannelState[index].disableinterruptcount  += 1;  /* [$CAN 202] [$CAN 49] */
  VECU_UNLOCK();
}

// -----------------------------------------------------------------------------
void Can_EnableControllerInterrupts_helper(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_ENABLECONTROLLERINTERRUPTS_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 209] */
    return; /* [$CAN 91] */
  }
  uint32 index =  Can_Get_Controller_Index(controller);

  if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_ENABLECONTROLLERINTERRUPTS_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 210] */
    return;
  }

  if (Can_ChannelState[index].disableinterruptcount != 0) { /* [$CAN 208] */
    VECU_LOCK();
    Can_ChannelState[index].disableinterruptcount  -= 1; /* [$CAN 202] [$CAN 50] */

    // If interrupts are now enabled we want to discard any pending events that
    // would result in a notification to CanIf. This is to avoid the following sort
    // of race: interrupts are disabled and a frame is received, interrupts are
    // enabled, a frame is transmitted, the received frame is indicated to
    // CanIf by the transmit complete interrupt processing.
    if (Can_ChannelState[index].disableinterruptcount == 0) {
      Can_DiscardPendingInterrupts(index);
    }
    VECU_UNLOCK();
  }
}

// -----------------------------------------------------------------------------
Can_ReturnType Can_CheckWakeup_helper(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_CHECKWAKEUP_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 362] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }

  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_CHECKWAKEUP_API_ID, CAN_E_PARAM_CONTROLLER, FALSE); /* [$CAN 363] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }
  if(Can_ChannelState[index].has_wokenup) {
#if (CAN_WAKEUP_SUPPORT == STD_ON)
    EcuM_SetWakeupEvent(Can_CurrentConfigData->Controllers[index].EcuMwakeupSourceId);
#endif
    return CAN_OK; /* [$CAN 361] */
  }
  return CAN_NOT_OK;
}

// -----------------------------------------------------------------------------
Can_ReturnType Can_Write_helper(Can_HwHandleType hth, const Can_PduType* pduInfo, boolean txConfirmFlag, boolean fromAction) {
  Can_ReturnType ret;
  
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_UNINIT, fromAction); /* [$CAN 216] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }

  uint32 index = Can_Get_Controller_Index_From_Hth(hth);
    if (index == CAN_NO_CONTROLLER_INDEX) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_HANDLE, fromAction); /* [$CAN 217] */
    return CAN_NOT_OK; /* [$CAN 91] */
    }

  // if the controller has been put into state busoff or (from AR4.3.1) passive then the controller must not transmit to the network.

  if (pduInfo == NULL_PTR) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_POINTER, fromAction); /* [$CAN 219] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }

  if (pduInfo->sdu == NULL_PTR) {
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_POINTER, fromAction); /* [$CAN 219] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }

  const Can_ControllerBaudrateConfigType *baudrateConfig;
  uint16 baudrate_index = Can_ChannelState[index].active_baudrate;
  baudrateConfig = &Can_CurrentConfigData->Controllers[index].BaudrateConfigs[baudrate_index]; 
  
  if ((pduInfo->length > CAN_MAX_DATA_LENGTH) || 
      ((pduInfo->length > CAN_STD_DATA_LENGTH) && (baudrateConfig->FdBaudrateConfig == NULL_PTR)) ||
      ((pduInfo->length > CAN_STD_DATA_LENGTH) && (!CAN_ID_FD_BIT_SET(pduInfo->id)))) { /* [$CAN 1219] [$CAN 1230] */
    Can_DETError(0U, CAN_WRITE_API_ID, CAN_E_PARAM_DLC, fromAction); /* [$CAN 218] [$CAN 1218] [$CAN 1219] */
    return CAN_NOT_OK; /* [$CAN 91] */
  }
  /*  [$CAN 11] */
  Can_Hwp_Frame frame;
  frame.txConfirm = txConfirmFlag;
  frame.injected = fromAction;  /* [$CAN 1035] */
  frame.swPduHandle = pduInfo->swPduHandle; /* [$CAN 276] */
  frame.id = pduInfo->id;

  if (   CAN_ID_FD_BIT_SET(pduInfo->id)                   /* if the message is supposed to be a FD frame */
      && ( (baudrateConfig->FdBaudrateConfig == NULL_PTR) || (baudrateConfig->FdBaudrateConfig->BaudRate == 0) ) /* but there is no FD conifg */
      && (pduInfo->length <= CAN_STD_DATA_LENGTH)) {      /* and the data is small enough to be sent as a CAN frame then send as a CAN frame */
    frame.id = pduInfo->id & ~CAN_ID_FD_BIT;    /*[$CAN 1231] */
  }
  frame.length      = pduInfo->length;
  memcpy(frame.data, pduInfo->sdu, frame.length);

  /* [$CAN 212] [$CAN 213] [$CAN 215] [$CAN 434] [$CAN 214] [$CAN 275] [$CAN 59] [$CAN 1162] */
  if (!Can_ChannelState[index].drop_write || fromAction) { /* [$CAN 1044]  */
    ret = Can_ChannelHw[index]->Write(hth, &frame); /* [$CAN 1163] [$CAN 1203] [$CAN 1229] [$CAN 1230] [$CAN 1231] [$CAN 1233] [$CAN 1234] */
    Can_RaiseWriteEvent(index, fromAction, ret, hth, &frame);  /* [$CAN 1026] [$CAN 1025] [$CAN 1036] */
  } else { /* [$CAN 1043] [$CAN 1047] [$CAN 1051] [$CAN 1048]*/
    Can_RaiseWriteEvent(index, fromAction, CAN_FRAME_DROPPED, hth, &frame); /* [$CAN 1034] [$CAN 1025] [$CAN 1036] */
    ret = CAN_OK;
  }
  return ret;
}


// -----------------------------------------------------------------------------
void Can_MainFunction_Write_helper (boolean fromIsr) { /* [$CAN 31] [$CAN 7] [$CAN 110] */
  bool run;
  Can_Hwp_Frame  txFrame;
#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
  PduInfoType     pduinfo;
#endif
  VECU_LOCK();
  if (Can_global_write_running) {
    run = false;
  } else {
    Can_global_write_running = true;
    run = true;
  }
  VECU_UNLOCK();

  if (!run) {
    return;
  }

  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_global_write_running = false;
     /* [$CAN 1289] */
    Can_DETError(0U, CAN_MAINFUNCTION_WRITE_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 179] [$CAN 431] */
        return; /* [$CAN 91] */
  }

  for (int i = 0; i < Can_hwobj_maxcount; i++) {
    uint32 index = Can_Get_Controller_Index_From_Hth(i);
    if (index != CAN_NO_CONTROLLER_INDEX) {
      /* [$CAN 1278] */
      if ((fromIsr && (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_INTERRUPT || (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_MIXED && Can_HwobjState[i].usesPolling == 0)) && Can_ChannelState[index].disableinterruptcount == 0)
         || (!fromIsr && (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_POLLING || (Can_CurrentConfigData->Controllers[index].TxProcessing == CAN_MIXED && Can_HwobjState[i].usesPolling)))) {
        if (Can_HwobjState[i].txInuse) {
          VECU_LOCK();
          txFrame = Can_HwobjState[i].txFrame;
#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
          pduinfo.SduDataPtr = &txFrame.data[0];
          pduinfo.SduLength = txFrame.length;
#endif
          Can_HwobjState[i].txInuse = false;
          VECU_UNLOCK();

          if (Can_HwobjState[i].txcancel) {
            Can_HwobjState[i].txcancel = false;
            if (txFrame.txConfirm) { /* [$CAN 1113] */
#if (CAN_HW_TRANSMIT_CANCELLATION == STD_ON)
              CanIf_CancelTxConfirmation(txFrame.swPduHandle, &pduinfo); /* [$CAN 287]  [$CAN 235] */
#endif
            }
          } else {
            if(txFrame.txConfirm) {  /* [$CAN 1053] [$CAN 1054] */
              CanIf_TxConfirmation(txFrame.swPduHandle);// Transmit Confirmation /* [$CAN 234] [$CAN 16] */
            }
          }
        }
      }
    }
  }
  Can_global_write_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Read_helper (boolean fromIsr) { /* [$CAN 396] [$CAN 108] [$CAN 7] */
  bool run;

  VECU_LOCK();
  if (Can_global_read_running) {
    run = false;
  } else {
    Can_global_read_running = true;
    run = true;
  }
  VECU_UNLOCK();

  if (!run) { /* [$CAN 12] */
    return;
  }

  if (Can_Get_Driver_State() == CAN_UNINIT) {
    Can_global_read_running = false;
     /* [$CAN 1290] */
    Can_DETError(0U, CAN_MAINFUNCTION_READ_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 181] [$CAN 431] */
        return; /* [$CAN 91] */
  }

  PduInfoType pduInfo;
  Can_HwType mailbox;

  for (int i = 0; i < Can_hwobj_maxcount; i++) {
    uint32 index = Can_Get_Controller_Index_From_Hrh(i);

    if (index != CAN_NO_CONTROLLER_INDEX) {
      Can_HwobjStateType& hwObj = Can_HwobjState[i];

      /* [$CAN 1277] */
      const Can_Mode rxProcessMode = Can_CurrentConfigData->Controllers[index].RxProcessing;
      const uint32 disableInterruptCount = Can_ChannelState[index].disableinterruptcount;

      if ((fromIsr && (rxProcessMode == CAN_INTERRUPT || rxProcessMode == CAN_MIXED) && !hwObj.usesPolling && disableInterruptCount == 0) 
            || (!fromIsr && (rxProcessMode != CAN_MIXED || hwObj.usesPolling))) {

        if (hwObj.deterror) {
          hwObj.deterror = false;

          Can_DETError(0U, CAN_MAINFUNCTION_READ_API_ID, CAN_E_DATALOST, FALSE); /* [$CAN 395] */
        }

        while (hwObj.rxFrameCount) {
          hwObj.removeNextFrame(pduInfo, mailbox, index); /* [$CAN 1295] */

          boolean doIndication = TRUE;

          if (Can_CurrentConfigData->CanLPduReceiveCalloutFunction != NULL_PTR) {
              doIndication = Can_CurrentConfigData->CanLPduReceiveCalloutFunction(mailbox.Hoh, mailbox.CanId, pduInfo.SduLength, pduInfo.SduDataPtr); /* [$CAN 444] [$CAN 1126] [$CAN 1232] */
          }

          if (doIndication) {
            /* [$CAN 279] [$CAN 234] [$CAN 59] [$CAN 396] [$CAN 60] [$CAN 1126] [$CAN 1232] */
            CanIf_RxIndication(&mailbox, &pduInfo);
          }
        }
      }
    }
  }

  Can_global_read_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_BusOff_helper ( boolean fromIsr) { /* [$CAN 109] [$CAN 7] [$CAN 110] */
  bool run;
  VECU_LOCK();

  if (Can_global_busoff_running) {
      run = false;
  }
  else {
      Can_global_busoff_running = true;
      run = true;
  }
  VECU_UNLOCK();
  if (!run) {
    return;
  }
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_global_busoff_running = false;
      /* [$CAN 1274] */
     Can_DETError(0U, CAN_MAINFUNCTION_BUSOFF_API_ID, CAN_E_UNINIT, FALSE);  /* [$CAN 184] [$CAN 431] */
          return; /* [$CAN 91] */
  }

  for (uint32 i = 0U; i < Can_CurrentConfigData->ControllerCount; i++) {
    if (Can_ChannelState[i].busoff) {
      Can_ChannelState[i].busoff = false;
      if((fromIsr && Can_CurrentConfigData->Controllers[i].BusoffProcessing == CAN_INTERRUPT && Can_ChannelState[i].disableinterruptcount == 0) || !fromIsr) {
         CanIf_ControllerBusOff(Can_CurrentConfigData->Controllers[i].ControllerId); /* [$CAN 234] [$CAN 20] */
      }
    }
  }
  Can_global_busoff_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Wakeup_helper (boolean fromIsr) /* [$CAN 112] [$CAN 7] [$CAN 110] [$CAN 271] */ {
  bool run;
  VECU_LOCK();
  if (Can_global_wakeup_running) {
      run = false;
  }
  else {
      Can_global_wakeup_running = true;
      run = true;
  }
  VECU_UNLOCK();
  if (!run) {
    return;
  }
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_global_wakeup_running = false;
      /* [$CAN 1275] */
     Can_DETError(0U, CAN_MAINFUNCTION_WAKEUP_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 186] [$CAN 431] */
          return;   /* [$CAN 91] */
  }
  for (uint32 i = 0U; i < Can_CurrentConfigData->ControllerCount; i++) {
    if ((Can_ChannelState[i].wakeup)) {
      Can_ChannelState[i].wakeup = false;
      if (Can_CurrentConfigData->Controllers[i].WakeupSupport) {
        if ((fromIsr && Can_CurrentConfigData->Controllers[i].WakeupProcessing == CAN_INTERRUPT && Can_ChannelState[i].disableinterruptcount == 0) || !fromIsr) {
          if (Can_CurrentConfigData->Controllers[i].EcuMwakeupSourceId != 0) {
#if (CAN_WAKEUP_SUPPORT == STD_ON)
             EcuM_CheckWakeup(Can_CurrentConfigData->Controllers[i].EcuMwakeupSourceId); /* [$CAN 364]  [$CAN 235] */
#endif
          }
        }
      }
    }
  }
  Can_global_wakeup_running = false;
}

// -----------------------------------------------------------------------------
void Can_MainFunction_Mode_helper (void) { /* [$CAN 369] [$CAN 7] */
  bool run;
  VECU_LOCK();
  if (Can_global_mode_running) {
      run = false;
  }
  else {
      Can_global_mode_running = true;
      run = true;
  }
  VECU_UNLOCK();
  if (!run) {
    return;
  }
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     Can_global_mode_running = false;
      /* [$CAN 1276] */
     Can_DETError(0U, CAN_MAINFUNCTION_MODE_API_ID, CAN_E_UNINIT, FALSE); /* [$CAN 379] [$CAN 431] */
          return;  /* [$CAN 91] */
  }
  for (uint32 i = 0U; i < Can_CurrentConfigData->ControllerCount; i++) {
    if (Can_ChannelState[i].started) {
      Can_ChannelState[i].awaiting_completion = false;
      Can_ChannelState[i].started = false;
      CanIf_ControllerModeIndication(Can_CurrentConfigData->Controllers[i].ControllerId,
        CANIF_CS_STARTED);  /* [$CAN 373]  [$CAN 234]  [$CAN 1121] */
    }
    if (Can_ChannelState[i].stopped) {
      Can_ChannelState[i].awaiting_completion = false;
      Can_ChannelState[i].stopped = false;
      CanIf_ControllerModeIndication(Can_CurrentConfigData->Controllers[i].ControllerId,
        CANIF_CS_STOPPED);  /* [$CAN 1121] */
    }
    if (Can_ChannelState[i].sleeping) {
      Can_ChannelState[i].awaiting_completion = false;
      Can_ChannelState[i].sleeping = false;
      CanIf_ControllerModeIndication(Can_CurrentConfigData->Controllers[i].ControllerId,
        CANIF_CS_SLEEP);  /* [$CAN 1121] */
    }
  }
  Can_global_mode_running = false;
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Force_Wakeup(uint8 controller) { /* [$CAN 1119] */
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  Can_ChannelHw[index]->ForceWakeup();
  return E_OK;
}


// -----------------------------------------------------------------------------
Std_ReturnType Can_Force_Buson(uint8 controller) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  if (Can_ChannelState[index].state == CAN_HWP_EVENT_BUSOFF) {
    Can_ChannelState[index].state = CAN_HWP_EVENT_STOPPED;
  }
  
  return E_OK;
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Force_Busoff(uint8 controller) { /* [$CAN 1118] */
  if (Can_Get_Driver_State() == CAN_UNINIT) {
     return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
     return E_NOT_OK;
  }
  Can_ChannelHw[index]->ForceBusOff();
  return E_OK;
}


// -----------------------------------------------------------------------------
static bool Can_Channel_Is_Initialized(uint8 index) {
  if (!Can_ChannelState || !Can_CurrentConfigData) {
    return false;
  }
  return (index < Can_CurrentConfigData->ControllerCount);
}

// -----------------------------------------------------------------------------
void Can_Drop_Write_Action_helper(uint8 index, boolean dropWrite) {
  if (Can_Channel_Is_Initialized(index)) {
    Can_ChannelState[index].drop_write  = dropWrite; /* [$CAN 1043] [$CAN 1044] */
  }
}

// -----------------------------------------------------------------------------
void Can_Drop_Receive_Action_helper(uint8 index, boolean dropReceive) {
  if (Can_Channel_Is_Initialized(index)) {
    Can_ChannelState[index].drop_receive = dropReceive;  /* [$CAN 1045] [$CAN 1046] */
  }
}

// -----------------------------------------------------------------------------
void Can_Inject_Write_helper(uint8 index, Can_HwHandleType hth, const Can_PduType* pduInfo, boolean txConfirmFlag, boolean fromAction) {
  Can_Write_helper(hth, pduInfo, txConfirmFlag, fromAction);
}

// -----------------------------------------------------------------------------
void Can_Inject_Rxaction_helper(uint8 index, Can_HwHandleType handle, Can_Hwp_Frame* frame) { /* [$CAN 1055] */
  if (!Can_Channel_Is_Initialized(index)) {
    return;
  }
  if (frame == NULL_PTR) {
    return;
  }
  uint32 index_tmp = Can_Get_Controller_Index_From_Hrh(handle);
  if (index_tmp != CAN_NO_CONTROLLER_INDEX && frame->length <= CAN_MAX_DATA_LENGTH) {
    Can_Rxupcall(index, handle, frame); /* [$CAN 1040] [$CAN 1055] */
  }
}

// -----------------------------------------------------------------------------
Std_ReturnType Can_Enable_Transmit_Processing_helper(uint8 controller, boolean enable) {
  if (Can_Get_Driver_State() == CAN_UNINIT) {
    return E_NOT_OK;
  }
  uint32 index =  Can_Get_Controller_Index(controller);
  if (index == CAN_NO_CONTROLLER_INDEX) {
    return E_NOT_OK;
  }
  Can_ChannelHw[index]->EnableTransmitProcessing(enable ? true : false);

  return E_OK;
}

}

