<?xml version="1.0" encoding="UTF-8"?>
<AUTOSAR xmlns="http://autosar.org/schema/r4.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://autosar.org/schema/r4.0 AUTOSAR_4-2-2.xsd">
  <ADMIN-DATA>
    <LANGUAGE>EN</LANGUAGE>
    <USED-LANGUAGES>
      <L-10 L="EN" xml:space="default">English</L-10>
    </USED-LANGUAGES>
  </ADMIN-DATA>
  <AR-PACKAGES>
    <AR-PACKAGE>
      <SHORT-NAME>AUTOSAR_NvM</SHORT-NAME>
      <AR-PACKAGES>
        
        <AR-PACKAGE>
          <SHORT-NAME>SwcBswMappings</SHORT-NAME>
          <ELEMENTS>
            <SWC-BSW-MAPPING>
              <SHORT-NAME>NvM</SHORT-NAME>
              <BSW-BEHAVIOR-REF DEST="BSW-INTERNAL-BEHAVIOR">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior</BSW-BEHAVIOR-REF>
              <RUNNABLE-MAPPINGS>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_EraseNvBlock</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/EraseNvBlock</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_GetDataIndex</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/GetDataIndex</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_GetErrorStatus</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/GetErrorStatus</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_InvalidateNvBlock</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/InvalidateNvBlock</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_ReadBlock</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/ReadBlock</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_ReadPRAMBlock</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/ReadPRAMBlock</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_RestoreBlockDefaults</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/RestoreBlockDefaults</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_RestorePRAMBlockDefaults</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/RestorePRAMBlockDefaults</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_SetBlockProtection</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/SetBlockProtection</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_SetDataIndex</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/SetDataIndex</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_SetRamBlockStatus</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/SetRamBlockStatus</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_WriteBlock</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/WriteBlock</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-CALLED-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/CE_WritePRAMBlock</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/WritePRAMBlock</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
                <SWC-BSW-RUNNABLE-MAPPING>
                  <BSW-ENTITY-REF DEST="BSW-SCHEDULABLE-ENTITY">/AUTOSAR_NvM/BswModuleDescriptions/NvM/BswInternalBehavior/SE_MainFunction</BSW-ENTITY-REF>
                  <SWC-RUNNABLE-REF DEST="RUNNABLE-ENTITY">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager/MainFunction</SWC-RUNNABLE-REF>
                </SWC-BSW-RUNNABLE-MAPPING>
              </RUNNABLE-MAPPINGS>
              <SWC-BEHAVIOR-REF DEST="SWC-INTERNAL-BEHAVIOR">/AUTOSAR_NvM/SwComponentTypes/NvM/NVRAMManager</SWC-BEHAVIOR-REF>
            </SWC-BSW-MAPPING>
          </ELEMENTS>
        </AR-PACKAGE>
        <AR-PACKAGE>
          <SHORT-NAME>BswModuleDescriptions</SHORT-NAME>
          <ELEMENTS>
            <BSW-MODULE-DESCRIPTION>
              <SHORT-NAME>NvM</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">NVRAM Manager</L-4>
              </LONG-NAME>
              <CATEGORY>BSW_MODULE</CATEGORY>
              <MODULE-ID>20</MODULE-ID>
              <PROVIDED-ENTRYS>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_CancelWriteAll</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_EraseNvBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_GetDataIndex</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_GetErrorStatus</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_GetVersionInfo</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Init</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_InvalidateNvBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_MainFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxGetDataIndex</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxGetErrorStatus</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxGetMigrationResult</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxInvalidateNvBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxReadBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxSetDataIndex</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_AuxWriteBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_ClrWriteMonCntrs</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_FirstInitAll</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetActiveService</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetBlockId</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetBlockIdCausingLastDetError</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetMigrationResult</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetNvBlockLength</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetRequestType</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetStatus</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_GetWriteCounter</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_SetWriteAllTrigger</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_ReadAll</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_ReadBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_ReadPRAMBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_RestoreBlockDefaults</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_RestorePRAMBlockDefaults</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_SetBlockLockStatus</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_SetBlockProtection</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_SetDataIndex</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_SetRamBlockStatus</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_ValidateAll</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_WriteAll</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_WriteBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_WritePRAMBlock</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
              </PROVIDED-ENTRYS>
              <OUTGOING-CALLBACKS>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_InitBlockCallbackFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_MultiBlockCallbackFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_MultiBlockStartCallbackFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_ObserverCallbackFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_ReadRamBlockFromNvm</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_SingleBlockCallbackFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_Rb_SingleBlockStartCallbackFunction</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
                <BSW-MODULE-ENTRY-REF-CONDITIONAL>
                  <BSW-MODULE-ENTRY-REF DEST="BSW-MODULE-ENTRY">/AUTOSAR_NvM/BswModuleEntrys/NvM_WriteRamBlockToNvm</BSW-MODULE-ENTRY-REF>
                </BSW-MODULE-ENTRY-REF-CONDITIONAL>
              </OUTGOING-CALLBACKS>
              <BSW-MODULE-DEPENDENCYS>
                <BSW-MODULE-DEPENDENCY>
                  <SHORT-NAME>Det</SHORT-NAME>
                  <TARGET-MODULE-ID>15</TARGET-MODULE-ID>
                </BSW-MODULE-DEPENDENCY>
                <BSW-MODULE-DEPENDENCY>
                  <SHORT-NAME>MemIf</SHORT-NAME>
                  <TARGET-MODULE-ID>22</TARGET-MODULE-ID>
                </BSW-MODULE-DEPENDENCY>
                <BSW-MODULE-DEPENDENCY>
                  <SHORT-NAME>Rte</SHORT-NAME>
                  <TARGET-MODULE-ID>2</TARGET-MODULE-ID>
                </BSW-MODULE-DEPENDENCY>
                <BSW-MODULE-DEPENDENCY>
                  <SHORT-NAME>SchM</SHORT-NAME>
                  <TARGET-MODULE-ID>130</TARGET-MODULE-ID>
                </BSW-MODULE-DEPENDENCY>
              </BSW-MODULE-DEPENDENCYS>
            </BSW-MODULE-DESCRIPTION>
          </ELEMENTS>
        </AR-PACKAGE>
        <AR-PACKAGE>
          <SHORT-NAME>BswModuleEntrys</SHORT-NAME>
          <ELEMENTS>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_CancelWriteAll</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to cancel a running NvM_WriteAll request</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service stops an ongoning multi-block write operation in a non-destructive way. Non-destructive means that the currently ongoing single-block write operation is finished as usual before the loop over all blocks to be written is leaved prematurely. If no multi-block write operation is currently ongoing, invoking NvM_CancelWriteAll is without any effect. The request result of all blocks which are not written as part of the multi-block write operation, due to the invocation of NvM_CancelWriteAll, is set to NVM_REQ_CANCELED except for those blocks which are pending due to a previously queued single block request.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM_CancelWriteAll sets the request result of block #0 to NVM_REQ_CANCELED if the writing of at least one block has been cancelled.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">A configured multiblock callback is invoked even if the WriteAll operation is canceled due to the invocation of NvM_CancelWriteAll.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
              </INTRODUCTION>
              <SERVICE-ID>10</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_EraseNvBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to erase an NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to erase a block in persistent storage. After successful execution of this service, reading this block will fail due to missing NV block data (NVM_REQ_INTEGRITY_FAILED). The request for erasing a block is only put into an NvM-internal queue and the actual erase operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">
                          Erasing is only possible for blocks configured to have
                          <E TYPE="ITALIC">immediate priority</E>
                          (see also NvMBlockJobPriority).
                        </L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_EraseNvBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_EraseNvBlock (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the erase operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the erase operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the erase operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
              </INTRODUCTION>
              <SERVICE-ID>9</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the erase operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_EraseNvBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is not configured to have immediate job priority (as defined by configuration parameter NvMBlockJobPriority).</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is write protected.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is of type NVM_BLOCK_DATASET and its dataset index points to a ROM block instead of an NV block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be erased on the persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_GetDataIndex</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for getting the current dataset index of an NvM block of type NVM_BLOCK_DATASET</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to retrieve which NV block is currently used for the given NvM block. It is only useful for NvM blocks of type NVM_BLOCK_DATASET.</L-2>
              </DESC>
              <SERVICE-ID>2</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the dataset index has been successfully retrieved. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_GetDataIndex returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The DataIndexPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the dataset index shall be retrieved.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>DataIndexPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current dataset index for the block selected by the BlockId parameter.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_GetErrorStatus</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for reading block dependent error/status information</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to retrieve the result of the latest asynchronous block operation. If there is a block operation currently ongoing, NVM_REQ_PENDING is reported.</L-2>
              </DESC>
              <SERVICE-ID>4</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the error/status information has been successfully retrieved. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_GetErrorStatus returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The RequestResultPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                  <P>
                    <L-1 L="EN">If you are absolutely sure that you always provide a valid BlockId and a non-NULL request result pointer when calling this service, you may decide to not check this service's return value.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">
                      This parameter selects the block for which error/status information shall be retrieved. In addition to the IDs of single blocks configured by the NvM user, NvM_GetErrorStatus also allows the BlockId to be set to zero. In this case, the error/status information of the latest
                      <E TYPE="ITALIC">multi-block</E>
                      operation is retrieved.
                    </L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>RequestResultPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current error/status information for the block selected by the BlockId parameter. Please refer to the description of the NvM_RequestResultType for a list of all possible request results and their meaning.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_RequestResultType</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_GetVersionInfo</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for getting version information of the NvM module</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to retrieve version information of the NvM module at runtime. The existence of this service is pre-compile time configurable by the configuration parameter NvMVersionInfoApi.</L-2>
              </DESC>
              <SERVICE-ID>15</SERVICE-ID>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>VersionInfoPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the version information of this module (vendor ID, module ID and software version). Please refer to the description of the Std_VersionInfoType for details.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>STRUCTURE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_VersionInfoType</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Init</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for resetting internal variables</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service resets internal NvM variables. This also includes the clearing of all queues. In case the saved zone is lost (e.g. after a reset), invoking this service sets all request results to NVM_REQ_OK and all RAM block states to unchanged and invalid. Additionally, the write protection states of all blocks are reset to their configured value and their dataset index is reset to zero. In case the saved zone is not lost, invoking this service resets neither RAM block states nor write protection states.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">
                      In contrast to many non-AUTOSAR implementations of persistent storage drivers, this initialization service does
                      <E TYPE="ITALIC">not</E>
                      also read selected blocks from persistent storage. In NvM, this initial reading of blocks is the task of the NvM_ReadAll service, not of NvM_Init.
                    </L-1>
                  </P>
                </NOTE>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">NvM_Init shall not be called by any regular NvM user. This is the task of system control only (in particular EcuM).</L-1>
                  </P>
                </NOTE>
              </INTRODUCTION>
              <SERVICE-ID>0</SERVICE-ID>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_InitBlockCallbackFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Per block callback routine to notify the NvM user that default data is required for a block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM if a RAM block shall be initialized by the NvM user. The actual name of the callback routine is configured by the NvM user via the NvMInitBlockCallback configuration parameter. Inside this callback routine, the NvM user shall fill the corresponding RAM block with initialization data. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">The NvM user shall always return E_OK as the return value of the initialization callback. NvM does not evaluate this return value at all.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_InvalidateNvBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to invalidate an NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to invalidate a block in persistent storage. After successful execution of this service, reading this block will fail due to invalidated NV block data (NVM_REQ_NV_INVALIDATED). The request for invalidating a block is only put into an NvM-internal queue and the actual invalidation operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_InvalidateNvBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_InvalidateNvBlock (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the invalidation operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the invalidation operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the invalidation operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
              </INTRODUCTION>
              <SERVICE-ID>11</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the invalidation operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_InvalidateNvBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is write protected.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is of type NVM_BLOCK_DATASET and its dataset index points to a ROM block instead of an NV block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be invalidated in persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_MainFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for performing the processing of NvM jobs</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service does the actual processing of all asynchronous tasks given to NvM such as reading or writing single or multiple NvM blocks.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">This service shall not be called by any regular NvM user. This is the task of the BSW scheduler.</L-1>
                  </P>
                </NOTE>
              </INTRODUCTION>
              <SERVICE-ID>14</SERVICE-ID>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>SCHEDULED</CALL-TYPE>
              <EXECUTION-CONTEXT>TASK</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_MultiBlockCallbackFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Callback routine to notify the NvM user that an asynchronous multi-block request has been finished</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM once a multi-block operation has finished. The actual name of the callback routine is configured by the NvM user via the NvMMultiBlockCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ServiceId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">With this service parameter, the NvM user is told which kind of service has been finished. The service IDs are uniquely specified for each NvM service, e.g. the multi-block read service (NvM_ReadAll) has the service ID 12.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>JobResult</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">The job result parameter informs the NvM user about the result of the just finished multi-block service. This is the same value which would also be reported by the NvM_GetErrorStatus API.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_RequestResultType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_MultiBlockStartCallbackFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Callback routine to notify the NvM user that an asynchronous multi-block request is starting</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM once a multi-block operation is starting. The actual name of the callback routine is configured by the NvM user via the NvMRbMultiBlockStartCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ServiceId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">With this service parameter, the NvM user is told which kind of service is starting. The service IDs are uniquely specified for each NvM service, e.g. the multi-block read service (NvM_ReadAll) has the service ID 12.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxGetDataIndex</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for getting the current dataset index of an NvM block of type NVM_BLOCK_DATASET</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to retrieve which NV block is currently used for accesses to NvM blocks of type NVM_BLOCK_DATASET carried out by an auxiliary user.</L-2>
              </DESC>
              <SERVICE-ID>243</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the dataset index has been successfully retrieved. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxGetDataIndex returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The DataIndexPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>DataIndexPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current dataset index.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxGetErrorStatus</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for reading block dependent error/status information</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to retrieve the result of the latest asynchronous block operation carried out by an auxiliary user. If there is a block operation currently ongoing, NVM_REQ_PENDING is reported.</L-2>
              </DESC>
              <SERVICE-ID>244</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the error/status information has been successfully retrieved. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxGetErrorStatus returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The RequestResultPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                  <P>
                    <L-1 L="EN">If you are absolutely sure that you always provide a non-NULL request result pointer when calling this service, you may decide to not check this service's return value.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>RequestResultPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current error/status information for the block selected by the most previously triggered auxiliary service. Please refer to the description of the NvM_RequestResultType for a list of all possible request results and their meaning.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_RequestResultType</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxGetMigrationResult</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to read the auxiliary migration result.</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to read the result of the migration for the block used by the most previously triggered auxiliary service.</L-2>
              </DESC>
              <SERVICE-ID>238</SERVICE-ID>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the auxiliary migration result has been successfully read. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxGetMigrationResult returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The MigrationResultPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                  <P>
                    <L-1 L="EN">If you are absolutely sure that you always provide a non-NULL request result pointer when calling this service, you may decide to not check this service's return value.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>MigrationResultPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current migration result for the block used by the most previously triggered auxiliary service. Please refer to the description of the NvM_Rb_MigrationResult_ten for a list of all possible migration results and their meaning.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_MigrationResult_ten</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxInvalidateNvBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to invalidate an NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to invalidate a block in persistent storage. After successful execution of this service, reading this block will fail due to invalidated NV block data (NVM_REQ_NV_INVALIDATED). The request for invalidating a block is only put into an NvM-internal queue and the actual invalidation operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_Rb_AuxGetErrorStatus.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_Rb_AuxInvalidateNvBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_Rb_AuxInvalidateNvBlock (retrieved by a subsequent call of NvM_Rb_AuxGetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the invalidation operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the invalidation operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the invalidation operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
              </INTRODUCTION>
              <SERVICE-ID>245</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the invalidation operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxInvalidateNvBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The dataset index set by NvM_Rb_AuxSetDataIndex is out of range for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is write protected.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is of type NVM_BLOCK_DATASET and the dataset index set by NvM_Rb_AuxSetDataIndex points to a ROM block instead of an NV block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently another operation in progress which is triggered by an auxiliary user.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for auxiliary requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be invalidated in persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxReadBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy the data of a single NV block to a temporary RAM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to read block data from persistent storage into a temporary RAM block. The request for reading a block is only put into an NvM-internal queue and the actual read operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_Rb_AuxGetErrorStatus.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="HINT">
                  <P>
                    <L-1 L="EN">If the NvM block is of type NVM_BLOCK_DATASET and the dataset index points to a ROM block, the "read" operation consists in copying default data from the ROM block to the temporary RAM block.</L-1>
                  </P>
                </NOTE>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_Rb_AuxReadBlock returned, the variable pointed to by NvM_DstPtr will be used internally by NvM until the actual read operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_Rb_AuxReadBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_Rb_AuxReadBlock (retrieved by a subsequent call of NvM_Rb_AuxGetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_REDUNDANCY_FAILED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the redundancy of the current block in has been lost on the persistent media (but the block could still be read successfully). In the current version of NvM, this state can never occur.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_RESTORED_FROM_ROM:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that ROM data has been read for this block instead of NV data if an implicit recovery occurred.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NV_INVALIDATED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation only found an invalidated block on the persistent media instead of an NV block containing "real" data. The temporary RAM block remains untouched in this case.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_INTEGRITY_FAILED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation did not find any valid data for this block on the persistent media.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation failed due to an unexpected event. Typical reasons for this request result are integration or hardware errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">If the request result of this service is NVM_REQ_INTEGRITY_FAILED or NVM_REQ_NOT_OK, then the temporary RAM block's contents may be corrupted. You may want to bring back the temporary RAM block into a consistent state in this case.</L-1>
                  </P>
                </NOTE>
              </INTRODUCTION>
              <SERVICE-ID>246</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the read operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxReadBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The dataset index set by NvM_Rb_AuxSetDataIndex is out of range for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM_DstPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently another operation in progress which is triggered by an auxiliary user.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for auxiliary requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be read from persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvM_DstPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to a temporary RAM block receiving the data read from the corresponding NV block.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_VoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxSetDataIndex</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for setting the dataset index of an NvM block of type NVM_BLOCK_DATASET</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to select the NV block which is to be used for accesses to NvM blocks of type NVM_BLOCK_DATASET carried out by an auxiliary user. It leaves the NV block(s) untouched in any case.</L-2>
              </DESC>
              <SERVICE-ID>247</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the dataset index has been set successfully. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxSetDataIndex returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently another operation in progress which is triggered by an auxiliary user.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>DataIndex</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter defines the new dataset index to be used in subsequent operations triggered by an auxiliary user.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_AuxWriteBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy the data of a temporary RAM block to a single NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to write data from a temporary RAM block into persistent storage. The request for writing a block is only put into an NvM-internal queue and the actual write operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_Rb_AuxGetErrorStatus.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_Rb_AuxWriteBlock returned, the variable pointed to by NvM_SrcPtr will be used internally by NvM until the actual write operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_Rb_AuxWriteBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_Rb_AuxWriteBlock (retrieved by a subsequent call of NvM_Rb_AuxGetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
              </INTRODUCTION>
              <SERVICE-ID>248</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the write operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_AuxWriteBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The dataset index set by NvM_Rb_AuxSetDataIndex is out of range for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM_SrcPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is write protected.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is of type NVM_BLOCK_DATASET and the dataset index set by NvM_Rb_AuxSetDataIndex points to a ROM block instead of an NV block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently another operation in progress which is triggered by an auxiliary user.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for auxiliary requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be written to persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvM_SrcPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to a temporary RAM block holding the data to be written to the corresponding NV block.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_ConstVoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_ClrWriteMonCntrs</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to clear write monitoring counters.</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service clears all write monitoring counters if configured otherwise this service does nothing.</L-2>
              </DESC>
              <SERVICE-ID>235</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if write monitor counters has been cleared successfully.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">This service always returns E_OK.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_FirstInitAll</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to trigger a multi block (re-) initialization operation</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service to trigger a multi block (re-) initialization operation</L-2>
              </DESC>
              <INTRODUCTION>
                <P>
                  <L-1 L="EN">This service triggers the (re-) initialization of an entire range of NvM blocks both on persistent storage and in the corresponding RAM blocks. For a proper initialisation of a native or a redundant NvM block, such a block needs</L-1>
                </P>
                <LIST TYPE="NUMBER">
                  <ITEM>
                    <P>
                      <L-1 L="EN">to have at least one recovery data source (i.e. a ROM block or an InitBlockCallback),</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">to have a permanent RAM block or to be configured to use explicit synchronization mechanism and</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">to be selected for this operation (via configuration parameter NvMRbSelectBlockForFirstInitAll).</L-1>
                    </P>
                  </ITEM>
                </LIST>
                <NOTE NOTE-TYPE="HINT">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">An NvM block, selected for this operation and which has no ROM block and no InitBlockCallback, is simply invalidated by the NvM_Rb_FirstInitAll operation.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">All the NV blocks of an NvM block of type NVM_BLOCK_DATASET, selected for this operation, are simply invalidated by the NvM_Rb_FirstInitAll job.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">NvM_Rb_FirstInitAll shall not be called by any regular NvM user. This is the task of a special first initialization control instance.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">First initialization consists of the following actions per block:</L-1>
                </P>
                <LIST TYPE="UNNUMBER">
                  <ITEM>
                    <P>
                      <L-1 L="EN">
                        <E TYPE="BOLD">If</E>
                        a ROM block or an InitBlockCallback has been configured for the corresponding native or redundant block, a restore job is performed, immediately followed by a write job. After successful execution, both the RAM block and the NV block are initialized with default data and the NvM block itself is internally marked as valid and unchanged.
                      </L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">
                        <E TYPE="BOLD">Otherwise</E>
                        , an invalidation job is performed on this block, leaving the RAM block including its internal status untouched and the NV block in an "intentionally marked as invalid" state.
                      </L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">If a block is of type NvM_BLOCK_DATASET, all its NV blocks are invalidated. The invalidation job is performed on this block, leaving the RAM block including its internal status untouched and the NV blocks in an "intentionally marked as invalid" state.</L-1>
                    </P>
                  </ITEM>
                </LIST>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">The write protection status of a block is ignored during the execution of this service.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The request for (re-) initializing multiple blocks is only put into an NvM-internal queue and the actual initialization operations are then carried out asynchronously. The NvM user can poll the overall result of this operation via NvM_GetErrorStatus (providing 0 for the block ID) or can be informed by a callback function upon completion (see NvM_MultiBlockCallbackFunction). Additionally, the status information of all participating blocks is maintained and all configured callbacks for these blocks are invoked just as in the case of single-block requests. The order of single-block operations during NvM_Rb_FirstInitAll is dictated by the block IDs (ascending order).</L-1>
                </P>
                <P>
                  <L-1 L="EN">The following multi-block request results from NvM_Rb_FirstInitAll (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that all single-block operations carried out during the multi-block first initialization operation were successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the multi-block first initialization operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that at least one single-block operation carried out during the multi-block first initialization operation failed due to an unexpected event. Typical reasons for this event are integration or hardware errors or explicit synchronization callbacks which failed after too many retries (see also the configuration parameter NvMRepeatMirrorOperations).</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">A block which is not participating in the multi-block read operation gets the request result NVM_REQ_BLOCK_SKIPPED assigned in its single-block status if it is not already pending due to a previously queued single block request. The RAM status (changed/unchanged, valid/invalid) of skipped blocks remains untouched.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>251</SERVICE-ID>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetActiveService</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to read the ID of the currently active service of the NVRAM manager</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This overall status is maintained within the NvM_MainFunction, so it does not take any asynchronous single block or multi block request into consideration before this has been arbitrated by the NvM_MainFunction. This service is mainly intended to be called within the InitBlockCallback.</L-2>
              </DESC>
              <SERVICE-ID>252</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the active NvM service was retrieved successfully. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_GetActiveService returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">The ServiceIdPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ServiceIdPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the currently active NvM service.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetBlockId</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for getting the NvM block ID using the persistent ID input parameter</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service for getting the NvM block ID using the persistent ID input parameter</L-2>
              </DESC>
              <SERVICE-ID>250</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the block ID was retrieved successfully from the corresponding NvM block desriptor. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_GetBlockId returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">No block with the given PersistentId has been configured.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockIdPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>PersistentId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter is the persistent ID of the NvM block for which the ID is to be retrieved.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint16</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockIdPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the ID of the NvM block whose persistent ID is equal to the value of the PersistentId passed parameter.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetBlockIdCausingLastDetError</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to get the block ID used in NvM service which has caused the last DET error</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service to get the block ID used in NvM service which has caused the last DET error</L-2>
              </DESC>
              <SERVICE-ID>236</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">Block identifier used in NvM service which has caused the last DET error</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Typical use case for this function is to be used as callback within the DET.
                      If NvM service which has caused the last DET error does not use any block
                      or no DET error has occured yet, then this function returns 0.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetMigrationResult</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to read the result of the migration operation</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to read the result of the migration for the block.</L-2>
              </DESC>
              <SERVICE-ID>239</SERVICE-ID>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the migration result has been successfully read. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_GetMigrationResult returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The MigrationResultPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                  <P>
                    <L-1 L="EN">If you are absolutely sure that you always provide a non-NULL request result pointer when calling this service, you may decide to not check this service's return value.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the migration result shall be read.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>MigrationResultPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current migration result for the block used by the most previously triggered auxiliary service. Please refer to the description of the NvM_Rb_MigrationResult_ten for a list of all possible migration results and their meaning.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_MigrationResult_ten</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetNvBlockLength</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for getting the configured NV block length in bytes of an NvM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service for getting the configured NV block length in bytes of an NvM block</L-2>
              </DESC>
              <SERVICE-ID>253</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the NV block length was retrieved successfully from the corresponding NvM block desriptor. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_GetNvBlockLength returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvBlockLengthPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the NV block length is to be retrieved.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvBlockLengthPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the NV block length for the block selected by the BlockId parameter.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint16</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetRequestType</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for reading the  type of the currently active service</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service for reading the  type of the currently active service</L-2>
              </DESC>
              <SERVICE-ID>237</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">Type of the currently active block request.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Typical use case for this function is to get the type of the block request for which a callback function has been called. So it is appropriate to call this function only in a callback.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_RequestType_ten</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetStatus</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for reading the overall status of NvM</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service for reading the overall status of NvM</L-2>
              </DESC>
              <SERVICE-ID>255</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the overall status information has been successfully retrieved. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_GetStatus returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">The StatusPtr parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                  <P>
                    <L-1 L="EN">If you are absolutely sure that you always provide a non-NULL status variable pointer when calling this service, you may decide to not check this service's return value.</L-1>
                  </P>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>StatusPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the overall status of the NvM. Please refer to the description of NvM_Rb_StatusType for a list of all possible values and their meaning.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_StatusType</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_GetWriteCounter</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to get the write counter for a NVRAM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service to get the write counter for a NVRAM block</L-2>
              </DESC>
              <SERVICE-ID>230</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the block specific write counter has been read successfully. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_GetStatus returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The cntrWrite_puo parameter is a NULL pointer.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">Write counter not configured.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the write counter shall be retrieved.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>cntrWrite_puo</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to the user variable which shall receive the current write counter for the block selected by the BlockId parameter.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                        <SW-POINTER-TARGET-PROPS>
                          <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                          <SW-DATA-DEF-PROPS>
                            <SW-DATA-DEF-PROPS-VARIANTS>
                              <SW-DATA-DEF-PROPS-CONDITIONAL>
                                <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint32</IMPLEMENTATION-DATA-TYPE-REF>
                                <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                              </SW-DATA-DEF-PROPS-CONDITIONAL>
                            </SW-DATA-DEF-PROPS-VARIANTS>
                          </SW-DATA-DEF-PROPS>
                        </SW-POINTER-TARGET-PROPS>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_ObserverCallbackFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Callback routine to notify an NvM observer that the processing of a job for a block within an asynchronous request has been finished</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM once a single block asynchronous operation or the processing of a block within an asynchronous multi-block operation has finished. The actual name of the callback routine is configured by an NvM observer via the common NvMRbObserverCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">The NvM observer returns E_OK if the callback is successful. Otherwise, E_NOT_OK shall be returned. NvM does not evaluate this return value.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the job result is to be delivered via the JobResult passed parameter.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ServiceId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">With this service parameter, the NvM observer is told which service has finished the processing of the block identified by the BlockId passed parameter. The service IDs are uniquely specified for each NvM service, e.g. the single-block read service (NvM_ReadBlock) has the service ID 6.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>JobResult</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">The job result parameter informs the NvM observer about the result of the just finished job operated on a block (identified by the BlockId passed parameter) within an asynchronous request. This is the same value which would also be reported by the NvM_GetErrorStatus API.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_RequestResultType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_SetWriteAllTrigger</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Alternative service for triggering a multi-block write operation</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service is an alternative service to NvM_SetRamBlockStatus. This API allows the NvM user to trigger a multi-block write operation without caring about the RAM block state or whether another operation on the same block is still in progress.</L-2>
              </DESC>
              <SERVICE-ID>241</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the trigger of the multi-block write has been accepted by NvM. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_Rb_SetWriteAllTrigger returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The service has been called for an NvM block which has no permanent RAM block assigned via configuration.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the WriteAll trigger shall be set.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>WriteAllTrigger</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter sets or resets the WriteAll trigger. TRUE means that the NvM_WriteAll shall be triggered for the selected blockId, FALSE means that this trigger shall not be set (but alternative triggers such as a VALID/CHANGED RAM block state are not reset).</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/boolean</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_ReadAll</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to trigger a multi-block read operation</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service triggers the reading of an entire range of NvM blocks from persistent storage to the corresponding RAM blocks. Only blocks which have a permanent RAM block (or which are configured to use explicit synchronization mechanism), are selected for this operation (via configuration parameter NvMSelectBlockForReadAll) and whose RAM status bits indicate that the RAM block is VALID (see also the "RAM block states" figure) participate in multi-block reads. NvM_ReadAll is typically only called during the startup phase of an ECU.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">NvM_ReadAll shall not be called by any regular NvM user. This is the task of system control only.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The request for reading multiple blocks is only put into an NvM-internal queue and the actual read operations are then carried out asynchronously. The NvM user can poll the overall result of this operation via NvM_GetErrorStatus (providing 0 for the block ID) or can be informed by a callback function upon completion (see NvM_MultiBlockCallbackFunction). Additionally, the status information of all participating blocks is maintained and all configured callbacks for these blocks are invoked just as in the case of single-block read requests. The order of single-block reads during NvM_ReadAll is dictated by the block IDs (ascending order).</L-1>
                </P>
                <P>
                  <L-1 L="EN">The following multi-block request results from NvM_ReadAll (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that all single-block read operations participating in the multi-block read operation were successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the multi-block read operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that at least one single-block read operation participating in the multi-block read operation was not entirely successful (e.g. due to the invalidation of one participating block).</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">If the dynamic configuration feature is enabled (configuration parameter NvMDynamicConfiguration), the following special read behaviour is activated:</L-1>
                </P>
                <LIST TYPE="NUMBER">
                  <ITEM>
                    <P>
                      <L-1 L="EN">NvM_ReadAll starts with reading the block with the reserved block ID 1 (named NvM_ConfigId).</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">If the data contents of this block matches the ID configured in configuration parameter NvMCompiledConfigId, the multi-block read operation continues regularly.</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">If a mismatch has been detected, only blocks configured as being resistant to changed software (configuration parameter NvMResistantToChangedSw set to true) will participate in the multi-block read operation. Blocks not configured as being resistant will be skipped.</L-1>
                    </P>
                  </ITEM>
                </LIST>
                <P>
                  <L-1 L="EN">A block which is not participating in the multi-block read operation gets the request result NVM_REQ_BLOCK_SKIPPED assigned in its single-block status if it is not already pending due to a previously queued single block request. This is independent of the reason why the block did not participate in the multi-block read operation (no permanent RAM block or no explicit synchronization, not selected for ReadAll, not resistant to changed software in case the configuration ID did not match). The RAM block contents and RAM status (changed/unchanged, valid/invalid) of skipped blocks remain untouched.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>12</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_ReadBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy the data of a single NV block to its corresponding RAM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to read block data from persistent storage into RAM. The request for reading a block is only put into an NvM-internal queue and the actual read operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="HINT">
                  <P>
                    <L-1 L="EN">If the NvM block is of type NVM_BLOCK_DATASET and the dataset index points to a ROM block, the "read" operation consists in copying default data from the ROM block to the RAM block. Additionally, if this NvM block has an InitBlockCallback configured, this callback is also called.</L-1>
                  </P>
                </NOTE>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_ReadBlock returned, the variable pointed to by NvM_DstPtr will be used internally by NvM until the actual read operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_ReadBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_ReadBlock (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_REDUNDANCY_FAILED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the redundancy of the current block in has been lost on the persistent media (but the block could still be read successfully). In the current version of NvM, this state can never occur.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_RESTORED_FROM_ROM:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that ROM data has been read for this block instead of NV data if an implicit recovery occurred.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NV_INVALIDATED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation only found an invalidated block on the persistent media instead of an NV block containing "real" data. The RAM block remains untouched in this case.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_INTEGRITY_FAILED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation did not find any valid data for this block on the persistent media.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation failed due to an unexpected event. Typical reasons for this request result are integration or hardware errors or explicit synchronization read callbacks which failed after too many retries (see also the configuration parameter NvMRepeatMirrorOperations).</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">If the request result of this service is NVM_REQ_INTEGRITY_FAILED or NVM_REQ_NOT_OK, then the RAM block's contents may be corrupted. You may want to bring back the RAM block into a consistent state in this case.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">If the permanent RAM block is defined as the destination of the read operation, then the internal block status is set to invalid as soon as the read request has been successfully enqueued. If the read operation to the permanent RAM block was successful, the internal block status is set to unchanged and valid upon completion.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>6</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the read operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_ReadBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM_DstPtr parameter is a NULL pointer and there is also no permanent RAM block configured for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be read from persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvM_DstPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to a temporary RAM block receiving the data read from the corresponding NV block. If this parameter is set to a NULL pointer, the permanent RAM block of the NvM block selected by the BlockId parameter is used as the data destination.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_VoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_ReadPRAMBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy the data of a single NV block to its corresponding permanent RAM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to read block data from persistent storage into the configured permanent RAM block. The request for reading a block is only put into an NvM-internal queue and the actual read operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="HINT">
                  <P>
                    <L-1 L="EN">If the NvM block is of type NVM_BLOCK_DATASET and the dataset index points to a ROM block, the "read" operation consists in copying default data from the ROM block to the RAM block. Additionally, if this NvM block has an InitBlockCallback configured, this callback is also called.</L-1>
                  </P>
                </NOTE>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_ReadPRAMBlock returned, the configured permanent RAM block will be used internally by NvM until the actual read operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_ReadPRAMBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_ReadPRAMBlock (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation from persistent storage into the configured permanent RAM block was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation from persistent storage into the configured permanent RAM block is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_REDUNDANCY_FAILED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the redundancy of the current block has been lost on the persistent media (but the block could still be read successfully). In the current version of NvM, this state can never occur.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_RESTORED_FROM_ROM:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that ROM data has been read into the configured permanent RAM block for this block instead of NV data if an implicit recovery occurred.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NV_INVALIDATED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation only found an invalidated block on the persistent media instead of an NV block containing "real" data. The configured permanent RAM block remains untouched in this case.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_INTEGRITY_FAILED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation did not find any valid data for this block on the persistent media.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the read operation failed due to an unexpected event. Typical reasons for this request result are integration or hardware errors or explicit synchronization read callbacks which failed after too many retries (see also the configuration parameter NvMRepeatMirrorOperations).</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">If the request result of this service is NVM_REQ_INTEGRITY_FAILED or NVM_REQ_NOT_OK, then contents of the configured permanent RAM block may be corrupted. You may want to bring back the configured permanent RAM block into a consistent state in this case.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The internal block status of the configured permanent RAM block is set to invalid as soon as the read request has been successfully enqueued. If the read operation to the permanent RAM block was successful, the internal block status is set to unchanged and valid upon completion.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>22</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the read operation from persistent storage into the configured permanent RAM block has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_ReadPRAMBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter has no configured permanent RAM block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be read from persistent storage into the configured permanent RAM block.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_ReadRamBlockFromNvm</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Read callback routine for an NvM block configured with explicit synchronization.</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM once the actual read job on Fee or Ea finished (for a read request) or once default data has been copied from ROM to NvM mirror (for a restore request or during implicit recovery). This notifies the NvM user that data copy from NvM mirror to user RAM is required. The actual name of the callback routine is configured by the NvM user via the NvMReadRamBlockFromNvCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">The NvM user returns E_OK if the callback is successful. Otherwise, E_NOT_OK shall be returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvMBuffer</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">The address of the NvM mirror from which data shall be copied.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_VoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_RestoreBlockDefaults</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy default data to a RAM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">
                  This service allows the NvM user to read block data from a source of default values defined in NvM's block configuration into RAM. The source of the default values can be a fixed block in ROM or can be asked from the NvM user at runtime via a dedicated callback routine. Both options can be specified in the corresponding block's configuration. Fixed ROM values are defined by the configuration parameter NvMRomBlockDataAddress. An initialization callback is defined by the configuration parameter NvMInitBlockCallback. If both default sources are configured, initialization with ROM block data is executed by NvM
                  <E TYPE="ITALIC">before</E>
                  the initialization callback is invoked.
                </L-2>
              </DESC>
              <INTRODUCTION>
                <P>
                  <L-1 L="EN">The request for restoring block defaults is only put into an NvM-internal queue and the actual restore operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-1>
                </P>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_RestoreBlockDefaults returned, the variable pointed to by NvM_DstPtr will be used internally by NvM until the actual restore operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_RestoreBlockDefaults will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <NOTE NOTE-TYPE="HINT">
                  <P>
                    <L-1 L="EN">If a DATASET block has only an InitBlockCallback (i.e. no ROM block) configured, the NvM_RestoreBlockDefaults request is accepted.</L-1>
                  </P>
                  <P>
                    <L-1 L="EN">
                      If a DATASET block has at least one ROM block, the NvM_RestoreBlockDefaults request is accepted
                      <E TYPE="BOLD">only if</E>
                      the dataset index points to a ROM block regardless whether the block has an InitBlockCallback or not.
                    </L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_RestoreBlockDefaults (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the restore operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the restore operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the restore operation failed due to an unexpected event. Typical reason for this request result is an explicit synchronization read callback which failed after too many retries (see also the configuration parameter NvMRepeatMirrorOperations).</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">If the permanent RAM block is defined as the destination of the restore operation, then the internal block status is set to invalid as soon as the restore request has been successfully enqueued. If the restore operation to the permanent RAM block was also successful in this case, the internal block status is set to changed and valid upon completion.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>8</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the restore operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_RestoreBlockDefaults returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM_DstPtr parameter is a NULL pointer and there is also no permanent RAM block configured for the NvM block selected by the BlockId parameter (only applicable in case of a fixed ROM block as the source of default data).</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">Neither a fixed ROM block nor an initialization callback is configured for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be restored with default values.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvM_DstPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to a temporary RAM block receiving the data restored from the configured source of default data. If this parameter is set to a NULL pointer, the permanent RAM block of the NvM block selected by the BlockId parameter is used as the data destination.</L-2>
                  </DESC>
                  <CATEGORY>DATA_REFERENCE</CATEGORY>
                  <DIRECTION>OUT</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_VoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_RestorePRAMBlockDefaults</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy default data to the configured permanent RAM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">
                  This service allows the NvM user to read block data from a source of default values defined in NvM's block configuration into the configured permanent RAM block. The source of the default values can be a fixed block in ROM or can be asked from the NvM user at runtime via a dedicated callback routine. Both options can be specified in the corresponding block's configuration. Fixed ROM values are defined by the configuration parameter NvMRomBlockDataAddress. An initialization callback is defined by the configuration parameter NvMInitBlockCallback. If both default sources are configured, initialization with ROM block data is executed by NvM
                  <E TYPE="ITALIC">before</E>
                  the initialization callback is invoked.
                </L-2>
              </DESC>
              <INTRODUCTION>
                <P>
                  <L-1 L="EN">The request for restoring block defaults is only put into an NvM-internal queue and the actual restore operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-1>
                </P>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_RestorePRAMBlockDefaults will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <NOTE NOTE-TYPE="HINT">
                  <P>
                    <L-1 L="EN">If a DATASET block has only an InitBlockCallback (i.e. no ROM block) configured, the NvM_RestorePRAMBlockDefaults request is accepted.</L-1>
                  </P>
                  <P>
                    <L-1 L="EN">
                      If a DATASET block has at least one ROM block, the NvM_RestorePRAMBlockDefaults request is accepted
                      <E TYPE="BOLD">only if</E>
                      the dataset index points to a ROM block regardless whether the block has an InitBlockCallback or not.
                    </L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_RestorePRAMBlockDefaults (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the restore operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the restore operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the restore operation failed due to an unexpected event. Typical reason for this request result is an explicit synchronization read callback which failed after too many retries (see also the configuration parameter NvMRepeatMirrorOperations).</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">The internal block status of the configured permanent RAM block is set to invalid as soon as the restore request has been successfully enqueued. If the restore operation to the permanent RAM block was also successful in this case, the internal block status is set to changed and valid upon completion.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>24</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the restore operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_RestoreBlockDefaults returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter has no configured permanent RAM block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">Neither a fixed ROM block nor an initialization callback is configured for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be restored with default values.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_SetBlockLockStatus</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for locking/unlocking an NvM block with respect to any operation that could change the NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to completely lock an NvM block against any modification of its persistent part. This is very similar to write protection (see NvM_SetBlockProtection) but is not intended for regular NvM users.</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="HINT">
                  <P>
                    <L-1 L="EN">Since the current version of NvM does not support block locking yet, this service is only there for API completeness.</L-1>
                  </P>
                </NOTE>
              </INTRODUCTION>
              <SERVICE-ID>19</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be locked or unlocked.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockLocked</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter defines whether the block selected by the BlockId parameter shall be locked (TRUE) or unlocked (FALSE).</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/boolean</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_SetBlockProtection</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for enabling/disabling write protection for an NvM block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to control an NvM block's write protection state. If an NvM block is write protected, all operations which would alter the persistent part of this NvM block are rejected.</L-2>
              </DESC>
              <SERVICE-ID>3</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the write protection state has been successfully set to the state given by the ProtectionEnabled parameter. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_SetBlockProtection returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The selected block has been configured to be writable only once (via configuration parameter NvMWriteBlockOnce).</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the write protection state shall be set.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ProtectionEnabled</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter defines whether write protection shall be enabled (TRUE) or disabled (FALSE) for the block selected by the BlockId parameter.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/boolean</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_SetDataIndex</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for setting the dataset index of an NvM block of type NVM_BLOCK_DATASET</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to select the NV block which is to be used for the given NvM block. It is only useful for NvM blocks of type NVM_BLOCK_DATASET. It leaves both the NV block(s) and RAM block untouched in any case.</L-2>
              </DESC>
              <SERVICE-ID>1</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the dataset index has been set successfully. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_SetDataIndex returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The DataIndex parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The service has been called for an NvM block of a type different from NVM_BLOCK_DATASET.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the dataset index shall be set.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>DataIndex</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter defines the new dataset index for the block selected by the BlockId parameter.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_SetRamBlockStatus</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service for setting the RAM block status of an NvM block to changed or unchanged</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to set the changed/unchanged state of a RAM block. Only blocks which have this state set to changed will be written as part of multi-block write operations. It is assumed that a changed RAM block is also valid.</L-2>
              </DESC>
              <SERVICE-ID>5</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the RAM block status has been set successfully. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_SetRamBlockStatus returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The service has been called for an NvM block which has no permanent RAM block assigned via configuration.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block for which the RAM block changed/unchanged state shall be set.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockChanged</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter defines the new RAM block status for the block selected by the BlockId parameter. TRUE means that the RAM block has been changed, FALSE means that it is unchanged.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/boolean</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_SingleBlockCallbackFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Per block callback routine to notify the NvM user that the processing of the job for this block within an asynchronous request has been finished</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM once a single block asynchronous operation or the processing of a block within an asynchronous multi-block operation has finished. The actual name of the callback routine is configured by the NvM user via the NvMSingleBlockCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">The NvM user shall always return E_OK as the return value of the single-block callback. NvM does not evaluate this return value at all.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ServiceId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">With this service parameter, the NvM user is told which kind of service has been finished. The service IDs are uniquely specified for each NvM service, e.g. the single-block read service (NvM_ReadBlock) has the service ID 6.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>JobResult</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">The job result parameter informs the NvM user about the result of the just finished job operated on this block within an asynchronous request. This is the same value which would also be reported by the NvM_GetErrorStatus API.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_RequestResultType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_Rb_SingleBlockStartCallbackFunction</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Per block callback routine to notify the NvM user that the processing of the job for this block within an asynchronous request has been started</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM once a single block asynchronous operation or the processing of a block within an asynchronous multi-block operation has started. The actual name of the callback routine is configured by the NvM user via the NvMRbSingleBlockStartCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">The NvM user shall always return E_OK as the return value of the single-block callback. NvM does not evaluate this return value at all.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>ServiceId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">With this service parameter, the NvM user is told which kind of service has been finished. The service IDs are uniquely specified for each NvM service, e.g. the single-block read service (NvM_ReadBlock) has the service ID 6.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_ValidateAll</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to trigger a multi-block validation operation</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service to trigger a multi-block validation operation</L-2>
              </DESC>
              <INTRODUCTION>
                <P>
                  <L-1 L="EN">This service triggers the setting of the RAM block state of an entire range of NvM blocks to VALID/CHANGED. Only blocks which</L-1>
                </P>
                <LIST TYPE="NUMBER">
                  <ITEM>
                    <P>
                      <L-1 L="EN">have a permanent RAM block or are configured to use explicit synchronization mechanism</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">are selected for this operation (via configuration parameter NvMBlockUseAutoValidation)</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">are internally marked as valid (which is not the case after initial NvM initialization)</L-1>
                    </P>
                  </ITEM>
                </LIST>
                <P>
                  <L-1 L="EN">participate in this multi-block operation.</L-1>
                </P>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">NvM_ValidateAll shall not be called by any regular NvM user. This is the task of system control only.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The request for validating multiple blocks is only put into an NvM-internal queue and the actual validation operations are then carried out asynchronously. The NvM user can poll the overall result of this operation via NvM_GetErrorStatus (providing 0 for the block ID) or can be informed by a callback function upon completion (see NvM_MultiBlockCallbackFunction). Additionally, the status information of all participating blocks is maintained and all configured callbacks for these blocks are invoked just as in the case of e.g. single-block write requests. The order of single-block validations during NvM_ValidateAll is dictated by the block IDs (ascending order).</L-1>
                </P>
                <P>
                  <L-1 L="EN">The following multi-block request results from NvM_ValidateAll (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the entire multi-block validation operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the multi-block validation operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">The contents of permanent RAM blocks are untouched by NvM_ValidateAll in any case.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>25</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_WriteAll</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to trigger a multi-block write operation</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Service to trigger a multi-block write operation</L-2>
              </DESC>
              <INTRODUCTION>
                <P>
                  <L-1 L="EN">This service triggers the writing of an entire range of NvM blocks to persistent storage from the corresponding RAM blocks. Only blocks which</L-1>
                </P>
                <LIST TYPE="NUMBER">
                  <ITEM>
                    <P>
                      <L-1 L="EN">have a permanent RAM block or are configured to use explicit synchronization mechanism</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">are selected for this operation (via configuration parameter NvMSelectBlockForWriteAll)</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">are not write protected and</L-1>
                    </P>
                  </ITEM>
                  <ITEM>
                    <P>
                      <L-1 L="EN">are internally marked as changed and valid (see also NvM_SetRamBlockStatus)</L-1>
                    </P>
                  </ITEM>
                </LIST>
                <P>
                  <L-1 L="EN">participate in multi-block writes. NvM_WriteAll is typically only called during the shutdown phase of an ECU.</L-1>
                </P>
                <NOTE NOTE-TYPE="CAUTION">
                  <P>
                    <L-1 L="EN">NvM_WriteAll shall not be called by any regular NvM user. This is the task of system control only.</L-1>
                  </P>
                </NOTE>
                <P>
                  <L-1 L="EN">The request for writing multiple blocks is only put into an NvM-internal queue and the actual write operations are then carried out asynchronously. The NvM user can poll the overall result of this operation via NvM_GetErrorStatus (providing 0 for the block ID) or can be informed by a callback function upon completion (see NvM_MultiBlockCallbackFunction). Additionally, the status information of all participating blocks is maintained and all configured callbacks for these blocks are invoked just as in the case of single-block write requests. The order of single-block writes during NvM_WriteAll is dictated by the block IDs (ascending order).</L-1>
                </P>
                <P>
                  <L-1 L="EN">The following multi-block request results from NvM_WriteAll (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that all single-block write operations participating in the multi-block write operation were successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the multi-block write operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that at least one single-block write operation participating in the multi-block write operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_CANCELED:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that NvM_CancelWriteAll was invoked in order to cancel the processing of the pending WriteAll operation.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">A block which is not participating in the multi-block write operation gets the request result NVM_REQ_BLOCK_SKIPPED assigned in its single-block status if it is not already pending due to a previously queued single block request. This is independent of the reason why the block did not participate in the multi-block write operation. The RAM status (changed/unchanged, valid/invalid) of skipped blocks remains untouched. The contents of permanent RAM blocks are untouched by NvM_WriteAll in any case.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>13</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_WriteBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy the data of a single RAM block to its corresponding NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to write block data from RAM into persistent storage. The request for writing a block is only put into an NvM-internal queue and the actual write operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_WriteBlock returned, the variable pointed to by NvM_SrcPtr will be used internally by NvM until the actual write operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_WriteBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_WriteBlock (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">If the permanent RAM block is defined as the source of the write operation, then the internal block status is set to valid as soon as the write request has been successfully enqueued. If the write operation to the permanent RAM block was successful, the internal block status is set to unchanged upon completion.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>7</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the write operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_WriteBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM_SrcPtr parameter is a NULL pointer and there is also no permanent RAM block configured for the NvM block selected by the BlockId parameter.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is write protected.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is of type NVM_BLOCK_DATASET and its dataset index points to a ROM block instead of an NV block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The standard or the immediate queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be written to persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvM_SrcPtr</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter points to a temporary RAM block holding the data to be written to the corresponding NV block. If this parameter is set to a NULL pointer, the permanent RAM block of the NvM block selected by the BlockId parameter is used as the data source.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_ConstVoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_WritePRAMBlock</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Service to copy the data of the permanent RAM block to its corresponding NV block</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">This service allows the NvM user to write block data from the configured permanent RAM block into persistent storage. The request for writing a block is only put into an NvM-internal queue and the actual write operation is then carried out asynchronously. The NvM user can poll the request result of this operation via NvM_GetErrorStatus or can be informed by a callback function upon completion (see NvM_SingleBlockCallbackFunction).</L-2>
              </DESC>
              <INTRODUCTION>
                <NOTE NOTE-TYPE="CAUTION">
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">Even after NvM_WritePRAMBlock returned, the configured permanent RAM block will be used internally by NvM until the actual write operation is finished. This is due to the asynchronous nature of this service.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">If enhanced dynamic configuration is enabled and the current block is selected for ReadAll and is not resistant to changed software then the request NvM_WritePRAMBlock will be not accepted by NvM as long as NvM_ReadAll has not been initiated.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </NOTE>
                <P>
                  <L-1 L="EN">The following request results (not return values!) from NvM_WritePRAMBlock (retrieved by a subsequent call of NvM_GetErrorStatus) are possible:</L-1>
                </P>
                <LABELED-LIST>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation was successful.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_PENDING:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation is still ongoing.</L-1>
                    </P>
                  </LABELED-ITEM>
                  <LABELED-ITEM>
                    <ITEM-LABEL>
                      <L-2 L="EN">NVM_REQ_NOT_OK:</L-2>
                    </ITEM-LABEL>
                    <P>
                      <L-1 L="EN">Indicates that the write operation failed due to an unexpected event. This is typically (but not always) due to integration errors.</L-1>
                    </P>
                  </LABELED-ITEM>
                </LABELED-LIST>
                <P>
                  <L-1 L="EN">The internal status of the configured permanent RAM block is set to valid as soon as the write request has been successfully enqueued. If the write operation to the permanent RAM block was successful, the internal block status is set to unchanged upon completion.</L-1>
                </P>
              </INTRODUCTION>
              <SERVICE-ID>23</SERVICE-ID>
              <IS-REENTRANT>true</IS-REENTRANT>
              <IS-SYNCHRONOUS>false</IS-SYNCHRONOUS>
              <CALL-TYPE>REGULAR</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">E_OK is returned if the write operation has been successfully triggered. Otherwise, E_NOT_OK is returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <INTRODUCTION>
                  <P>
                    <L-1 L="EN">Possible reasons for NvM_WritePRAMBlock returning E_NOT_OK are:</L-1>
                  </P>
                  <LIST TYPE="UNNUMBER">
                    <ITEM>
                      <P>
                        <L-1 L="EN">NvM is not yet initialized.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The BlockId parameter is out of range.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter has no configured permanent RAM block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is write protected.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The NvM block selected by the BlockId parameter is of type NVM_BLOCK_DATASET and its dataset index points to a ROM block instead of an NV block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">There is currently a single-block or multi-block operation in progress on the selected block.</L-1>
                      </P>
                    </ITEM>
                    <ITEM>
                      <P>
                        <L-1 L="EN">The standard or the immediate queue for single-block requests is full.</L-1>
                      </P>
                    </ITEM>
                  </LIST>
                </INTRODUCTION>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>BlockId</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">This parameter selects the block which shall be written to persistent storage.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_BlockIdType</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
            <BSW-MODULE-ENTRY>
              <SHORT-NAME>NvM_WriteRamBlockToNvm</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Write callback routine for an NvM block configured with explicit synchronization.</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">A callback routine with this signature (but typically not with the same name) is called by NvM before starting the actual write job on Fee or Ea. This notifies the NvM user that data copy from user RAM to NvM mirror is required. The actual name of the callback routine is configured by the NvM user via the NvMWriteRamBlockToNvCallback configuration parameter. It is not allowed to call any NvM or DEM functions from within this callback function!</L-2>
              </DESC>
              <IS-REENTRANT>false</IS-REENTRANT>
              <IS-SYNCHRONOUS>true</IS-SYNCHRONOUS>
              <CALL-TYPE>CALLBACK</CALL-TYPE>
              <EXECUTION-CONTEXT>UNSPECIFIED</EXECUTION-CONTEXT>
              <SW-SERVICE-IMPL-POLICY>STANDARD</SW-SERVICE-IMPL-POLICY>
              <RETURN-TYPE>
                <SHORT-NAME>ReturnValue</SHORT-NAME>
                <DESC>
                  <L-2 L="EN">The NvM user returns E_OK if the callback is successful. Otherwise, E_NOT_OK shall be returned.</L-2>
                </DESC>
                <CATEGORY>TYPE_REFERENCE</CATEGORY>
                <DIRECTION>OUT</DIRECTION>
                <SW-DATA-DEF-PROPS>
                  <SW-DATA-DEF-PROPS-VARIANTS>
                    <SW-DATA-DEF-PROPS-CONDITIONAL>
                      <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Std/ImplementationDataTypes/Std_ReturnType</IMPLEMENTATION-DATA-TYPE-REF>
                      <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    </SW-DATA-DEF-PROPS-CONDITIONAL>
                  </SW-DATA-DEF-PROPS-VARIANTS>
                </SW-DATA-DEF-PROPS>
              </RETURN-TYPE>
              <ARGUMENTS>
                <SW-SERVICE-ARG>
                  <SHORT-NAME>NvMBuffer</SHORT-NAME>
                  <DESC>
                    <L-2 L="EN">The address of the NvM mirror to which user data shall be written.</L-2>
                  </DESC>
                  <CATEGORY>TYPE_REFERENCE</CATEGORY>
                  <DIRECTION>IN</DIRECTION>
                  <SW-DATA-DEF-PROPS>
                    <SW-DATA-DEF-PROPS-VARIANTS>
                      <SW-DATA-DEF-PROPS-CONDITIONAL>
                        <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_NvM/ImplementationDataTypes/NvM_Rb_ConstVoidPtr</IMPLEMENTATION-DATA-TYPE-REF>
                        <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                      </SW-DATA-DEF-PROPS-CONDITIONAL>
                    </SW-DATA-DEF-PROPS-VARIANTS>
                  </SW-DATA-DEF-PROPS>
                </SW-SERVICE-ARG>
              </ARGUMENTS>
            </BSW-MODULE-ENTRY>
          </ELEMENTS>
        </AR-PACKAGE>
        <AR-PACKAGE>
          <SHORT-NAME>ImplementationDataTypes</SHORT-NAME>
          <ELEMENTS>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_BlockIdType</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Type used for identifying an NvM block in NvM's service functions</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">NvM reserves the values 0 and 1 for its own internal use. All other values in the uint16 range can be used for user blocks (but there shall not be any gap in the sequence of block IDs).</L-2>
              </DESC>
              <CATEGORY>TYPE_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint16</IMPLEMENTATION-DATA-TYPE-REF>
                    <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
            </IMPLEMENTATION-DATA-TYPE>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_Rb_ConstVoidPtr</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Type used for addressing constant block data</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Defining this type as part of NvM is only a temporary solution until a central ConstVoidPtr type is defined for general use. It has only been created for use in client/server interfaces, not for use within ASW or BSW code.</L-2>
              </DESC>
              <CATEGORY>DATA_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                    <SW-POINTER-TARGET-PROPS>
                      <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                      <SW-DATA-DEF-PROPS>
                        <SW-DATA-DEF-PROPS-VARIANTS>
                          <SW-DATA-DEF-PROPS-CONDITIONAL>
                            <BASE-TYPE-REF DEST="SW-BASE-TYPE">/AUTOSAR_Platform/BaseTypes/void</BASE-TYPE-REF>
                            <SW-IMPL-POLICY>CONST</SW-IMPL-POLICY>
                          </SW-DATA-DEF-PROPS-CONDITIONAL>
                        </SW-DATA-DEF-PROPS-VARIANTS>
                      </SW-DATA-DEF-PROPS>
                    </SW-POINTER-TARGET-PROPS>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
            </IMPLEMENTATION-DATA-TYPE>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_Rb_StatusType</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Enumeration type for general NvM status information</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">The NvM_Rb_GetStatus service provides information based on this type.</L-2>
              </DESC>
              <CATEGORY>TYPE_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <COMPU-METHOD-REF DEST="COMPU-METHOD">/AUTOSAR_NvM/CompuMethods/NvM_Rb_StatusType</COMPU-METHOD-REF>
                    <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                    <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
              <TYPE-EMITTER>HEADER_FILE</TYPE-EMITTER>
            </IMPLEMENTATION-DATA-TYPE>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_Rb_VoidPtr</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Type used for addressing changeable block data</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">Defining this type as part of NvM is only a temporary solution until a central VoidPtr type is defined for general use. It has only been created for use in client/server interfaces, not for use within ASW or BSW code.</L-2>
              </DESC>
              <CATEGORY>DATA_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <SW-POINTER-TARGET-PROPS>
                      <TARGET-CATEGORY>VALUE</TARGET-CATEGORY>
                      <SW-DATA-DEF-PROPS>
                        <SW-DATA-DEF-PROPS-VARIANTS>
                          <SW-DATA-DEF-PROPS-CONDITIONAL>
                            <BASE-TYPE-REF DEST="SW-BASE-TYPE">/AUTOSAR_Platform/BaseTypes/void</BASE-TYPE-REF>
                            <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                          </SW-DATA-DEF-PROPS-CONDITIONAL>
                        </SW-DATA-DEF-PROPS-VARIANTS>
                      </SW-DATA-DEF-PROPS>
                    </SW-POINTER-TARGET-PROPS>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
            </IMPLEMENTATION-DATA-TYPE>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_RequestResultType</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Enumeration type for results of asynchronous block operations</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">The NvM_GetErrorStatus service as well as single and multi block callbacks provide information based on this type.</L-2>
              </DESC>
              <CATEGORY>TYPE_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <COMPU-METHOD-REF DEST="COMPU-METHOD">/AUTOSAR_NvM/CompuMethods/NvM_RequestResultType</COMPU-METHOD-REF>
                    <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                    <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
            </IMPLEMENTATION-DATA-TYPE>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_Rb_MigrationResult_ten</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Enumeration for the NvM migration status information</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">The NvM_Rb_GetMigrationResult and NvM_Rb_AuxGetMigrationResult services provide information based on this type.</L-2>
              </DESC>
              <CATEGORY>TYPE_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <COMPU-METHOD-REF DEST="COMPU-METHOD">/AUTOSAR_NvM/CompuMethods/NvM_Rb_MigrationResult_ten</COMPU-METHOD-REF>
                    <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                    <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
              <TYPE-EMITTER>HEADER_FILE</TYPE-EMITTER>
            </IMPLEMENTATION-DATA-TYPE>
            <IMPLEMENTATION-DATA-TYPE>
              <SHORT-NAME>NvM_Rb_RequestType_ten</SHORT-NAME>
              <LONG-NAME>
                <L-4 L="EN">Enumeration type for the block request type</L-4>
              </LONG-NAME>
              <DESC>
                <L-2 L="EN">The NvM_Rb_GetRequestType service provides information based on this type.</L-2>
              </DESC>
              <CATEGORY>TYPE_REFERENCE</CATEGORY>
              <SW-DATA-DEF-PROPS>
                <SW-DATA-DEF-PROPS-VARIANTS>
                  <SW-DATA-DEF-PROPS-CONDITIONAL>
                    <COMPU-METHOD-REF DEST="COMPU-METHOD">/AUTOSAR_NvM/CompuMethods/NvM_Rb_RequestType_ten</COMPU-METHOD-REF>
                    <IMPLEMENTATION-DATA-TYPE-REF DEST="IMPLEMENTATION-DATA-TYPE">/AUTOSAR_Platform/ImplementationDataTypes/uint8</IMPLEMENTATION-DATA-TYPE-REF>
                    <SW-IMPL-POLICY>STANDARD</SW-IMPL-POLICY>
                  </SW-DATA-DEF-PROPS-CONDITIONAL>
                </SW-DATA-DEF-PROPS-VARIANTS>
              </SW-DATA-DEF-PROPS>
              <TYPE-EMITTER>HEADER_FILE</TYPE-EMITTER>
            </IMPLEMENTATION-DATA-TYPE>
          </ELEMENTS>
        </AR-PACKAGE>
      </AR-PACKAGES>
    </AR-PACKAGE>
  </AR-PACKAGES>
</AUTOSAR>

