

/*
 **********************************************************************************************************************
 * Includes
 **********************************************************************************************************************
*/

#include "Com_Prv.h"
#include "Com_Prv_Inl.h"


/*
 **********************************************************************************************************************
 * Defines/Macros
 **********************************************************************************************************************
*/


/*
 **********************************************************************************************************************
 * Prototypes
 **********************************************************************************************************************
*/
#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
LOCAL_INLINE void Com_Prv_RxTimeoutProcessing(PduIdType idRxPdu_uo, boolean rxIndication_b);
#endif

#ifdef COM_RxIPduTimeout

LOCAL_INLINE boolean Com_Prv_IPduBasedTimeoutMonitoring(PduIdType idRxPdu_uo, boolean reloadDmTimer_b);

LOCAL_INLINE boolean Com_Prv_IPduBasedSigTimeoutAction(PduIdType idRxPdu_uo);

#ifdef COM_RX_SIGNALGROUP
LOCAL_INLINE boolean Com_Prv_IPduBasedSigGrpTimeoutAction(PduIdType idRxPdu_uo);
#endif

#endif /* #ifdef COM_RxIPduTimeout */

#ifdef COM_RxSigUpdateTimeout
LOCAL_INLINE boolean Com_Prv_SigBasedTimeoutMonitoring(PduIdType idRxPdu_uo);
#endif

#ifdef COM_RxSigGrpUpdateTimeout
LOCAL_INLINE boolean Com_Prv_SigGrpBasedTimeoutMonitoring(PduIdType idRxPdu_uo);
#endif

#ifdef COM_RxIPduDeferredProcessing
LOCAL_INLINE void Com_Prv_ProcessDeferredRxIpdu(PduIdType idPdu_uo);
#endif

#ifdef COM_RXIPDU_TP_INVALIDATION

#ifdef COM_RxSigInvalid
LOCAL_INLINE void Com_Prv_ExecuteRxSigInvalidActions(PduIdType idPdu_uo);
#endif /* end of COM_RxSigInvalid */

#ifdef COM_RxSigGrpInvalid
LOCAL_INLINE void Com_Prv_ExecuteRxSigGrpInvalidActions(PduIdType idPdu_uo);
#endif /* end of COM_RxSigGrpInvalid */

#endif /* end of #ifdef COM_RXIPDU_TP_INVALIDATION */


/*
 **********************************************************************************************************************
 * Variables
 **********************************************************************************************************************
*/


/*
 **********************************************************************************************************************
 * Constants
 **********************************************************************************************************************
*/


/*
 **********************************************************************************************************************
 * Functions
 **********************************************************************************************************************
*/
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_InternalMainFunctionRx
 Description      : Service to perform the processing of the AUTOSAR COM receive processing that
                    are not directly initiated by the calls from the RTE and PDU-R.
 Parameter        : idRxMainFunc_uo - Internal Rx-ComMainFunction Id
 Return value     : None
 **********************************************************************************************************************
*/
#ifdef COM_ENABLE_MAINFUNCTION_RX

#define COM_START_SEC_CODE
#include "Com_MemMap.h"
void Com_Prv_InternalMainFunctionRx(Com_MainFunc_tuo idRxMainFunc_uo)
{
    /* DET is not checked for RxMainFuncId, as this is an internal Id generated by the Com */
    /* TRACE[SWS_Com_00664] A call to Com_MainFunctionRx shall simply return if the AUTOSAR COM module was not
     * previously initialized with a call to Com_Init.
     * TRACE[SWS_Com_00804] Error code(COM_E_UNINIT) is not reported,
     * if Com_MainFunctionRx service is called
     * before the AUTOSAR COM module was initialized with Com_Init or after a call to Com_DeInit */
    if (Com_InitStatus_en != COM_UNINIT)
    {
# ifdef COM_RxIPduDeferredProcessing
        Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
# endif
        Com_RxIpduRam_tpst          rxIpduRamPtr_pst;
        uint16_least                idxIdIpdu_qu16;
        uint16_least                numOfIpdus_qu16;
        boolean                     rxIndication_b;

        /* Get the first RxIPdu-Id to be processed for given ComMainFunction */
        idxIdIpdu_qu16  = COM_GET_MAINFUNCTION_CFG( idRxMainFunc_uo ).idFirstIpdu_uo;
        numOfIpdus_qu16      = idxIdIpdu_qu16 + COM_GET_MAINFUNCTION_CFG( idRxMainFunc_uo ).numOfIpdus_uo;

# ifdef COM_RxIPduDeferredProcessing
        rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idxIdIpdu_qu16);
# endif
        rxIpduRamPtr_pst    = &COM_GET_RXPDURAM_S(idxIdIpdu_qu16);

        for ( ; idxIdIpdu_qu16 < numOfIpdus_qu16; idxIdIpdu_qu16++)
        {
            /* Check for Ipdu Group is Started/Stopped */
            if(Com_Prv_CheckRxIPduStatus((PduIdType)idxIdIpdu_qu16))
            {
                Com_Get_SchM_Enter_Com_RxIPduProcess

                /* RxIndication() status has to be stored into local variable here only,
                 * so as to process its timeout later */
                rxIndication_b = Com_GetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u8);

                /* For an IPdu, check if there is any pending RxIndication to be processesed */
                if (rxIndication_b)
                {

# ifdef COM_RxIPduDeferredProcessing
                    /* For an Ipdu with Immediate Signal processing, the _INDICATION flag will be reset here */
                    if (Com_GetValue(RXIPDU,_SIGPROC,rxIpduConstPtr_pcst->rxIPduFields_u8) == COM_IMMEDIATE)
# endif
                    {
                        Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u8,COM_FALSE);
                    }
# ifdef COM_RxIPduDeferredProcessing
                    else
                    {
                        Com_Prv_ProcessDeferredRxIpdu((PduIdType)idxIdIpdu_qu16);
                    }
# endif /* #ifdef COM_RxIPduDeferredProcessing */

                }

# if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)

                /* Reception Deadline Monitoring */
                Com_Prv_RxTimeoutProcessing((PduIdType)idxIdIpdu_qu16, rxIndication_b);

# endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */

                Com_Get_SchM_Exit_Com_RxIPduProcess
            }/* End of check for Ipdu Group is Started/Stopped */

# ifdef COM_RxIPduDeferredProcessing
            rxIpduConstPtr_pcst++;
# endif
            rxIpduRamPtr_pst++;
        } /* End of for loop */
    }/* End of Com initialization status */

} /* End of Com_Prv_InternalMainFunctionRx */
#define COM_STOP_SEC_CODE
#include "Com_MemMap.h"

#endif /*End of #ifdef COM_ENABLE_MAINFUNCTION_RX */


#if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout)
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_RxTimeoutProcessing
 Description      : Performs Reception Deadline Monitoring
 Parameter        : idRxPdu_uo          - Internal Rx-IPdu Id
                    rxIndication_b      - latest RxIndication status
 Return value     : None
 **********************************************************************************************************************
*/

LOCAL_INLINE void Com_Prv_RxTimeoutProcessing(PduIdType idRxPdu_uo, boolean rxIndication_b)
{

    /* Check if deadline monitoring is enabled for Ipdu */
    if (COM_CheckRxIPduDMStatus(idRxPdu_uo))
    {
        Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;

#if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
        Com_RxIpduRam_tpst          rxIpduRamPtr_pst;
#endif
        /* updated any timed out gateway rx-signals/signal groups? */
        boolean                     isGwSigUpdated_b;

        isGwSigUpdated_b        = COM_FALSE;

        rxIpduConstPtr_pcst     = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

#if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
        rxIpduRamPtr_pst        = &COM_GET_RXPDURAM_S(idRxPdu_uo);
#endif

#ifdef COM_RxIPduTimeout

        if (rxIpduConstPtr_pcst->timeout_u16 != COM_ZERO)
        {
            /* TRACE[SWS_Com_00290] The AUTOSAR COM module shall perform an I-PDU based
             * reception deadline monitoring for signals without an update-bit. */
            isGwSigUpdated_b = Com_Prv_IPduBasedTimeoutMonitoring( (PduIdType)idRxPdu_uo, rxIndication_b );
        }
#else
        (void)rxIndication_b;
#endif /* #ifdef COM_RxIPduTimeout */

#ifdef COM_RxSigUpdateTimeout

        /* Start timeout monitoring for signals with update-bit */
        if (rxIpduConstPtr_pcst->signalTimeoutRef_pcst != NULL_PTR)
        {
            isGwSigUpdated_b = Com_Prv_SigBasedTimeoutMonitoring( (PduIdType)idRxPdu_uo ) || isGwSigUpdated_b;
        }
#endif /* #ifdef COM_RxSigUpdateTimeout */

#ifdef COM_RxSigGrpUpdateTimeout

        /* Start timeout monitoring for signal groups with update-bit */
        if (rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst != NULL_PTR)
        {
            isGwSigUpdated_b = Com_Prv_SigGrpBasedTimeoutMonitoring( (PduIdType)idRxPdu_uo ) || isGwSigUpdated_b;
        }
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */

#if defined(COM_SIGNALGATEWAY) || defined(COM_SIGNALGROUPGATEWAY)
        /* This part of code updates the Rx Gateway queue,
         * If any gateway rx-signal in the Ipdu were updated by one of the below means
         * 1. Rx Ipdu timeout leading to a signal update
         * 2. Signal timeout leading to a signal update
         */
        if (isGwSigUpdated_b)
        {
            /* flag checking is also done within locks, to prevent RxIndication from corrupting RxFlags */
            Com_Get_SchM_Enter_Com_RxPduBuffer

            if (Com_GetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,rxIpduRamPtr_pst->rxFlags_u8) == COM_FALSE)
            {
                /* Ipdu timeout caused a update on the Signal,
                 * Hence set the flag to process in next Com_MainFunctionRouteSignals
                 * Once the Ipdu is processed, this flag will hold COM_TRUE in Com_MainFunctionRouteSignals
                 * If any new receptions are invoked on the same Ipdu before the next processing is done,
                 * 1. Signal buffers are updated
                 * 2. Queue is not updated */
                (void)Com_Prv_WriteSigGwReceiveQueue((PduIdType)idRxPdu_uo);

                Com_SetRamValue(RXIPDU,_GWPDU_TOBEPROCESSED,rxIpduRamPtr_pst->rxFlags_u8,COM_TRUE);
            }
            Com_Get_SchM_Exit_Com_RxPduBuffer
        }
#else
        (void)isGwSigUpdated_b;
#endif /* #if defined COM_SIGNALGATEWAY || defined COM_SIGNALGROUPGATEWAY */

    } /* End of check for reception timeout monitoring */

} /* End of Com_Prv_RxTimeoutProcessing */
#endif /* #if defined(COM_RxIPduTimeout) || defined(COM_RxSigUpdateTimeout) || defined(COM_RxSigGrpUpdateTimeout) */


#ifdef COM_RxIPduTimeout
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedTimeoutMonitoring
 Description      : Service to perform rx-IPdus timeout processing
 Parameter        : idRxPdu_uo          - Internal Rx-IPdu Id
                    reloadDmTimer_b     - latest RxIndication status, to reload deadline timer
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
LOCAL_INLINE boolean Com_Prv_IPduBasedTimeoutMonitoring(PduIdType idRxPdu_uo, boolean reloadDmTimer_b)
{
    Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
    Com_RxIpduRam_tpst          rxIpduRamPtr_pst;
    uint16                      rxTimeoutTicks_u16;
    boolean                     isGwSigUpdated_b; /* updated any timed out gateway rx-signals/signal groups? */

    isGwSigUpdated_b = COM_FALSE;

    rxIpduConstPtr_pcst     = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);
    rxIpduRamPtr_pst        = &COM_GET_RXPDURAM_S(idRxPdu_uo);

# ifdef COM_RX_DUAL_CYCLE_SUPPPORT

    /* Check if new dual-cycle-deadline is provided by application */
    if (Com_GetRamValue(RXIPDU,_RELOAD_RXTICKS, rxIpduRamPtr_pst->rxFlags_u8))
    {
        Com_Get_SchM_Enter_Com_RxPduBuffer

        /* clear the flag to capture new till next call to MainFunctionRx */
        Com_SetRamValue(RXIPDU,_RELOAD_RXTICKS, rxIpduRamPtr_pst->rxFlags_u8, COM_FALSE);

        Com_Get_SchM_Exit_Com_RxPduBuffer

        reloadDmTimer_b = COM_TRUE;
    }

    /* get latest dual cycle timeout. this is automic read operation, hence no locks are required. */
    rxTimeoutTicks_u16 = rxIpduRamPtr_pst->rxDualCycTimeout_u16;

    /* check if dual cycle is not provided */
    if (rxTimeoutTicks_u16 == COM_ZERO)
# endif /* end of COM_RX_DUAL_CYCLE_SUPPPORT */
    {
        /* read timeout from calibration or the configured value */
        rxTimeoutTicks_u16 = COM_GET_RXIPDU_TIMEOUT(idRxPdu_uo, rxIpduConstPtr_pcst);
    }
    /* or else use dual-cycle timeout */

    /* Reload Ipdu timeout value on every reception or when dual-cycle deadline is updated with new value */
    if (reloadDmTimer_b)
    {
        /* FC_VariationPoint_START */
#if (COM_ENABLE_JITTERFLITER == STD_ON)
        /* CC requirements:
         * An extra cycle is added to the timeout value after a PDU has been received incase filter is
         * ON Provides a chance incase of jitter( extra cycle is added in normal case and hence
         * if JITTERFILTER is enabled extra two cycles are added)
         */
        rxIpduRamPtr_pst->cntrRxTimeout_u16 = (rxTimeoutTicks_u16 == COM_ZERO) ? COM_RXTIMER_MAX : (rxTimeoutTicks_u16 + 2u);
#else
        /* FC_VariationPoint_END   */
        /* Extra cycle is added to prevent early timeouts */
        rxIpduRamPtr_pst->cntrRxTimeout_u16 = (rxTimeoutTicks_u16 == COM_ZERO) ? COM_RXTIMER_MAX : (rxTimeoutTicks_u16 + 1u);
        /* FC_VariationPoint_START */
#endif /* #ifdef COM_ENABLE_JITTERFLITER */
        /* FC_VariationPoint_END   */
    }

    /* For IPduBased timeout actions, locks are already available at the individual rx-signal and signalGroup bufffers,
     * hence whole timeout monitoring(action) is not placed under locks.
     *
     * About cntrRxTimeout_u16:
     * If the control has reached this point, then IpduGroup is already started.
     * And the only other place where cntrRxTimeout_u16 is written, is
     * when Ipdugroup/DeadlineMonitoring is re-started(stopped -> started).
     * hence locks are not used even for cntrRxTimeout_u16. */

    /* If timeout is disabled for an IPdu (i.e, ComTimeOut = 0) then
     * RxTicks will be loaded with COM_RXTIMER_MAX (0xFFFF).
     * Reduce Tick Timeout only if timeout is applicable (i.e., other than COM_RXTIMER_MAX).
     *
     * Not to go less than ZERO.
     */
    if ((rxIpduRamPtr_pst->cntrRxTimeout_u16 != COM_RXTIMER_MAX) && (rxIpduRamPtr_pst->cntrRxTimeout_u16 != COM_ZERO))
    {
        --rxIpduRamPtr_pst->cntrRxTimeout_u16;
    }

    /* IPDU has timed out */
    if (rxIpduRamPtr_pst->cntrRxTimeout_u16 == COM_ZERO)
    {
        /* Reload the timer upon time out */
        rxIpduRamPtr_pst->cntrRxTimeout_u16 = rxTimeoutTicks_u16;

        /* Perform timeout actions for Signals without update bit position */
        isGwSigUpdated_b = Com_Prv_IPduBasedSigTimeoutAction( idRxPdu_uo );

#ifdef COM_RX_SIGNALGROUP
        /* Perform timeout actions for Signal groups without update bit position */
        isGwSigUpdated_b = Com_Prv_IPduBasedSigGrpTimeoutAction( idRxPdu_uo ) || isGwSigUpdated_b;
#endif

#ifdef COM_RxIPduTimeoutNotify
        if (rxIpduConstPtr_pcst->timeoutNotification_pfct != NULL_PTR)
        {
            Com_Get_SchM_Exit_Com_RxIPduProcess

            /* The following function is generated function in com_cfg.c file
             * This function calls the timeout notification functions of IPDU, signals & signal groups
             * (without update-bit) */
            /* Notifications are invoked outside the Com locks */
            rxIpduConstPtr_pcst->timeoutNotification_pfct();

            Com_Get_SchM_Enter_Com_RxIPduProcess
        }
#endif /* #ifdef COM_RxIPduTimeoutNotify */

    } /* if (rxIpduRamPtr_pst->cntrRxTimeout_u16 == COM_ZERO) */

    return isGwSigUpdated_b;

} /* End of Com_Prv_IPduBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxIPduTimeout */


/*
 **********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedSigTimeoutAction
 Description      : Service to execute rx-signal timeout action
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
#ifdef COM_RxIPduTimeout
LOCAL_INLINE boolean Com_Prv_IPduBasedSigTimeoutAction(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
    Com_RxSigCfg_tpcst          rxSigConstPtr_pcst;
#if defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
    Com_RxSigRam_tpst           rxSigRamPtr_pst;
#endif
    uint16_least                idxSig_qu16;
    Com_MainFunc_tuo            idRxMainFunc_uo;
    boolean                     isGwSigUpdated_b; /* updated any timed out gateway rx-signals ? */

    isGwSigUpdated_b        = COM_FALSE;

    rxIpduConstPtr_pcst     = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    idRxMainFunc_uo         = rxIpduConstPtr_pcst->idMainFunc_uo;

    /* Set the signal flags to indicate timeout
     * When the signal is read using function Com_ReceiveSignal() , if signal is timed out then
     * either previous value or init value is returned based on the action configured
     */
    rxSigConstPtr_pcst = COM_GET_RXSIG_CONSTDATA(rxIpduConstPtr_pcst->idRxSig_uo);

#if defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
    rxSigRamPtr_pst   = &COM_GET_RXSIGNALFLAG(rxIpduConstPtr_pcst->idRxSig_uo);
#endif

    for (idxSig_qu16 = rxIpduConstPtr_pcst->numOfSig_u16; idxSig_qu16 != COM_ZERO; idxSig_qu16--)
    {
        /* Signal with update-bit have seperate timeout handling
         * Signals without update-bit are marked as timed out, when IPdu times out.
         */
#ifdef COM_RxSigUpdateBit
        if (Com_GetValue(GEN,_UPDBITCONF,rxSigConstPtr_pcst->general_u8) == COM_FALSE)
#endif
        {
            /* Now check if the RxTimeout action is = COM_REPLACE */
            if (Com_GetValue(RXSIG,_TOACTION,rxSigConstPtr_pcst->rxSignalFields_u8))
            {
                Com_SigMax_tuo rxSigVal_uo;
#if (defined(COM_RXSIG_INT64) || defined(COM_RXSIG_FLOAT64SUPP))
                uint8          type_u8;

                type_u8     = Com_GetValue(GEN,_TYPE,rxSigConstPtr_pcst->general_u8);
#endif
                rxSigVal_uo=Com_Prv_GetRxSigInitValue(rxSigConstPtr_pcst);

                Com_Get_SchM_Enter_Com_RxSigBuff(MAINFUNCTIONRX)

/* FC_VariationPoint_START */
#ifdef COM_RXSIG_FLOAT64SUPP
                if (type_u8 == COM_FLOAT64)
                {
                    /* For float64 signals, RxSigConstPtr->Init_Val holds index to
                     * float array holding init values. */
                    COM_GET_SIGTYPEFLOAT64_BUFF(idRxMainFunc_uo,rxSigConstPtr_pcst->idxSigBuff_uo) =
                                                         Com_getfloat64InitValue(rxSigVal_uo);
                }
                else
#endif /* #ifdef COM_RXSIG_FLOAT64SUPP */
/* FC_VariationPoint_END */
                {

#ifdef COM_RXSIG_INT64
                    /* TRACE[SWS_Com_00723] The AUTOSAR COM module shall extend the init value
                     * (ComSignalInitValue) of a signal to the size of its ComSignalType.
                     * Init_Val by default will be sign extended only for 32bits.
                     * Currently for COM_SINT64 signal types, if the signal is of Negative,
                     * it is required to perform the sign extension till 64bits explicitly. */
                    rxSigVal_uo = (type_u8 == COM_SINT64) ? (Com_SigMax_tuo)((sint64)((sint32)rxSigVal_uo)) : rxSigVal_uo;
#endif
                    Com_Prv_UpdateRxSignalBuffer(rxSigConstPtr_pcst, rxSigVal_uo, idRxMainFunc_uo);
                }

                Com_Get_SchM_Exit_Com_RxSigBuff(MAINFUNCTIONRX)

            }
#ifdef COM_SIGNALGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal/Ipdu is timed out */
            if(Com_GetValue(RXSIG,_ISGWSIG,rxSigConstPtr_pcst->rxSignalFields_u8))
            {
                /* If the signal is updated after the last call of Com_MainFunctionRouteSignals
                 * because of the Ipdu Timeout
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set */
                Com_SetRamValue(RXSIG,_SIGNALFILLBIT,rxSigRamPtr_pst->rxSigRAMFields_u8,COM_TRUE);

                /* Flag will tell if any signals in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter
             * MASKED_NEW_DIFFERS_MASKED_OLD, the AUTOSAR COM module shall treat the
             * first value received for this signal after a reception deadline monitoring timeout
             * occurred for this signal the same way as if the value has passed the filter criteria. */
            Com_SetRamValue(RXSIG,_DMFILTERING,rxSigRamPtr_pst->rxSigRAMFields_u8,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }

        rxSigConstPtr_pcst++;
#if defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
        rxSigRamPtr_pst++;
#endif
    }

    return isGwSigUpdated_b;

} /* End of Com_Prv_IPduBasedSigTimeoutAction */
#endif /* #ifdef COM_RxIPduTimeout */


/*
 **********************************************************************************************************************
 Function name    : Com_Prv_IPduBasedSigGrpTimeoutAction
 Description      : Service to execute rx-signalGroup timeout action
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
#if defined(COM_RX_SIGNALGROUP) && defined(COM_RxIPduTimeout)
LOCAL_INLINE boolean Com_Prv_IPduBasedSigGrpTimeoutAction(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst             rxIpduConstPtr_pcst;
    Com_RxSigGrpCfg_tpcst           rxSigGrpConstPtr_pcst;
#if defined(COM_SIGNALGROUPGATEWAY) || (defined(COM_RxFilters) && defined(COM_F_MASKEDNEWDIFFERSOLD))
    Com_RxSigGrpRam_tpst            rxSigGrpRamPtr_pst;
#endif
    uint16_least                    idxSigGrp_qu16;
    boolean                         isGwSigUpdated_b; /* updated any timed out gateway rx-signal groups? */

    isGwSigUpdated_b = COM_FALSE;

    rxIpduConstPtr_pcst   = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    /* Set the signal group flags to indicate timeout
     * When the signal group is read using function Com_ReceiveSignalGroup(), if signal group is timed
     * out then either previous value or init value is returned based on the action configured
     */
    rxSigGrpConstPtr_pcst = COM_GET_RXSIGGRP_CONSTDATA(rxIpduConstPtr_pcst->idFirstRxSigGrp_uo);

#if defined(COM_SIGNALGROUPGATEWAY) || (defined COM_RxFilters && defined COM_F_MASKEDNEWDIFFERSOLD)
    rxSigGrpRamPtr_pst   = &COM_GET_RXSIGGRPFLAG(rxIpduConstPtr_pcst->idFirstRxSigGrp_uo);
#endif
    for (idxSigGrp_qu16 = rxIpduConstPtr_pcst->numOfSigGrp_u16; idxSigGrp_qu16 != COM_ZERO; idxSigGrp_qu16--)
    {
        /* Signal Groups with update-bit have seperate timeout handling
         * Signal Groups without update-bit are marked as timed out, when IPdu times out.
         */
#ifdef COM_RxSigGrpUpdateBit
        if (Com_GetValue(RXSIGGRP,_UPDBITCONF,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8) == COM_FALSE)
#endif
        {
            /* Mark the SignalGroup without update-bit as times out,
             * if the SignalGroup TimeoutAction is configured as COM_REPLACE, replace its GroupSignal
             * shadow buffers with SignalInitValues */
            if (Com_GetValue(RXSIGGRP,_TOACTION,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8))
            {
                /* At timeout,Replace group signals in the signal group with Initial values */
                Com_Prv_SigGrpReplaceToInit( rxSigGrpConstPtr_pcst, rxIpduConstPtr_pcst->idMainFunc_uo );
            }
#ifdef COM_SIGNALGROUPGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal group is to be updated
             * into signalgroup buffer by one of the below means
             * 1. Reception of Ipdu and thereby signal update after update bit processing
             */
            if (Com_GetValue(RXSIGGRP,_ISGWSIGGRP,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8))
            {
                /* If the signal is recieved first time after the last call of
                 * Com_MainFunctionRouteSignals then
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set */
                Com_SetRamValue(RXSIGGRP,_SIGNALFILLBIT,rxSigGrpRamPtr_pst->rxSigGrpRAMFields_u8,COM_TRUE);

                /* Flag will tell if any signalGroups in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGROUPGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
             * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
             * monitoring timeout occurred for this signal the same way as if the value has passed
             * the filter criteria. */
            Com_SetRamValue(RXSIGGRP,_DMFILTERING,rxSigGrpRamPtr_pst->rxSigGrpRAMFields_u8,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }

        rxSigGrpConstPtr_pcst++;
#if defined(COM_SIGNALGROUPGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
        rxSigGrpRamPtr_pst++;
#endif
    }

    return isGwSigUpdated_b;

} /* End of Com_Prv_IPduBasedSigGrpTimeoutAction */
#endif /* #if defined(COM_RX_SIGNALGROUP) && defined(COM_RxIPduTimeout) */


#ifdef COM_RxSigUpdateTimeout
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_SigBasedTimeoutMonitoring
 Description      : Service to perform timeout processing for rx-Signal with update-bit & timeout
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
LOCAL_INLINE boolean Com_Prv_SigBasedTimeoutMonitoring(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst                 rxIpduConstPtr_pcst;
    Com_RxSigCfg_tpcst                  rxSigConstPtr_pcst;
#if (defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)))
    Com_RxSigRam_tpst                   rxSigRamPtr_pst;
#endif
    const Com_SignalTimeoutInfo_tst *   sigTimeOutConstPtr_pcst;
    uint16 *                            sigTimeOutRamPtr_pu16;
    uint16_least                        numOfSig_qu16;
    uint16_least                        idxSig_qu16;
    Com_MainFunc_tuo                    idRxMainFunc_uo;
#ifdef COM_RxUpdateTimeoutNotify
    boolean                             callTOSigNotify_b;
#endif
    boolean                             isGwSigUpdated_b; /* updated any timed out gateway rx-signals? */

    isGwSigUpdated_b            = COM_FALSE;

    rxIpduConstPtr_pcst         = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);

    idRxMainFunc_uo             = rxIpduConstPtr_pcst->idMainFunc_uo;

    /* Get the number of signals with update-bit & configured timeout, within this IPDU */
    numOfSig_qu16                = rxIpduConstPtr_pcst->signalTimeoutRef_pcst->numWithUpdateBit_u8;
    /* Initialise pointer to Com_SignalTimeoutInfo */
    sigTimeOutConstPtr_pcst     = rxIpduConstPtr_pcst->signalTimeoutRef_pcst->timeoutInfoRef_pcst;
    /* Initialise pointer to timer */
    sigTimeOutRamPtr_pu16       = rxIpduConstPtr_pcst->signalTimeoutRef_pcst->timeoutTicks_pu16;

    for (idxSig_qu16 = numOfSig_qu16; idxSig_qu16 != COM_ZERO; idxSig_qu16--)
    {
#ifdef COM_RxUpdateTimeoutNotify
        /* Reset the callTOSigNotify_b flag before processing next signal */
        callTOSigNotify_b = COM_FALSE;
#endif
        rxSigConstPtr_pcst     = COM_GET_RXSIG_CONSTDATA(sigTimeOutConstPtr_pcst->idSig_u16);

#if (defined(COM_SIGNALGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)))
        rxSigRamPtr_pst       = &COM_GET_RXSIGNALFLAG(sigTimeOutConstPtr_pcst->idSig_u16);
#endif
        /* Decrement the timer, if time out is enabled
         * If FirstTimeOut for signal is disabled then timer will be loaded with COM_RXTIMER_MAX (0xFFFF).
         * Hence do not decrement the timer if timer is COM_RXTIMER_MAX.
         */
        Com_Get_SchM_Enter_Com_RxSigToTicks
        if (((*sigTimeOutRamPtr_pu16) != COM_RXTIMER_MAX) && ((*sigTimeOutRamPtr_pu16) != COM_ZERO))
        {
            --(*sigTimeOutRamPtr_pu16);
        }
        /* Signal has timed out */
        if ((*sigTimeOutRamPtr_pu16) == COM_ZERO)
        {
            /* Reload the timer */
            (*sigTimeOutRamPtr_pu16) = sigTimeOutConstPtr_pcst->timeout_u16;

            /* Now check if the RxTimeout action is = COM_REPLACE */
            if (Com_GetValue(RXSIG,_TOACTION,rxSigConstPtr_pcst->rxSignalFields_u8))
            {
                Com_SigMax_tuo rxSigVal_uo;
#if (defined( COM_RXSIG_INT64 ) || defined( COM_RXSIG_FLOAT64SUPP ))
                uint8          type_u8;

                type_u8     = Com_GetValue(GEN,_TYPE,rxSigConstPtr_pcst->general_u8);
#endif
                rxSigVal_uo=Com_Prv_GetRxSigInitValue(rxSigConstPtr_pcst);

/* FC_VariationPoint_START */
#ifdef COM_RXSIG_FLOAT64SUPP
                if (type_u8 == COM_FLOAT64)
                {
                    /* For float64 signals, rxSigConstPtr_pcst->Init_Val holds index to float array
                     * holding init values.*/
                    COM_GET_SIGTYPEFLOAT64_BUFF(idRxMainFunc_uo,rxSigConstPtr_pcst->idxSigBuff_uo) =
                                                         Com_getfloat64InitValue(rxSigVal_uo);
                }
                else
#endif /* #ifdef COM_RXSIG_FLOAT64SUPP*/
/* FC_VariationPoint_END */
                {

#ifdef COM_RXSIG_INT64
                    /* TRACE[SWS_Com_00723] The AUTOSAR COM module shall extend the init value
                     * (ComSignalInitValue) of a signal to the size of its ComSignalType.
                     * Init_Val by default will be sign extended only for 32bits.
                     * Currently for COM_SINT64 signal types, if the signal is of Negative,
                     * it is required to perform the sign extension till 64bits explicitly. */
                    rxSigVal_uo = (type_u8 == COM_SINT64) ? (Com_SigMax_tuo)((sint64)((sint32)rxSigVal_uo)) : rxSigVal_uo;
#endif
                    /* Set the signal with Init value as signal timed out */
                    Com_Prv_UpdateRxSignalBuffer(rxSigConstPtr_pcst, rxSigVal_uo, idRxMainFunc_uo);
                }
            }

#ifdef COM_RxUpdateTimeoutNotify
            /* Set the signal timeout notification flag, and
             * call TO notification callback outside the lock */
            callTOSigNotify_b = COM_TRUE;
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

#ifdef COM_SIGNALGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal/Ipdu is timed out */
            if(Com_GetValue(RXSIG,_ISGWSIG,rxSigConstPtr_pcst->rxSignalFields_u8))
            {
                /* If the signal is updated after the last call of Com_MainFunctionRouteSignals
                 * because of the signal timeout
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set*/
                Com_SetRamValue(RXSIG,_SIGNALFILLBIT,rxSigRamPtr_pst->rxSigRAMFields_u8,COM_TRUE);

                /* Flag will tell if any signals in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
             * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
             * monitoring timeout occurred for this signal the same way as if the value has passed the
             * filter criteria. */
            Com_SetRamValue(RXSIG,_DMFILTERING,rxSigRamPtr_pst->rxSigRAMFields_u8,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }
        Com_Get_SchM_Exit_Com_RxSigToTicks

#ifdef COM_RxUpdateTimeoutNotify
        /* If signal has timed out,Call the timeout notification for the signal */
        if ((callTOSigNotify_b) &&
            (sigTimeOutConstPtr_pcst->timeoutNotification_pfct != NULL_PTR))
        {
            Com_Get_SchM_Exit_Com_RxIPduProcess
            /* Notifications are invoked outside the Com locks */
            sigTimeOutConstPtr_pcst->timeoutNotification_pfct();

            Com_Get_SchM_Enter_Com_RxIPduProcess
        }
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

        sigTimeOutConstPtr_pcst++;
        sigTimeOutRamPtr_pu16++;
    } /* End for loop */

    return isGwSigUpdated_b;

} /* End of Com_Prv_SigBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxSigUpdateTimeout */


#ifdef COM_RxSigGrpUpdateTimeout
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_SigGrpBasedTimeoutMonitoring
 Description      : Service to perform timeout processing for rx-SignalGroups with update-bit & timeout
 Parameter        : idRxPdu_uo - Internal Rx-IPdu Id
 Return value     : true - if any Gw-signal/signalGroup are updated, otherwise return false.
 **********************************************************************************************************************
*/
LOCAL_INLINE boolean Com_Prv_SigGrpBasedTimeoutMonitoring(PduIdType idRxPdu_uo)
{
    Com_RxIpduCfg_tpcst                 rxIpduConstPtr_pcst;
    Com_RxSigGrpCfg_tpcst               rxSigGrpConstPtr_pcst;
#if defined (COM_SIGNALGROUPGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
    Com_RxSigGrpRam_tpst                rxSigGrpRamPtr_pst;
#endif
    const Com_SignalTimeoutInfo_tst *   sigTimeOutConstPtr_pcst;
    uint16 *                            sigTimeOutRamPtr_pu16;
    uint16_least                        numOfSigGrp_qu16;
    uint16_least                        idxSigGrp_qu16;
    Com_MainFunc_tuo                    idRxMainFunc_uo;
#ifdef COM_RxUpdateTimeoutNotify
    /* flag to call the callback functions when the SigGrp times out */
    boolean                             callTOSigGrpNotify_b;
#endif
    boolean                             isGwSigUpdated_b; /* updated any timed out gateway rx-signal groups? */

    isGwSigUpdated_b            = COM_FALSE;

    rxIpduConstPtr_pcst         = COM_GET_RX_IPDU_CONSTDATA(idRxPdu_uo);
    idRxMainFunc_uo             = rxIpduConstPtr_pcst->idMainFunc_uo;

    /* Get the number of signal groups with update-bit & configured timeout, within this IPDU */
    numOfSigGrp_qu16             = rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst->numWithUpdateBit_u8;
    /* Initialise pointer to Com_SignalTimeoutInfo */
    sigTimeOutConstPtr_pcst     = rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst->timeoutInfoRef_pcst;
    /* Initialise pointer to timer */
    sigTimeOutRamPtr_pu16       = rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst->timeoutTicks_pu16;

    for (idxSigGrp_qu16 = numOfSigGrp_qu16; idxSigGrp_qu16 != COM_ZERO; idxSigGrp_qu16--)
    {
#ifdef COM_RxUpdateTimeoutNotify
        /* Initialise the flag which is used to call the TO notification callback functions */
        callTOSigGrpNotify_b = COM_FALSE;
#endif

#if defined(COM_SIGNALGROUPGATEWAY) || (defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD))
        rxSigGrpRamPtr_pst       = &COM_GET_RXSIGGRPFLAG(sigTimeOutConstPtr_pcst->idSig_u16);
#endif
        /* Decrement the timer, if time out is enabled
         * If FirstTimeOut for signal group is disabled then timer will be loaded with COM_RXTIMER_MAX (0xFFFF).
         * Hence do not decrement the timer if timer is COM_RXTIMER_MAX.
         */
        Com_Get_SchM_Enter_Com_RxSigGrpToTicks
        if (((*sigTimeOutRamPtr_pu16) != COM_RXTIMER_MAX) && ((*sigTimeOutRamPtr_pu16) != COM_ZERO))
        {
            --(*sigTimeOutRamPtr_pu16);
        }
        /* Signal group has timed out */
        if ((*sigTimeOutRamPtr_pu16) == COM_ZERO)
        {
            /* Reload the timer */
            (*sigTimeOutRamPtr_pu16) = sigTimeOutConstPtr_pcst->timeout_u16;

            rxSigGrpConstPtr_pcst    = COM_GET_RXSIGGRP_CONSTDATA(sigTimeOutConstPtr_pcst->idSig_u16);

            /* Once SignalGroup with configured update-bit times out and
             * if the SignalGroup TimeoutAction is configured as COM_REPLACE, replace its GroupSignal
             * shadow buffers with SignalInitValues */
            if (Com_GetValue(RXSIGGRP,_TOACTION,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8))
            {
                /* At timeout,Replace group signals in the signal group with Initial values */
                Com_Prv_SigGrpReplaceToInit( rxSigGrpConstPtr_pcst, idRxMainFunc_uo );
            }

#ifdef COM_RxUpdateTimeoutNotify
            /* Set the flag which is used to call callback notifications signal group with
             * update bit times out*/
            callTOSigGrpNotify_b = COM_TRUE;
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

#ifdef COM_SIGNALGROUPGATEWAY
            /* This part of code updates the Rx Gateway queue If the signal group is to be updated
             *  into signalgroup buffer by one of the below means
             * 1. Reception of Ipdu and thereby signal update after update bit processing
             */
            if(Com_GetValue(RXSIGGRP,_ISGWSIGGRP,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8))
            {
                /* If the signal is recieved first time after the last call of
                 * Com_MainFunctionRouteSignals then
                 * 1. The fill bit per signal has to be set
                 * 2. Queue entry has to be done for the signal
                 * For the further receptions of the signal, Queue and signal fill bit are not set*/
                Com_SetRamValue(RXSIGGRP,_SIGNALFILLBIT,rxSigGrpRamPtr_pst->rxSigGrpRAMFields_u8,COM_TRUE);

                /* Flag will tell if any signals in the Ipdu are updated */
                isGwSigUpdated_b = COM_TRUE;
            }
#endif /* #ifdef COM_SIGNALGROUPGATEWAY */

#if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD)
            /* TRACE[SWS_Com_00793] For a signal with a configured reception filter MASKED_NEW_DIFFERS_MASKED_OLD,
             * the AUTOSAR COM module shall treat the first value received for this signal after a reception deadline
             * monitoring timeout occurred for this signal the same way as if the value has passed
             * the filter criteria.*/
            Com_SetRamValue(RXSIGGRP,_DMFILTERING,rxSigGrpRamPtr_pst->rxSigGrpRAMFields_u8,COM_TRUE);
#endif /* #if defined (COM_RxFilters) && defined (COM_F_MASKEDNEWDIFFERSOLD) */
        }
        Com_Get_SchM_Exit_Com_RxSigGrpToTicks

#ifdef COM_RxUpdateTimeoutNotify
        /* If signal group has timed out,Call the timeout notification for the signal */
        if ((callTOSigGrpNotify_b) &&
            (sigTimeOutConstPtr_pcst->timeoutNotification_pfct != NULL_PTR))
        {
            Com_Get_SchM_Exit_Com_RxIPduProcess
            /* Notifications are invoked outside the Com locks */
            sigTimeOutConstPtr_pcst->timeoutNotification_pfct();

            Com_Get_SchM_Enter_Com_RxIPduProcess
        }
#endif /* #ifdef COM_RxUpdateTimeoutNotify */

        sigTimeOutConstPtr_pcst++;
        sigTimeOutRamPtr_pu16++;
    } /* End for loop */

    return isGwSigUpdated_b;

} /* End of Com_Prv_SigGrpBasedTimeoutMonitoring */
#endif /* #ifdef COM_RxSigGrpUpdateTimeout */


#ifdef COM_PROVIDE_IPDU_STATUS
/*
 **********************************************************************************************************************
 Function name    : COM_ProvideRxIpduStatus
 Description      : Service returns the status of Rx I-PDU referenced by PduId.
 Parameter        : idPdu_uo -> Rx-Ipdu ID
 Return value     : true - if Ipdu is started, otherwise return false.
 **********************************************************************************************************************
*/
#define COM_START_SEC_CODE
#include "Com_MemMap.h"
boolean Com_ProvideRxIpduStatus(PduIdType idPdu_uo)
{
    boolean     pduStatus_b;

    pduStatus_b  = COM_FALSE;

# if (COM_PRV_ERROR_HANDLING == STD_ON)
    if (Com_InitStatus_en == COM_UNINIT)
    {
        COM_DET_REPORT_ERROR(COMServiceId_ProvideRxIpduStatus, COM_E_UNINIT);
    }
    else if (!Com_Prv_IsValidRxIpduId(idPdu_uo))
    {
        COM_DET_REPORT_ERROR(COMServiceId_ProvideRxIpduStatus, COM_E_PARAM);
    }
    else
# endif /* end of COM_PRV_ERROR_HANDLING */
    {
        /* If PB variant is selected, then PduId which is passed to this function will be changed
         * to internal Id which is generated through configuration
         * If PC variant is selected, then no mapping table will be used. */

        idPdu_uo = COM_GET_RX_IPDU_ID(idPdu_uo);

        pduStatus_b = Com_Prv_CheckRxIPduStatus(idPdu_uo);
    }

    return(pduStatus_b);

} /* End of Com_ProvideRxIpduStatus */
#define COM_STOP_SEC_CODE
#include "Com_MemMap.h"
#endif /* #ifdef COM_PROVIDE_IPDU_STATUS */


#ifdef COM_RxIPduDeferredProcessing
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ProcessDeferredRxIpdu
 Description      : Rx-IPDU processing with DEFERRED signal-processing
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_ProcessDeferredRxIpdu(PduIdType idPdu_uo)
{
    Com_RxIpduCfg_tpcst     rxIpduConstPtr_pcst;
    Com_RxIpduRam_tpst      rxIpduRamPtr_pst;
    PduInfoType             rxPduInfo_st;

    rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idPdu_uo);
    rxIpduRamPtr_pst    = &COM_GET_RXPDURAM_S(idPdu_uo);

    rxPduInfo_st.SduDataPtr = COM_GET_DEFERREDBUFFER(rxIpduConstPtr_pcst->idMainFunc_uo);

#ifdef COM_TP_IPDUTYPE
    if (Com_GetValue(RXIPDU,_IS_TP_TYPE,rxIpduConstPtr_pcst->rxIPduFields_u8) == COM_FALSE)
#endif
    {
        Com_Get_SchM_Enter_Com_RxPduBuffer

        rxPduInfo_st.SduLength = rxIpduRamPtr_pst->rxIPduLength_uo;

        /*
         * Copy the data from IPdu buffer to another buffer
         * This is required for data consistency as it is possible that IPdu buffer is updated
         * by Com_RxIndication(), when it is being processed
         * Since all the IPdus are processed sequentially, only one common buffer is sufficient
         */
        Com_ByteCopy(rxPduInfo_st.SduDataPtr, rxIpduConstPtr_pcst->buffPtr_pau8, rxPduInfo_st.SduLength);

        /* Reset the flag after checking the flag
         * In case of defered processing, the flag should be reset under protection */
        Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u8,COM_FALSE);

        Com_Get_SchM_Exit_Com_RxPduBuffer

#if defined(COM_RxIPduCallOuts) || defined(COM_RX_IPDUCOUNTER)
        if (Com_Prv_IsValidRxIpdu(idPdu_uo, &rxPduInfo_st))
#endif
        {
            Com_Prv_ProcessRxIPdu(idPdu_uo, &rxPduInfo_st);
        }
    }
#ifdef COM_TP_IPDUTYPE
    else
    {
        if (Com_GetRamValue(RXIPDU,_IS_INVALID,rxIpduRamPtr_pst->rxFlags_u8) == COM_FALSE)
        {
            Com_Get_SchM_Enter_Com_RxPduBuffer

            rxPduInfo_st.SduLength = rxIpduRamPtr_pst->rxIPduLength_uo;

            /*
             * Copy the data from IPdu buffer to another buffer
             * This is required for data consistency as it is possible that IPdu buffer is updated
             * by Com_TpRxIndication(), when it is being processed
             * Since all the IPdus are processed sequentially, only one common buffer is sufficient
             */
            Com_ByteCopy(rxPduInfo_st.SduDataPtr, rxIpduConstPtr_pcst->buffPtr_pau8, rxPduInfo_st.SduLength);

            /* Reset the flag after checking the flag
             * In case of defered processing, the flag should be reset under protection */
            Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u8,COM_FALSE);

            Com_Get_SchM_Exit_Com_RxPduBuffer

            /* IPDU callout and counter is already processed in Com_TpRxIndication */

            Com_Prv_ProcessRxIPdu(idPdu_uo, &rxPduInfo_st);
        }
        else
        {
            Com_Get_SchM_Enter_Com_RxPduBuffer

            Com_SetRamValue(RXIPDU,_INDICATION,rxIpduRamPtr_pst->rxFlags_u8,COM_FALSE);

            Com_SetRamValue(RXIPDU,_IS_INVALID,rxIpduRamPtr_pst->rxFlags_u8,COM_FALSE);

            Com_Get_SchM_Exit_Com_RxPduBuffer

# ifdef COM_RXIPDU_TP_INVALIDATION
            if (Com_GetValue(RXIPDU,_TP_INV_CFG,rxIpduConstPtr_pcst->rxIPduFields_u8))
            {
                Com_Prv_ExecuteRxInvalidActions(idPdu_uo);
            }
# endif /* end of #ifdef COM_RXIPDU_TP_INVALIDATION */
        }
    }
#endif /* end of #ifdef COM_TP_IPDUTYPE */
}

#endif /* end of # ifdef COM_RxIPduDeferredProcessing */


#ifdef COM_RXIPDU_TP_INVALIDATION

/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ExecuteRxInvalidActions
 Description      : Execute all configured ComDataInvalidActions for all included signals and signal groups
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
#define COM_START_SEC_CODE
#include "Com_MemMap.h"

void Com_Prv_ExecuteRxInvalidActions(PduIdType idPdu_uo)
{
#ifdef COM_RxSigInvalid
    Com_Prv_ExecuteRxSigInvalidActions(idPdu_uo);
#endif

#ifdef COM_RxSigGrpInvalid
    Com_Prv_ExecuteRxSigGrpInvalidActions(idPdu_uo);
#endif

#if defined(COM_RxIPduNotification) || defined(COM_RxSignalNotify) || defined(COM_RxSignalGrpNotify)
    Com_Prv_InvokeRxNotifications(idPdu_uo);
#endif

}
#define COM_STOP_SEC_CODE
#include "Com_MemMap.h"


#ifdef COM_RxSigInvalid
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ExecuteRxSigInvalidActions
 Description      : Execute all configured ComDataInvalidActions for all included signals
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_ExecuteRxSigInvalidActions(PduIdType idPdu_uo)
{
    Com_RxIpduCfg_tpcst         rxIpduConstPtr_pcst;
    Com_RxSigCfg_tpcst          rxSigConstPtr_pcst;
#ifdef COM_RxSignalNotify
    Com_RxSigRam_tpst           rxSigRamPtr_pst;
#endif
    uint16_least                idxIdSig_qu16;
    uint16_least                idMaxRxSig_qu16;
    Com_SigMax_tuo              rxSigNewVal_uo;
#ifdef COM_RxSigUpdateTimeout
    uint16_least                idxSigTout_qu16;
    uint8                       ipduUpdateBitStatus_u8;
    uint8                       sigUpdateBitStatus_u8;
#endif
    Com_MainFunc_tuo            idRxMainFunc_uo;

    rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idPdu_uo);

#ifdef COM_RxSigUpdateTimeout
    /* If this IPDU has signals with update-bits , initialise the pointers
     * Separate deadline monitoring should be performed for signals with update-bit
     * Deadline monitoring should not be done if it is disabled
     */
    /* MR12 RULE 13.5 VIOLATION: Below conditional statement access RAM, use of intermediate variables
     * to store and read here, may read obsolete value. Evaluation(or no evaluation) shall not impact the
     * system behaviour. Hence suppressed. */
    if ((rxIpduConstPtr_pcst->signalTimeoutRef_pcst != NULL_PTR) && (COM_CheckRxIPduDMStatus(idPdu_uo)))
    {

        /* Update the variable UpdateBitStatus with value COM_UPDATEBIT_APPLICABLE
         * ie at least one of the signal within the IPDU is configured with both update-bit.
         */
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_APPLICABLE;
    }
    else
    {
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_NOT_APPLICABLE;
    }

    /* Initialize the variable to be used to refer the first signal timeout configuration */
    idxSigTout_qu16 = COM_ZERO;
#endif /* #ifdef COM_RxSigUpdateTimeout */

    idRxMainFunc_uo     = rxIpduConstPtr_pcst->idMainFunc_uo;

    idxIdSig_qu16       = rxIpduConstPtr_pcst->idRxSig_uo;
    idMaxRxSig_qu16     = idxIdSig_qu16 + rxIpduConstPtr_pcst->numOfSig_u16;

    rxSigConstPtr_pcst  = COM_GET_RXSIG_CONSTDATA(idxIdSig_qu16);
#ifdef COM_RxSignalNotify
    rxSigRamPtr_pst     = &COM_GET_RXSIGNALFLAG(idxIdSig_qu16);
#endif

    for ( ; idxIdSig_qu16 < idMaxRxSig_qu16; idxIdSig_qu16++ )
    {

#ifdef COM_RxSigUpdateTimeout
        sigUpdateBitStatus_u8 = ipduUpdateBitStatus_u8;
#endif

        /* [DesignDecision] float64 signal buffers are not updated here,
           as validator prevents configuration of invalidation */
        /* required only for signals that support InvalidAction */
        if (Com_GetValue(RXSIG,_INVACTION,rxSigConstPtr_pcst->rxSignalFields_u8) != COM_NONE)
        {
            rxSigNewVal_uo = rxSigConstPtr_pcst->dataInvalidVal_u32;

            if (Com_Prv_ValidateRxSignal((Com_SignalIdType)idxIdSig_qu16, &rxSigNewVal_uo))
            {
                /* NOTE on Exclusive area MAINFUNCTIONRX:
                 * If there is a possibility that Com_RxIndication() can be interrupted by
                 * Com_ReceiveSignal() or Com_Init() function for any IPdu,
                 * then this exclusive area needs to be defined in Com_Cfg_SchM.h file.
                 */
                /* Copy the new value of the signal into signal buffer */

#ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT
                if (Com_GetValue(GEN,_TYPE,rxSigConstPtr_pcst->general_u8) == COM_UINT8_DYN)
                {
                    Com_Get_SchM_Enter_Com_RxSigDynBuff

                    /* UINT8_DYN signal */
                    Com_ByteCopyInit( &COM_GET_SIGTYPEUINT8DYN_BUFF(idRxMainFunc_uo,rxSigConstPtr_pcst->idxSigBuff_uo),
                                      (uint32)rxSigNewVal_uo, rxSigConstPtr_pcst->bitSize_uo );

                    Com_Get_SchM_Exit_Com_RxSigDynBuff
                }
                else
#endif /* #ifdef COM_RX_DYNAMIC_SIGNAL_SUPPORT */
                {
                    Com_Get_SchM_Enter_Com_RxSigBuff(MAINFUNCTIONRX)

                    /* Signal copy is done for rx signals */
                    Com_Prv_UpdateRxSignalBuffer(rxSigConstPtr_pcst, rxSigNewVal_uo, idRxMainFunc_uo);

                    Com_Get_SchM_Exit_Com_RxSigBuff(MAINFUNCTIONRX)
                }

                /* If sigUpdateBitStatus_u8 is
                 * COM_UPDATEBIT_NOT_APPLICABLE(0x0), then it remains unchanged.
                 * COM_UPDATEBIT_APPLICABLE(0x1), then it is changed to COM_UPDATEBIT_SET(0x2) here. */
#ifdef COM_RxSigUpdateTimeout
                sigUpdateBitStatus_u8 <<= COM_ONE;
#endif

                /* Set the _SIGNOTIF flag to invoke configured signal-ComNotification */
#ifdef COM_RxSignalNotify
                Com_SetRamValue(RXSIG,_SIGNOTIF,rxSigRamPtr_pst->rxSigRAMFields_u8,COM_TRUE);
#endif
            }
        }

#ifdef COM_RxSigUpdateTimeout
        if (sigUpdateBitStatus_u8 != COM_UPDATEBIT_NOT_APPLICABLE)
        {
            Com_Prv_LoadSigTimeoutValue((Com_SignalIdType)idxIdSig_qu16, sigUpdateBitStatus_u8, &idxSigTout_qu16);
        }
#endif /* end of #ifdef COM_RxSigUpdateTimeout */

        rxSigConstPtr_pcst++;
#ifdef COM_RxSignalNotify
        rxSigRamPtr_pst++;
#endif

    }
}
#endif /* COM_RxSigInvalid */


#ifdef COM_RxSigGrpInvalid
/*
 **********************************************************************************************************************
 Function name    : Com_Prv_ExecuteRxSigGrpInvalidActions
 Description      : Execute all configured ComDataInvalidActions for all included signal groups
 Parameter        : idPdu_uo
 Return value     : Void
 **********************************************************************************************************************
*/
LOCAL_INLINE void Com_Prv_ExecuteRxSigGrpInvalidActions(PduIdType idPdu_uo)
{
    Com_RxIpduCfg_tpcst             rxIpduConstPtr_pcst;
    Com_RxSigGrpCfg_tpcst           rxSigGrpConstPtr_pcst;
#ifdef COM_RxSignalGrpNotify
    Com_RxSigGrpRam_tpst            rxSigGrpRamPtr_pst;
#endif
    uint16_least                    idxIdSigGrp_qu16;
    uint16_least                    idMaxSigGrp_qu16;
#ifdef COM_RxSigGrpUpdateTimeout
    uint16_least                    idxSigTout_qu16;
    uint8                           ipduUpdateBitStatus_u8;
    uint8                           sigUpdateBitStatus_u8;
#endif
    uint8                           invalidAction_u8;
    Com_MainFunc_tuo                idRxMainFunc_uo;

    rxIpduConstPtr_pcst  = COM_GET_RX_IPDU_CONSTDATA(idPdu_uo);

#ifdef COM_RxSigGrpUpdateTimeout
    /* If this IPDU has signals with update-bits , initialise the pointers
     * Separate deadline monitoring should be performed for signals with update-bit
     * Deadline monitoring should not be done if it is disabled
     */
    /* MR12 RULE 13.5 VIOLATION: Below conditional statement access RAM, use of intermediate variables
     * to store and read here, may read obsolete value. Evaluation(or no evaluation) shall not impact the
     * system behaviour. Hence suppressed. */
    if ((rxIpduConstPtr_pcst->signalGrpTimeoutRef_pcst != NULL_PTR) && (COM_CheckRxIPduDMStatus(idPdu_uo)))
    {

        /* Update the variable UpdateBitStatus with value COM_UPDATEBIT_APPLICABLE
         * ie at least one of the signal within the IPDU is configured with both update-bit.
         */
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_APPLICABLE;
    }
    else
    {
        ipduUpdateBitStatus_u8 = COM_UPDATEBIT_NOT_APPLICABLE;
    }

    /* Initialize the variable to be used to refer the first signal timeout configuration */
    idxSigTout_qu16 = COM_ZERO;

#endif /* #ifdef COM_RxSigGrpUpdateTimeout */

    idRxMainFunc_uo     = rxIpduConstPtr_pcst->idMainFunc_uo;

    idxIdSigGrp_qu16    = rxIpduConstPtr_pcst->idFirstRxSigGrp_uo;
    idMaxSigGrp_qu16    = idxIdSigGrp_qu16 + rxIpduConstPtr_pcst->numOfSigGrp_u16;

    rxSigGrpConstPtr_pcst  = COM_GET_RXSIGGRP_CONSTDATA(idxIdSigGrp_qu16);

#ifdef COM_RxSignalGrpNotify
    rxSigGrpRamPtr_pst    = &COM_GET_RXSIGGRPFLAG(idxIdSigGrp_qu16);
#endif

    /* Start processing for signal groups. */
    for ( ; idxIdSigGrp_qu16 < idMaxSigGrp_qu16; idxIdSigGrp_qu16++)
    {
#ifdef COM_RxSigGrpUpdateTimeout
        sigUpdateBitStatus_u8 = ipduUpdateBitStatus_u8;
#endif

        invalidAction_u8 = Com_GetValue(RXSIGGRP,_INVACTION,rxSigGrpConstPtr_pcst->rxSignalGrpFields_u8);

        if (invalidAction_u8 == COM_REPLACE)
        {
            /* Replace all the GroupSignals with Initial value */
            Com_Prv_SigGrpReplaceToInit(rxSigGrpConstPtr_pcst, idRxMainFunc_uo);

            /* If sigUpdateBitStatus_u8 is
             * COM_UPDATEBIT_NOT_APPLICABLE(0x0), then it remains unchanged.
             * COM_UPDATEBIT_APPLICABLE(0x1), then it is changed to COM_UPDATEBIT_SET(0x2) here. */
#ifdef COM_RxSigGrpUpdateTimeout
            sigUpdateBitStatus_u8 <<= COM_ONE;
#endif

            /* Set _SIGNOTIF flag to invoke configured SignalGroup-ComNotification */
#ifdef COM_RxSignalGrpNotify
            Com_SetRamValue(RXSIGGRP,_SIGNOTIF,rxSigGrpRamPtr_pst->rxSigGrpRAMFields_u8,COM_TRUE);
#endif
        }
#ifdef COM_RxSigGrpInvalidNotify
        else if (invalidAction_u8 == COM_NOTIFY)
        {
            /* Invoke invalid notification function */
            if(rxSigGrpConstPtr_pcst->invalidNotification_pfct != NULL_PTR)
            {
                rxSigGrpConstPtr_pcst->invalidNotification_pfct();
            }
        }
#endif /* #ifdef COM_RxSigGrpInvalidNotify */
        else
        {
            /* do nothing */
        }

#ifdef COM_RxSigGrpUpdateTimeout
        if (sigUpdateBitStatus_u8 != COM_UPDATEBIT_NOT_APPLICABLE)
        {
            Com_Prv_LoadSigGrpTimeoutValue((Com_SignalGroupIdType)idxIdSigGrp_qu16, sigUpdateBitStatus_u8, &idxSigTout_qu16);
        }
#endif /* end of #ifdef COM_RxSigGrpUpdateTimeout */

        rxSigGrpConstPtr_pcst++;
#ifdef COM_RxSignalGrpNotify
        rxSigGrpRamPtr_pst++;
#endif
    }
}
#endif /* COM_RxSigGrpInvalid */

#endif /* end of #ifdef COM_RXIPDU_TP_INVALIDATION */

