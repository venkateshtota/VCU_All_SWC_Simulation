/*******************************************************************************
 * Autogenerated by MCALgen for MCAL V2.0.0.30631: VirtualCan.cpp
 *******************************************************************************/

//#define CAN_VIRTUAL_DEBUG

/************************************************************************************************************
 *                         Include Files
 ***********************************************************************************************************/
#ifdef unix
  extern "C" {
    #include <stdlib.h>
    #include <sys/select.h>
    #include <unistd.h>
  }
#else /* unix */
  #include <windows.h>
  #undef CONST
#endif /* unix */

#include "Can_HwProvider.hpp"
#include "vrtaCore.h"
#include "virtualDevice.hpp"

extern "C" {
  #include "MCalLogging.h"
}


/************************************************************************************************************
 *                         VIRTUAL Driver Implementation
 ***********************************************************************************************************/

#define CAN_VIRTUAL_DRIVER_NAME                "VirtualCan" // Driver name.
#define CAN_VIRTUAL_MAX_TX_INDEX               1000000U     // Can_HwHandleType is a uint16 so there can be
                                                            // at most 65536 transmit objects so this value
                                                            // is greater than the highest transmit object handle
                                                            // or transmit object array index.
#define CAN_VIRTUAL_NO_TX_INDEX                ((unsigned) -1)
#define CAN_VIRTUAL_NUM_CONTROLLERS_PER_BUS    4U          // The number of virtual CAN contollers per bus. All
                                                           // CAN controllers that have the same value of
                                                           // (hardware-id / CAN_VIRTUAL_NUM_CONTROLLERS_PER_BUS)
                                                           // are on the same CAN bus. E.g. when this value is 4,
                                                           // CAN controllers with hardware IDs 0..3 are on CAN bus 0
                                                           // and controllers with hardware IDs 5..7 are on CAN bus 1.

// ---------------------------------------------------------------------------
// [$CANHWP 38] Not relevant to virtual CAN.
// [$CANHWP 41] Not relevant to virtual CAN.

// ---------------------------------------------------------------------------
class Can_Virtual_TxObject {
public:
  Can_HwHandleType m_Handle;
  Can_Hwp_Frame    m_Frame;
  uint8 m_FdPaddingValue;
  // These are used to communicate with the worker thread - hence they are
  // volatile and should be read/written with a single instruction.
  volatile bool m_InUse;   // True if the object in use.
  volatile bool m_Cancel;  // True if the transmit in this object should be cancelled.

  Can_Virtual_TxObject(void)
    : m_Handle(0U),
      m_InUse(false),
      m_Cancel(false) {
    m_FdPaddingValue = 0;
    
    memset(&m_Frame, 0, sizeof(m_Frame));
  }
};

// ---------------------------------------------------------------------------
class Can_Virtual_RxObject {
public:
  Can_HwHandleType  m_Handle;
  Can_Hwp_CanRxType m_RxType;
  Can_Hwp_CanIdType m_IdType;
  uint32            m_RxId;
  uint32            m_RxFilterMask;

  Can_Virtual_RxObject(void)
    : m_Handle(0U),
      m_RxType(CAN_HWP_RXTYPE_BASIC),
      m_IdType(CAN_HWP_IDTYPE_STANDARD),
      m_RxId(0U),
      m_RxFilterMask(0U) { }
};


// ---------------------------------------------------------------------------
class Can_Virtual_Controller {
public:
  const char*           m_CtrlName;
  Can_Hwp_UpCall        m_UpCall;
  uint32                m_UpCallContext;
  bool                  m_Configured;

  bool                  m_CancelTxLowerPriority;  // True iff lower priority transmits should be cancelled.
  bool                  m_CancelTxEqualPriority;  // True iff equal priority transmits should be cancelled.

  unsigned              m_NumTxObjects;
  unsigned              m_LowestTxHandle;
  unsigned              m_HighestTxHandle;
  Can_Virtual_TxObject* m_TxObjects;
  Can_Virtual_TxObject* m_ShadowTxObjects;
  unsigned*             m_TxObjectsMap;

  unsigned              m_NumRxObjects;
  Can_Virtual_RxObject* m_RxObjects;
  unsigned              m_Baudrate;
  
  unsigned              m_FdBaudrate;
  bool                  m_FdTxBitRateSwitch;
  // These are used to communicate with the worker thread - hence they are
  // volatile and should be read/written with a single instruction.
  volatile Can_Hwp_Event m_CurrentState;
  volatile Can_Hwp_Event m_NewState;
  volatile unsigned      m_LowestTxIndex;
  volatile unsigned      m_HighestTxIndex;
  volatile bool          m_TxPending;
  volatile bool          m_CausedWakeup;
  volatile bool          m_EnableTxProcessing;
  volatile bool          m_ForceBusOff;
  volatile bool          m_ForceWakeup;

  Can_Virtual_Controller(void)
    : m_CtrlName(""),
      m_UpCall(NULL_CPP_PTR),
      m_UpCallContext(0U),
      m_Configured(false),

      m_CancelTxLowerPriority(false),
      m_CancelTxEqualPriority(false),

      m_NumTxObjects(0U),
      m_LowestTxHandle(CAN_VIRTUAL_MAX_TX_INDEX),
      m_HighestTxHandle(0U),
      m_TxObjects(NULL_CPP_PTR),
      m_ShadowTxObjects(NULL_CPP_PTR),
      m_TxObjectsMap(NULL_CPP_PTR),

      m_NumRxObjects(0U),
      m_RxObjects(NULL_CPP_PTR),
      m_Baudrate(1000U),
        
      m_FdBaudrate(0U),
      m_FdTxBitRateSwitch(true),
      // [$CANHWP 4]
      m_CurrentState(CAN_HWP_EVENT_STOPPED),
      m_NewState(CAN_HWP_EVENT_STOPPED),
      m_LowestTxIndex(CAN_VIRTUAL_MAX_TX_INDEX),
      m_HighestTxIndex(0U),
      m_TxPending(false),
      m_CausedWakeup(false),
      m_EnableTxProcessing(true),
      m_ForceBusOff(false),
      m_ForceWakeup(false) { }
  
  ~Can_Virtual_Controller(void) {
    delete [] m_TxObjects;
    delete [] m_ShadowTxObjects;
    delete [] m_TxObjectsMap;
    delete [] m_RxObjects;
  }

  void UpCall(Can_Hwp_Event event, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
    // [$CANHWP 46]
    m_UpCall(m_UpCallContext, event, handle, frame);
  }

};


// ---------------------------------------------------------------------------
static void Can_Virtual_Teardown(void);
static void Can_Virtual_WorkerThread(void);


// ---------------------------------------------------------------------------
class Can_Virtual_Driver {
private:
  bool                    m_Initialised;      // Has the driver been initialised OK?
  bool                    m_InitFailed;       // Did intialisation fail?

  unsigned                m_NumControllers;
  Can_Virtual_Controller* m_Controllers;      // Per-controller information.

  volatile bool           m_ThreadRunning;    // Is our worker thread running?
#ifdef unix
  int                     m_ThreadEvent[2];   // Event (pipe) used to wakeup the worker thread.
#else
  HANDLE                  m_ThreadEvent;      // Event used to wakeup the worker thread.
#endif

public:
  // ---------------------------------------------------------------
  Can_Virtual_Driver(void)
    : m_Initialised(false),
      m_InitFailed(false),
      m_NumControllers(0U),
      m_Controllers(NULL_CPP_PTR),
      m_ThreadRunning(false) {
#ifdef unix
      m_ThreadEvent[0] = 0;
      m_ThreadEvent[1] = 0;
#else
      m_ThreadEvent = 0;
#endif
    }

  // ---------------------------------------------------------------
  ~Can_Virtual_Driver(void) {
    delete [] m_Controllers;
  }

  // ---------------------------------------------------------------
  // Initialise the VIRTUAL driver and create our worker thread. We
  // do this here rather than in the constructor so we can be sure
  // that all of the global C++ objects associated with vrta have
  // been created first.
  void Initialise(void) {
    // We will be called by he OS thread.
    vrtaEnterUninterruptibleSection();

    m_InitFailed = true;

    // m_Controllers represent the CAN virtual CAN controllers. m_Controllers
    // is indexed the CAN driver's hardware identifier.
    m_NumControllers = 16U;
    m_Controllers    = new Can_Virtual_Controller[m_NumControllers];

    // Create the event used to send events to the worker thread.
    if (!SetupEvent(m_ThreadEvent)) {
      vrtaLeaveUninterruptibleSection();
      return;
    }
    m_ThreadRunning = true;
    vrtaSpawnThread(Can_Virtual_WorkerThread);

    // Arrange for our Teardown() function to be called when the process terminates.
    atexit(Can_Virtual_Teardown);

    m_InitFailed  = false;
    m_Initialised = true;

    vrtaLeaveUninterruptibleSection();
  }

  // ---------------------------------------------------------------
  // Teardown the VIRTUAL driver and stop our worker thread. We
  // do this here rather than in the destructor so we can be sure
  // that all of the global C++ objects associated with vrta are
  // still valid.
  void Teardown(void) {
#ifdef CAN_VIRTUAL_DEBUG
    mcal_printf("VirtualCan", "%s: Teardown starts\n", CAN_VIRTUAL_DRIVER_NAME);
#endif

    // If our worker thread is running then wait for it to terminate. Since
    // we may be running or core 0 we mustn't just spin as this would stop
    // the console and network from running.
//    while (m_ThreadRunning) {
//      SendEvent(m_ThreadEvent);
//#ifdef unix
//      usleep(1000U);
//#else
//      Sleep(1U);
//#endif
//    }

#ifdef CAN_VIRTUAL_DEBUG
    mcal_printf("VirtualCan", "%s: Teardown ends\n", CAN_VIRTUAL_DRIVER_NAME);
#endif
  }

  // ---------------------------------------------------------------
  bool IsControllerPresent(uint32 hwId) {
    // If we've not already initialised the driver (and initialisation
    // hasn't previously failed) then initialise now.
    if (!m_Initialised && !m_InitFailed) {
      Initialise();
    }

    return m_Initialised && hwId < 16 && hwId < m_NumControllers;
  }

  // ---------------------------------------------------------------
  void AddController(uint32 hwId, const char* name, Can_Hwp_UpCall upCall, uint32 context) {
    // If we've not already initialised the driver (and initialisation
    // hasn't previously failed) then initialise now.
    if (!m_Initialised && !m_InitFailed) {
      Initialise();
    }

    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];

    ctrl->m_CtrlName      = name;
    ctrl->m_UpCall        = upCall;
    ctrl->m_UpCallContext = context;
  }

  // ---------------------------------------------------------------
  void ConfigureController(uint32 hwId, const Can_Hwp_ChannelConfig* config) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    if (config->numTxHwObjects == 0U || config->numRxHwObjects == 0U) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];

    // [$CANHWP 6]
    ctrl->m_CancelTxLowerPriority = config->txCancelLowerPriorityEnabled;
    ctrl->m_CancelTxEqualPriority = config->txCancelEqualPriorityEnabled;

    // Create transmit objects.
    ctrl->m_NumTxObjects    = config->numTxHwObjects;
    ctrl->m_LowestTxHandle  = CAN_VIRTUAL_MAX_TX_INDEX;
    ctrl->m_HighestTxHandle = 0U;
    ctrl->m_TxObjects       = new Can_Virtual_TxObject[ctrl->m_NumTxObjects];
    ctrl->m_ShadowTxObjects = new Can_Virtual_TxObject[ctrl->m_NumTxObjects];

    for (unsigned i = 0U; i < ctrl->m_NumTxObjects; i++) {
      ctrl->m_TxObjects[i].m_Handle       = config->txHwObjects[i].handle;
      ctrl->m_ShadowTxObjects[i].m_Handle = config->txHwObjects[i].handle;
             ctrl->m_TxObjects[i].m_FdPaddingValue = config->txHwObjects[i].fdPaddingValue;
       ctrl->m_ShadowTxObjects[i].m_FdPaddingValue = config->txHwObjects[i].fdPaddingValue;
            if (config->txHwObjects[i].handle < ctrl->m_LowestTxHandle) {
        ctrl->m_LowestTxHandle = config->txHwObjects[i].handle;
      }
      if (config->txHwObjects[i].handle > ctrl->m_HighestTxHandle) {
        ctrl->m_HighestTxHandle = config->txHwObjects[i].handle;
      }
    }

    // Create a map to get from frame transmit handle to transmit object quickly.
    unsigned mapSize = ctrl->m_HighestTxHandle - ctrl->m_LowestTxHandle + 1U;
    ctrl->m_TxObjectsMap = new unsigned[mapSize];

    for (unsigned i = 0U; i < mapSize; i++) {
      ctrl->m_TxObjectsMap[i] = CAN_VIRTUAL_NO_TX_INDEX;
    }

    for (unsigned i = 0U; i < ctrl->m_NumTxObjects; i++) {
      ctrl->m_TxObjectsMap[ctrl->m_TxObjects[i].m_Handle - ctrl->m_LowestTxHandle] = i;
    }

    ResetTransmitObjects(ctrl);

    // Create receive objects.
    ctrl->m_NumRxObjects = config->numRxHwObjects;
    ctrl->m_RxObjects    = new Can_Virtual_RxObject[ctrl->m_NumRxObjects];

    for (unsigned i = 0U; i < ctrl->m_NumRxObjects; i++) {
      ctrl->m_RxObjects[i].m_Handle       = config->rxHwObjects[i].handle;
      ctrl->m_RxObjects[i].m_RxType       = config->rxHwObjects[i].rxType;
      ctrl->m_RxObjects[i].m_IdType       = config->rxHwObjects[i].idType;
      ctrl->m_RxObjects[i].m_RxId         = config->rxHwObjects[i].rxId;
      ctrl->m_RxObjects[i].m_RxFilterMask = config->rxHwObjects[i].rxFilterMask;
    }

    ctrl->m_Configured = true;
  }

  // ---------------------------------------------------------------
  void DeInitialise(void) {
    delete [] m_Controllers;
    m_Initialised = false;
  }

  // ---------------------------------------------------------------
  void SetControllerBaudrate(uint32 hwId, const Can_Hwp_BaudrateConfig* baudrate) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];

    // [$CANHWP 6]
    ctrl->m_Baudrate = baudrate->baudrate;
 
    if(baudrate->fdBaudrateConfig != NULL_PTR) {
      if (baudrate->fdBaudrateConfig->baudrate != 0) {
        ctrl->m_FdBaudrate = baudrate->fdBaudrateConfig->baudrate;
        ctrl->m_FdTxBitRateSwitch = baudrate->fdBaudrateConfig->txBitRateSwitch;
      }
    }
        
  }

  // ---------------------------------------------------------------
  void StartController(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    // [$CANHWP 5]
    // We don't need to lock here because we can write the new state atomically
    // and the worker thread "acknowledges" the change by setting the current state.
    ctrl->m_NewState = CAN_HWP_EVENT_RUNNING;
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  void SleepController(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    // Clear any knowledge about previous wakeup events.
    // [$CANHWP 22]
    ctrl->m_CausedWakeup = false;

    // [$CANHWP 8]
    // We don't need to lock here because we can write the new state atomically
    // and the worker thread "acknowledges" the change by setting the current state.
    ctrl->m_NewState = CAN_HWP_EVENT_SLEEPING;
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  void StopController(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    // [$CANHWP 10]
    // We don't need to lock here because we can write the new state atomically
    // and the worker thread "acknowledges" the change by setting the current state.
    ctrl->m_NewState = CAN_HWP_EVENT_STOPPED;
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  bool ControllerCausedWakeup(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return false;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return false;
    }

    // [$CANHWP 21] [$CANHWP 22]
    return ctrl->m_CausedWakeup;
  }

  // -----------------------------------------------------------------------
  Can_Hwp_Event State(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return CAN_HWP_EVENT_STOPPED;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return CAN_HWP_EVENT_STOPPED;
    }

    // [$CANHWP 48] [$CANHWP 49] [$CANHWP 50]
    return ctrl->m_CurrentState;
  }

  // -----------------------------------------------------------------------
  void ForceBusOff(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    ctrl->m_ForceBusOff = true;

    SendEvent(m_ThreadEvent);
  }

  // -----------------------------------------------------------------------
  void ForceWakeup(uint32 hwId) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return;
    }

    ctrl->m_ForceWakeup = true;
    SendEvent(m_ThreadEvent);
  }

  // ---------------------------------------------------------------
  Can_ReturnType Write(uint32 hwId, Can_HwHandleType handle, Can_Hwp_Frame* frame) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return CAN_NOT_OK;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    if (!ctrl->m_Configured) {
      return CAN_NOT_OK;
    }

    if (frame->length > CAN_MAX_FRAME_LENGTH) {
      return CAN_NOT_OK;
    }

    if (handle < ctrl->m_LowestTxHandle || handle > ctrl->m_HighestTxHandle) {
      return CAN_NOT_OK;
    }

    unsigned txIndex = ctrl->m_TxObjectsMap[handle - ctrl->m_LowestTxHandle];
    if (txIndex == CAN_VIRTUAL_NO_TX_INDEX)  {
      return CAN_NOT_OK;
    }

    Can_Virtual_TxObject* txObj = &ctrl->m_TxObjects[txIndex];

    Can_ReturnType retCode = CAN_OK;

    // Obtain the lock to make sure that this code and the the worker thread
    // see a consistent view of the transmit object. Specifically we don't want
    // this code to claim that an object is busy but the worker thread to
    // generate a transmit completion for it.
    VECU_LOCK();

    // Silently drop transmits if we are not fully attached to the network.
    if (ctrl->m_CurrentState == CAN_HWP_EVENT_RUNNING) {

      if (txObj->m_InUse) {
        // The transmit object is busy so we need to work out if we should cancel
        // the transmit. Since frame ID's are stored in canonical form (i.e. the
        // MSB is set for an extended frame) we can just compare IDs to compare
        // priorities. The rule is that standard frames always have a higher
        // priority than extended frames and within a frame type the smaller
        // identifier has a higher priority.

        // If the transmit object contains a higher priority frame then leave it alone.
        // [$CANHWP 15]
        if (txObj->m_Frame.id < frame->id) {
          // Nothing to do - retCode is set to CAN_BUSY later.
        }

        // If the transmit object contains a lower priority frame then cancel it
        // iff lower priority cancellation is enabled.
        else if (txObj->m_Frame.id > frame->id) {
          // [$CANHWP 16]
          if (ctrl->m_CancelTxLowerPriority) {
            txObj->m_Cancel = true;
          }
          // [$CANHWP 17]
          else {
            // Nothing to do - retCode is set to CAN_BUSY later.
          }
        }

        // If the transmit object contains an equal priority frame then cancel it
        // iff equal priority cancellation is enabled.
        else {
          // [$CANHWP 18]
          if (ctrl->m_CancelTxEqualPriority) {
            txObj->m_Cancel = true;
          }
          // [$CANHWP 19]
          else {
            // Nothing to do - retCode is set to CAN_BUSY later.
          }
        }

        retCode = CAN_BUSY;
      }

      else {
        // Transmit object is not busy so put the new frame in it.
        // [$CANHWP 20]
        txObj->m_InUse  = true;
        txObj->m_Cancel = false;
                  if(CAN_ID_FD_BIT_SET(frame->id)) {  /* [$CAN 1163] [$CAN 1229] [$CAN 1230] [$CAN 1233] */
            uint8 frameLength = frame->length;
            if(frame->length > 8 && frame->length < 12) frame->length = 12;
            if(frame->length > 12 && frame->length < 16) frame->length = 16;
            if(frame->length > 16 && frame->length < 20) frame->length = 20;
            if(frame->length > 20 && frame->length < 24) frame->length = 24;
            if(frame->length > 24 && frame->length < 32) frame->length = 32;
            if(frame->length > 32 && frame->length < 48) frame->length = 48;
            if(frame->length > 48 && frame->length < 64) frame->length = 64;

            for(int i = frameLength; i < frame->length; i++) { /*  [$CAN 1203] [$CAN 1234] */
              frame->data[i] = txObj->m_FdPaddingValue;
            }
          }  
                memcpy(&txObj->m_Frame, frame, sizeof(Can_Hwp_Frame));
        retCode = CAN_OK;
      }

      // Tell the worker thread that there is transmit work to be done.
      if (txIndex < ctrl->m_LowestTxIndex) {
        ctrl->m_LowestTxIndex = txIndex;
      }
      if (txIndex > ctrl->m_HighestTxIndex) {
        ctrl->m_HighestTxIndex = txIndex;
      }

      ctrl->m_TxPending = true;
    }

    VECU_UNLOCK();

    // Wakeup the worker thread to do the actual transmit or transmit cancellation.
    SendEvent(m_ThreadEvent);

    return retCode;
  }

  // ---------------------------------------------------------------
  void WorkerThread(void) {
#ifdef CAN_VIRTUAL_DEBUG
    mcal_printf("VirtualCan", "%s: Worker thread started\n", CAN_VIRTUAL_DRIVER_NAME);
#endif

    while (!vrtaIsAppFinished()) {

      for (unsigned i = 0U; i < m_NumControllers; i++) {
        Can_Virtual_Controller* ctrl = &m_Controllers[i];
        if (ctrl->m_Configured) {

          // Do we need to change the state of the controller?
          if (ctrl->m_NewState != ctrl->m_CurrentState) {
            ChangeControllerState(ctrl);

            // [$CANHWP 7] [$CANHWP 9] [$CANHWP 12]
            Can_Hwp_Frame frame;
            ctrl->UpCall(ctrl->m_CurrentState, 0U, &frame);
          }

          // Force bus-off if required.
          // [$CANHWP 51]
          if (ctrl->m_ForceBusOff) { // && ctrl->m_CurrentState == CAN_HWP_EVENT_RUNNING) { 
            HandleBusOff(ctrl);
            // Clear any request to go bus-off.
            // [$CANHWP 52]
            ctrl->m_ForceBusOff = false;
          }

          // Force wakeup if required.
          // [$CANHWP 54]
          if (ctrl->m_ForceWakeup && ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
            HandleWakeup(ctrl);
          }

          // We may need to transmit one or more frames.
          if (ctrl->m_TxPending && ctrl->m_EnableTxProcessing) {
            TransmitFrames(ctrl, i);
          }
        }
      }

      // Wait until someone sends us an event.
      WaitForEvent(m_ThreadEvent);
    }

    m_ThreadRunning = false;

#ifdef CAN_VIRTUAL_DEBUG
    mcal_printf("VirtualCan", "%s: Worker thread ended\n", CAN_VIRTUAL_DRIVER_NAME);
#endif

  }

  // ---------------------------------------------------------------
  void EnableTransmitProcessing(uint32 hwId, bool enable) {
    if (!m_Initialised || hwId >= m_NumControllers) {
      return;
    }

    Can_Virtual_Controller* ctrl = &m_Controllers[hwId];
    ctrl->m_EnableTxProcessing = enable;

    if (enable) {
      SendEvent(m_ThreadEvent);
    }
  }

private:
  // ---------------------------------------------------------------
  void HandleBusOff(Can_Virtual_Controller* ctrl) {
    // [$CANHWP 42]
    ctrl->m_NewState = CAN_HWP_EVENT_STOPPED;
    ChangeControllerState(ctrl);

    // [$CANHWP 43]
    Can_Hwp_Frame frame;
    ctrl->UpCall(CAN_HWP_EVENT_BUSOFF, 0U, &frame);
  }
     
  // ---------------------------------------------------------------
  void HandleWakeup(Can_Virtual_Controller* ctrl) {
    // [$CANHWP 39]
    ctrl->m_NewState = CAN_HWP_EVENT_STOPPED;
    ChangeControllerState(ctrl);

    // [$CANHWP 21]
    ctrl->m_CausedWakeup = true;

    Can_Hwp_Frame frame;
    ctrl->UpCall(CAN_HWP_EVENT_WAKEUP, 0U, &frame);
  }

  // ---------------------------------------------------------------
  void ChangeControllerState(Can_Virtual_Controller* ctrl) {
    // Take a copy of the new state to avoid it changing under our feet.
    Can_Hwp_Event newState = ctrl->m_NewState;

    // [$CANHWP 5] [$CANHWP 6] [$CANHWP 8] [$CANHWP 10]
    // For a virtual CAN controller there is nothing to do to change state.

    // Once we've set m_CurrentState to CAN_HWP_EVENT_STOPPED or CAN_HWP_EVENT_SLEEPING
    // no more writes will be accepted.
    ctrl->m_CurrentState = newState;

    if (newState != CAN_HWP_EVENT_RUNNING) {
      // Hold the lock to force this code to wait until Write has finished in the event that
      // Write has claimed the lock and tested ctrl->m_CurrentState before we set it to
      // something other than CAN_HWP_EVENT_RUNNING.
      // [$CANHWP 11] [$CANHWP 42]
      VECU_LOCK();
      ResetTransmitObjects(ctrl);
      VECU_UNLOCK();
    }

    // Clear any request to wakeup.
    // [$CANHWP 55]
    ctrl->m_ForceWakeup = false;
  }

  // ---------------------------------------------------------------
  void ResetTransmitObjects(Can_Virtual_Controller* ctrl) {
    for (unsigned i = 0U; i < ctrl->m_NumTxObjects; i++) {
      ctrl->m_TxObjects[i].m_InUse = false;
    }

    ctrl->m_LowestTxIndex  = CAN_VIRTUAL_MAX_TX_INDEX;
    ctrl->m_HighestTxIndex = 0U;
    ctrl->m_TxPending      = false;
  }

  // ---------------------------------------------------------------
  void TransmitFrames(Can_Virtual_Controller* ctrl, unsigned hwId) {
    // With the lock held make shadown copies of the transmit objects that are in use
    // and need processing. The externally visible transmit objects are freed.
    unsigned lowestTxIndex;
    unsigned highestTxIndex;

    VECU_LOCK();

    lowestTxIndex  = ctrl->m_LowestTxIndex;
    highestTxIndex = ctrl->m_HighestTxIndex;

    for (unsigned i = lowestTxIndex; i <= highestTxIndex; i++) {
      if (ctrl->m_TxObjects[i].m_InUse) {
        memcpy(&ctrl->m_ShadowTxObjects[i], &ctrl->m_TxObjects[i], sizeof(Can_Virtual_TxObject));
        // [$CANHWP 23] [$CANHWP 26]
        ctrl->m_TxObjects[i].m_InUse = false;
      }
      else {
        ctrl->m_ShadowTxObjects[i].m_InUse = false;
      }
    }

    ctrl->m_LowestTxIndex  = CAN_VIRTUAL_MAX_TX_INDEX;
    ctrl->m_HighestTxIndex = 0U;
    ctrl->m_TxPending      = false;

    // Now drop the lock so that we don't hold up anything else while we are
    // processing the shadown objects.
    VECU_UNLOCK();

    for (unsigned i = lowestTxIndex; i <= highestTxIndex; i++) {
      Can_Virtual_TxObject* txObj = &ctrl->m_ShadowTxObjects[i];

      if (txObj->m_InUse) {
        if (txObj->m_Cancel) {
          // The frame has been cancelled so do not transmit it.
          // [$CANHWP 25]
          // [$CANHWP 27]
          ctrl->UpCall(CAN_HWP_EVENT_TX_CANCELLED, txObj->m_Handle, &txObj->m_Frame);
        }

        else {
          // [$CANHWP 24]
          ctrl->UpCall(CAN_HWP_EVENT_TX_COMPLETED, txObj->m_Handle, &txObj->m_Frame);

          // Send the frame to all virtual CAN controllers that are on the same bus.
          // [$CANHWP 44] [$CANHWP 45]
          Can_Virtual_Controller* busCtrl =
            &m_Controllers[(hwId / CAN_VIRTUAL_NUM_CONTROLLERS_PER_BUS) * CAN_VIRTUAL_NUM_CONTROLLERS_PER_BUS];

          for (unsigned j = 0U; j < CAN_VIRTUAL_NUM_CONTROLLERS_PER_BUS; j++) {
            // [$CANHWP 13] [$CANHWP 14]
            ReceiveFrame(busCtrl, ctrl, &txObj->m_Frame);
            busCtrl++;
          }
        }
      }
    }
  }

  // ---------------------------------------------------------------
  void ReceiveFrame(Can_Virtual_Controller* ctrl, Can_Virtual_Controller* sourceCtrl, Can_Hwp_Frame* frame) {
    // We only want to receive frames when we are in running or sleeping states.
    if (ctrl->m_CurrentState != CAN_HWP_EVENT_RUNNING &&
          ctrl->m_CurrentState != CAN_HWP_EVENT_SLEEPING) {
      return;
    }
    if (ctrl->m_Baudrate != sourceCtrl->m_Baudrate) {
      mcal_error("VirtualCan", "%s: Controller has baudrate %u but source %s has baudrate %u - frame not received",
        ctrl->m_CtrlName, ctrl->m_Baudrate, sourceCtrl->m_CtrlName, sourceCtrl->m_Baudrate);
      return;
    }
    if(CAN_ID_FD_BIT_SET(frame->id)) { /* [$CAN 1162] [$CAN 1229] [$CAN 1230] */
      if ((ctrl->m_FdBaudrate != sourceCtrl->m_FdBaudrate) && (ctrl->m_FdTxBitRateSwitch == TRUE) && (sourceCtrl->m_FdTxBitRateSwitch == TRUE)) {
        mcal_error("VirtualCan", "%s: Controller has Fd baudrate %u but source %s has Fd baudrate %u - frame not received",
          ctrl->m_CtrlName, ctrl->m_FdBaudrate, sourceCtrl->m_CtrlName, sourceCtrl->m_FdBaudrate);
        return;
      }     
      if ((sourceCtrl->m_FdTxBitRateSwitch == TRUE) && (ctrl->m_FdTxBitRateSwitch == FALSE)  && (sourceCtrl->m_Baudrate != sourceCtrl->m_FdBaudrate)) {
        // When the Rx controller's BitRateSwitch is disabled, drop the frames if the Tx controllers default baudrate is not equal to the fd baudrate
        return;
      }  
    }
        
    // If we detect a frame when we are sleeping then we switch to the stopped state and upcall.
    if (ctrl->m_CurrentState == CAN_HWP_EVENT_SLEEPING) {
      HandleWakeup(ctrl);

      // Ignore the received frame.
      // [$CANHWP 40]
    }

    else {
      // For AUTOSAR can the MSB of the frame ID is set for extended frames.
      // [$CANHWP 34]
      uint32 frameId    = frame->id;
      bool   isExtended = false;

      if (CAN_CANONICAL_ID_IS_EXTENDED(frameId)) {
        isExtended = true;
      }

      // Look for one or more receive objects that will accept this frame.
      for (unsigned j = 0U; j < ctrl->m_NumRxObjects; j++) {
        Can_Virtual_RxObject* rxObj = &ctrl->m_RxObjects[j];

        // The frame type must match the receive object type.
        // [$CANHWP 28] [$CANHWP 29] [$CANHWP 30]
        if ((rxObj->m_IdType == CAN_HWP_IDTYPE_STANDARD && !isExtended) ||
            (rxObj->m_IdType == CAN_HWP_IDTYPE_EXTENDED && isExtended) ||
            (rxObj->m_IdType == CAN_HWP_IDTYPE_MIXED)) {

          // For FULL can we need an exact ID match. For BASIC can we allow a filtered match.
          // [$CANHWP 31] [$CANHWP 32] [$CANHWP 47]
          if ((rxObj->m_RxType == CAN_HWP_RXTYPE_FULL &&
                 frameId == rxObj->m_RxId) ||
              (rxObj->m_RxType == CAN_HWP_RXTYPE_BASIC &&
                 ((frameId & rxObj->m_RxFilterMask) == (rxObj->m_RxId & rxObj->m_RxFilterMask)))) {
            // [$CANHWP 33] [$CANHWP 36] [$CANHWP 35]
            Can_Hwp_Frame rxFrame;
            memcpy(&rxFrame, frame, sizeof(Can_Hwp_Frame));
            rxFrame.injected  = FALSE;
            rxFrame.txConfirm = FALSE;
            ctrl->UpCall(CAN_HWP_EVENT_RX, rxObj->m_Handle, &rxFrame);
            break; 
          }
        }

        // Nothing to do to allow the Rx object to receive another frame.
        // [$CANHWP 37]
      }
    }
  }

  // ---------------------------------------------------------------
#ifdef unix

  bool SetupEvent(int* eventFds) {
    if (pipe(eventFds) != 0) {
      mcal_error("VirtualCan", "%s: pipe() failed", CAN_VIRTUAL_DRIVER_NAME);
      return false;
    }

    return true;
  }

#else /* unix */

  bool SetupEvent(HANDLE& event) {
    event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (event == NULL) {
      mcal_error("VirtualCan", "%s: CreateEvent() failed", CAN_VIRTUAL_DRIVER_NAME);
      return false;
    }

    return true;
  }

#endif /* unix */

  // ---------------------------------------------------------------
#ifdef unix

  void WaitForEvent(int* eventPipe) {
      fd_set readFds;
      fd_set exceptFds;

      FD_ZERO(&readFds);
      FD_ZERO(&exceptFds);

      FD_SET(eventPipe[0], &readFds);
      FD_SET(eventPipe[0], &exceptFds);

      // Wait for someone to write to eventPipe.
      int fdReady = select(eventPipe[0] + 1, &readFds, NULL_CPP_PTR, &exceptFds, NULL_CPP_PTR);

      // If someone has written to eventPipe then we need to consume the data.
      if (fdReady > 0 && FD_ISSET(eventPipe[0], &readFds)) {
        char buffer[512];
        read(eventPipe[0], buffer, sizeof(buffer));
      }
  }

#else /* unix */

  void WaitForEvent(HANDLE event) {
    // Wait until either someone sets the event or the timeout expires.
    WaitForSingleObject(event, INFINITE);
  }

#endif /* unix */

  // ---------------------------------------------------------------
#ifdef unix

  void SendEvent(int* eventPipe) {
    char dummy = 0;
    vrtaEnterUninterruptibleSection();
    write(eventPipe[1], &dummy, sizeof(char));
    vrtaLeaveUninterruptibleSection();
  }

#else /* unix */

  void SendEvent(HANDLE event) {
    SetEvent(event);
  }

#endif /* unix */
};

static Can_Virtual_Driver Can_Virtual;


// ---------------------------------------------------------------------------
static void Can_Virtual_WorkerThread(void) {
  Can_Virtual.WorkerThread();
}

static void Can_Virtual_Teardown(void) {
  Can_Virtual.Teardown();
}


/************************************************************************************************************
 *                         Hardware Names
 ***********************************************************************************************************/
static const char* Names[] = {
  "VirtualCan0",
  "VirtualCan1",
  "VirtualCan2",
  "VirtualCan3",
  "VirtualCan4",
  "VirtualCan5",
  "VirtualCan6",
  "VirtualCan7",
  "VirtualCan8",
  "VirtualCan9",
  "VirtualCan10",
  "VirtualCan11",
  "VirtualCan12",
  "VirtualCan13",
  "VirtualCan14",
  "VirtualCan15",
  "?"
};

/************************************************************************************************************
 *                         Channel Implementation
 ***********************************************************************************************************/
class Can_VirtualHw : public Can_Hw {

public:
  // ---------------------------------------------------------------
  Can_VirtualHw(Can_Hwp_UpCall upCall, uint32 context, uint32 HwId) : Can_Hw(upCall, context) {
    m_Name = Names[HwId];
    m_HwId = HwId;

    Can_Virtual.AddController(HwId, m_Name, upCall, context);
  }

  // -----------------------------------------------------------------------
  void Configure(const Can_Hwp_ChannelConfig* config) {
    Can_Virtual.ConfigureController(m_HwId, config);
  }

  // -----------------------------------------------------------------------
  void SetBaudrate(const Can_Hwp_BaudrateConfig* baudrate) {
    Can_Virtual.SetControllerBaudrate(m_HwId, baudrate);
  }

  // -----------------------------------------------------------------------
  void Start(void) {
    Can_Virtual.StartController(m_HwId);
  }

  // -----------------------------------------------------------------------
  void Sleep(void) {
    Can_Virtual.SleepController(m_HwId);
  }

  // -----------------------------------------------------------------------
  void Stop(void) {
    Can_Virtual.StopController(m_HwId);
  }

  // -----------------------------------------------------------------------
  Can_ReturnType Write(Can_HwHandleType handle, Can_Hwp_Frame* frame) {
    return Can_Virtual.Write(m_HwId, handle, frame);
  }

  // -----------------------------------------------------------------------
  bool CausedWakeup(void) {
    return Can_Virtual.ControllerCausedWakeup(m_HwId);
  }

  // -----------------------------------------------------------------------
  Can_Hwp_Event State(void) {
    return Can_Virtual.State(m_HwId);
  }

  // -----------------------------------------------------------------------
  void ForceBusOff(void) {
    Can_Virtual.ForceBusOff(m_HwId);
  }

  // -----------------------------------------------------------------------
  void ForceWakeup(void) {
    Can_Virtual.ForceWakeup(m_HwId);
  }

  // -----------------------------------------------------------------------
  void EnableTransmitProcessing(bool enable) {
    return Can_Virtual.EnableTransmitProcessing(m_HwId, enable);
  }

  // -----------------------------------------------------------------------
  void DeInit(void) {
    Can_Virtual.DeInitialise();
  }

};

/************************************************************************************************************
 *                         Provider Implementation
 ***********************************************************************************************************/

static class Can_Virtual_HwProvider : public Can_HwProvider {

  bool IsHardwareHere(uint32 HwId) {
    return Can_Virtual.IsControllerPresent(HwId);
  }

  bool IsHardwarePresent(uint32 HwId) {
    return Can_Virtual.IsControllerPresent(HwId);
  }

  Can_Hw *GetHardware(Can_Hwp_UpCall UpCall, uint32 Context, uint32 HwId) {

    if (!Can_Virtual.IsControllerPresent(HwId)) {
      return NULL_CPP_PTR;
    }

    Can_VirtualHw *hw = new Can_VirtualHw(UpCall, Context, HwId);

    return hw;
  }

} hw_provider;

// Make this provider available
Can_HwProvider* Can_Virtual_HwProviderPtr = &hw_provider;



