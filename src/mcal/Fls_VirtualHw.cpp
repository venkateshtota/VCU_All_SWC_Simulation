/*******************************************************************************
 * Autogenerated by MCALgen for FLS V1.0.54.30643: Fls_VirtualHw.cpp
 *******************************************************************************/

/************************************************************************************************************
 *				Include Files
 ***********************************************************************************************************/

#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include "Fls_VirtualHw.h"
extern "C" {
  #include "Fls_Implementation.h"
}
#include "Fls_Device.h"

/************************************************************************************************************
 *				Macro Definitions
 ***********************************************************************************************************/

/************************************************************************************************************
 *				Static and Global Variable Definitions
 ***********************************************************************************************************/

/************************************************************************************************************
 *				Static and Global Function Definitions
 ***********************************************************************************************************/

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Fls_FakeHW
 *Description:
 *The member variables are initialised with the values of parameters passed to the constructor.
 *The emulated FLASH is then initialized by creating/
 *opening the file in write mode from the path specified in the derived class.
 *The file is then truncated to length specified by FlsTotalSize. The file is mapped
 *and the pointer 'FlsInternalMap' is initialized. The FLASH state is set to MEMIF_UNINIT.
 *Inputs:
 * Argument 1	None
 *Return Value:	None
 *
 ***********************************************************************************************************/
Fls_FakeHW::Fls_FakeHW(
  Fls_LengthType FlsTotalSizeIn,
  uint8 FlsErasedValueIn,
  uint8 FlsDevErrDetect) {
  m_Store = new NonVolatileStore((const char*)"vecu_mcal_fls.bin", FlsTotalSizeIn);
  FlsTotalSize = FlsTotalSizeIn;
  FlsErasedValue = FlsErasedValueIn;
  HardwareError = FALSE;
  EraseVerifyError = FALSE;
  BlankCheckVerifyError = FALSE;
  WriteVerifyError = FALSE;
  ReadTimeoutError = FALSE;
  WriteTimeoutError = FALSE;
  EraseTimeoutError = FALSE;
  CompareTimeoutError = FALSE;
  JobResult = MEMIF_JOB_FAILED;
  DemError = FALSE;
  Mode = MEMIF_MODE_SLOW;
  Config = ((Fls_ConfigType*) NULL_PTR);
  m_FlsDevErrDetect = FlsDevErrDetect;
  Status = MEMIF_UNINIT;
  m_ApiId = 0xFF;
  m_currentJob = FLS_NONE;
  m_sourceDataBufferPtr = ((uint8 *) NULL_PTR);
  m_targetDataBufferPtr = ((uint8 *) NULL_PTR);
  m_DataBufferPtr = ((uint8 *) NULL_PTR);
  m_FlashAddress = 0;
  m_Length = 0;
  FlsBaseAddress = 0;
  ErrorCode = 0;
}

/**********************************************************************************************************
*Function Name:	Fls_FakeHW::Fls_FakeHW
*Description: Dummy function to avoid sonar warnings
*
*Inputs:
* Argument 1	None
*Return Value:	None
*
***********************************************************************************************************/
Fls_FakeHW::Fls_FakeHW(Fls_FakeHW &other) {
  *this = other;
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Init
 *Description:
 *The Pointer to configuration set (ConfigPtr) is stored in a member variable.
 *The FLASH state is set to MEMIF_IDLE. The job result is set to MEMIF_JOB_OK.
 *Inputs:
 * Argument 1	Pointer to configuration set
 *Return Value:	None
 *
 ***********************************************************************************************************/
void Fls_FakeHW::Init(const Fls_ConfigType* ConfigPtr) { /* [$Fls 14] */
  Status = MEMIF_UNINIT;
  if (m_Store->Exists()) {
    Config = ConfigPtr; /* [$Fls 191] */ /* [$Fls 86] */
    Mode = ConfigPtr->FlsMode;
    Status = MEMIF_IDLE; /* [$Fls 323] */
    JobResult = MEMIF_JOB_OK; /* [$Fls 324] */
  }
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Erase
 *Description:
 *The FLASH status is set to MEMIF_BUSY. The job result is set to MEMIF_JOB_PENDING.
 *The member variables are updated with the parameter values. E_OK is returned to the Proxy API (caller). The Fls_Erase function
 *only initiates the job and the actual job of erasing an FLASH block starting from TargetAddress +
 *FLASH base address of size Length is executed within the Fls_MainFunction.
 *Inputs:
 * Argument 1	Start address in Flash
 * Argument 2	Number of bytes to erase
 *Return Value:	E_OK or E_NOT_OK (Std_ReturnType)
 *
 ***********************************************************************************************************/
Std_ReturnType Fls_FakeHW::Erase(Fls_AddressType TargetAddress, Fls_LengthType Length) {
  Status = MEMIF_BUSY; /* [$Fls 328] */
  JobResult = MEMIF_JOB_PENDING; /* [$Fls 329] */
  m_currentJob = FLS_ERASE;
  m_FlashAddress = TargetAddress;
  m_Length = Length;  /* [$Fls 218] */
  return (E_OK); /* [$Fls 330] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Write
 *Description:
 *The FLASH status is set to MEMIF_BUSY. The job result is set to MEMIF_JOB_PENDING.
 *The member variables are updated with the parameter values. E_OK is returned to the Proxy API (caller).
 *The Fls_Write function only initiates the job and the actual job of writing a data block of size Length
 *from * SourceAddressPtr to TargetAddress + FLASH base address is executed within the Fls_MainFunction.
 *Inputs:
 * Argument 1	Address offset in Flash
 * Argument 2	Pointer to source data
 * Argument 3	Number of bytes to write
 *Return Value:	E_OK or E_NOT_OK (Std_ReturnType)
 *
 ***********************************************************************************************************/
Std_ReturnType Fls_FakeHW::Write(Fls_AddressType TargetAddress, const uint8* SourceAddressPtr, Fls_LengthType Length) {
  Status = MEMIF_BUSY; /* [$Fls 332] */
  JobResult = MEMIF_JOB_PENDING; /* [$Fls 333] */
  m_currentJob = FLS_WRITE;
  m_FlashAddress = TargetAddress;
  m_sourceDataBufferPtr = (uint8*) SourceAddressPtr;
  m_Length = Length; /* [$Fls 223] */

  return (E_OK); /* [$Fls 334] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::BlankCheck
 *Description:
 *The FLASH status is set to MEMIF_BUSY. The job result is set to MEMIF_JOB_PENDING.
 *The member variables are updated with the parameter values. E_OK is returned to the Proxy API (caller). The Fls_BlankCheck function
 *only initiates the job and the actual job of verifying if the memory area (FLASH block starting from TargetAddress +
 *FLASH base address of size Length) is erased or not is executed within the Fls_MainFunction.
 *Inputs:
 * Argument 1	Start address in Flash
 * Argument 2	Number of bytes to be verified if erased.
 *Return Value:	E_OK or E_NOT_OK (Std_ReturnType)
 *
 ***********************************************************************************************************/
Std_ReturnType Fls_FakeHW::BlankCheck(Fls_AddressType TargetAddress, Fls_LengthType Length) {
  Status = MEMIF_BUSY; /* [$Fls 1238] */
  JobResult = MEMIF_JOB_PENDING; /* [$Fls 1239] */
  m_currentJob = FLS_BLANKCHECK;
  m_FlashAddress = TargetAddress;
  m_Length = Length;
  return (E_OK); /* [$Fls 1240] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Cancel
 *Description:
 *If configured, the error notification function defined in FlsJobErrorNotification is called, in order to
 *inform the caller about the cancellation of a job. The job result is set to MEMIF_JOB_CANCELED if the job
 *result currently has the value MEMIF_JOB_PENDING. The FLS module state is set to MEMIF_IDLE.
 *This function returns to the caller after finishing the job of aborting a running job. Canceling an
 *ongoing write or erase job causes the emulated FLASH cells to revert back to the previous state and data.
 *Inputs:
 * Argument 1	None
 *Return Value:	None
 *
 ***********************************************************************************************************/
void Fls_FakeHW::Cancel(void) {
  NotifyJobError(); /* [$Fls 147] [$Fls 348] */   /*reset internal variables*/
  m_DataBufferPtr = ((uint8 *) NULL_PTR);
  m_FlashAddress = 0;
  m_Length = 0;
  if (JobResult == MEMIF_JOB_PENDING) {
    JobResult = MEMIF_JOB_CANCELED; /* [$Fls 33] [$Fls 229] [$Fls 230] */
  }
  Status = MEMIF_IDLE; /* [$Fls 336] [$Fls 229] [$Fls 230] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::GetStatus
 *Description:
 *The FLASH status is read from the member variable and returned to the caller.
 *Inputs:
 * Argument 1	None
 *Return Value:	Status of the Flash
 *
 ***********************************************************************************************************/
MemIf_StatusType Fls_FakeHW::GetStatus(void) {
  return Status; /* [$Fls 34] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::GetJobResult
 *Description:
 *The result of the last job that has been accepted by the Fls module is read from the member variable and
 *returned to the caller.
 *Inputs:
 * Argument 1	None
 *Return Value:	Result of the last job
 *
 ***********************************************************************************************************/
MemIf_JobResultType Fls_FakeHW::GetJobResult(void) {
  return JobResult; /* [$Fls 35] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Read
 *Description:
 *The FLASH status is set to MEMIF_BUSY. The job result is set to MEMIF_JOB_PENDING.
 *The member variables are updated with the parameter values. E_OK is returned to the Proxy API (caller).
 *The Fls_Read function only initiates the job and the actual job of reading a data block of size Length
 *from SourceAddress + FLASH base address to * TargetAddressPtr is executed within the Fls_MainFunction.
 *Inputs:
 * Argument 1	Address offset in Flash
 * Argument 2	Pointer to destination data buffer in RAM
 * Argument 3	Number of bytes to read
 *Return Value:	E_OK or E_NOT_OK (Std_ReturnType)
 *
 ***********************************************************************************************************/
Std_ReturnType Fls_FakeHW::Read(Fls_AddressType SourceAddress, uint8* TargetAddressPtr, Fls_LengthType Length) {
  Status = MEMIF_BUSY; /* [$Fls 338] */
  JobResult = MEMIF_JOB_PENDING; /* [$Fls 339] */
  m_currentJob = FLS_READ;
  m_FlashAddress =  SourceAddress;
  m_targetDataBufferPtr = TargetAddressPtr;
  m_Length = Length;

  return E_OK; /* [$Fls 340] */
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::Compare
 *Description:
 *The FLASH status is set to MEMIF_BUSY. The job result is set to MEMIF_JOB_PENDING.
 *The member variables are updated with the parameter values. E_OK is returned to the Proxy API (caller).
 *The Fls_Compare function only initiates the job and the actual job of comparing the FLASH data block at
 *SourceAddress + FLASH base address of size Length with the data block at *TargetAddressPtr of the
 *same length  is executed within the Fls_MainFunction.
 *Inputs:
 * Argument 1	Address offset in Flash
 * Argument 2	Pointer to source data
 * Argument 3	Number of bytes to write
 *Return Value:	E_OK or E_NOT_OK (Std_ReturnType)
 *
 ***********************************************************************************************************/
Std_ReturnType Fls_FakeHW::Compare(Fls_AddressType SourceAddress, const uint8* TargetAddressPtr, Fls_LengthType Length) {
  Status = MEMIF_BUSY; /* [$Fls 342] */
  JobResult = MEMIF_JOB_PENDING; /* [$Fls 343] */
  m_currentJob = FLS_COMPARE;
  m_FlashAddress =  SourceAddress;
  m_DataBufferPtr = (uint8*) TargetAddressPtr;
  m_Length = Length;
  return E_OK; /* [$Fls 344] */
}

/**********************************************************************************************************
 *Function Name:        Fls_FakeHW::SetMode
 *Description:
 *No action is taken as the modes are not supported in emulated internal FLASH file
 *Inputs:
 * Argument 1	Mode
 *Return Value:	None
 *
 ***********************************************************************************************************/
 /* [$Fls 155] */
void Fls_FakeHW::SetMode(MemIf_ModeType mode_in) {
  Mode = mode_in;
}

/*******************************************************************************/
void Fls_FakeHW::NotifyJobEnd(void) { /* [$Fls 9307] [$Fls 262] */
  if ((Config->FlsJobEndNotification) != NULL_PTR) {
      Config->FlsJobEndNotification();
  }
}
/*******************************************************************************/
void Fls_FakeHW::NotifyJobError(void) { /* [$Fls 147] [$Fls 9274] [$Fls 263] */
  if ((Config->FlsJobErrorNotification) != NULL_PTR) {
      Config->FlsJobErrorNotification();
  }
}

/*******************************************************************************/
void Fls_FakeHW::DoErase(boolean fromAction) {
  if (HardwareError) {
    JobResult = MEMIF_JOB_FAILED; /* [$Fls 104] */
    Status = MEMIF_IDLE; /* [$Fls 104] */ /* [$Fls 346] */
#ifdef FLS_E_ERASE_FAILED
    Fls_Device_UpdateDem(FLS_E_ERASE_FAILED, DEM_EVENT_STATUS_FAILED); /* [$Fls 104] [$Fls 315] */
#endif    
    DemError = TRUE;
    NotifyJobError(); /* [$Fls 347] */
    return;
  }

  m_Store->memset(m_FlashAddress, FlsErasedValue, m_Length);

  /* Faking an erase verify error */
  if (EraseVerifyError) {
      m_Store->poke(m_FlashAddress, m_Store->peek(m_FlashAddress) + 1);  /* Faking an erase verify error */
  }
  if (m_FlsDevErrDetect == STD_ON) {
    Fls_AddressType byteCount = 0;
    do {
      if ((FlsErasedValue != m_Store->peek(m_FlashAddress + byteCount)) || (EraseTimeoutError)) { /* [$Fls 22] */
        if (EraseTimeoutError) { /*Faking an Erase Time out error*/
          ErrorCode = FLS_E_TIMEOUT; /* [$Fls 359] [$Fls 361] */
        } else {
          ErrorCode = FLS_E_VERIFY_ERASE_FAILED; /* [$Fls 22] [$Fls 313] */
        }
        RaiseDetError(0, FLS_MAINFUNCTION_API_ID, ErrorCode, fromAction);
        JobResult = MEMIF_JOB_FAILED; /* [$Fls 22] */
      }
      byteCount++;
    } while ((byteCount < m_Length) && (JobResult != MEMIF_JOB_FAILED));
  }
  m_Store->Flush(m_FlashAddress, m_Length);

  if (JobResult == MEMIF_JOB_PENDING) { /* [$Fls 345] */
    JobResult = MEMIF_JOB_OK; /* [$Fls 345] */
    Status = MEMIF_IDLE; /* [$Fls 346] */
    NotifyJobEnd(); /* [$Fls 167] */
  } else {
    Status = MEMIF_IDLE; /* [$Fls 346] */
    NotifyJobError(); /* [$Fls 347] */
  }
}

/*******************************************************************************/
void Fls_FakeHW::DoBlankCheck(boolean fromAction) {
  if (HardwareError) {
    JobResult = MEMIF_JOB_FAILED;
    Status = MEMIF_IDLE;
    return;
  }

  /* Faking an blank check verify error thereby blank check fails  */
  if (BlankCheckVerifyError) {
      m_Store->poke(m_FlashAddress, m_Store->peek(m_FlashAddress) + 1);
  }  
  
  Fls_AddressType byteCount = 0;
  do {
    if (FlsErasedValue != m_Store->peek(m_FlashAddress + byteCount)) { /* [$Fls 22] */
      if (m_FlsDevErrDetect == STD_ON) {
        RaiseDetError(0, FLS_MAINFUNCTION_API_ID, FLS_E_VERIFY_ERASE_FAILED, fromAction); /* [$Fls 22] [$Fls 313] */
      }
      JobResult = MEMIF_JOB_FAILED; /* [$Fls 22] */
    }
    byteCount++;
  } while ((byteCount < m_Length) && (JobResult != MEMIF_JOB_FAILED));

  m_Store->Flush(m_FlashAddress, m_Length);
  Status = MEMIF_IDLE; /* [$Fls 346] [$Fls  1257] */

  if (JobResult == MEMIF_JOB_PENDING) { /* [$Fls 345] [$Fls 1239] */
    JobResult = MEMIF_JOB_OK; /* [$Fls 345] */
    NotifyJobEnd(); /* [$Fls 167] */
  } else {
    JobResult = MEMIF_JOB_FAILED; /* [$Fls  1256] */
    NotifyJobError(); /* [$Fls 347] */
  }
}

/*******************************************************************************/
void Fls_FakeHW::DoWrite(boolean fromAction) {
  if (HardwareError) {
    JobResult = MEMIF_JOB_FAILED; /* [$Fls 105] */
    Status = MEMIF_IDLE; /* [$Fls 105] */
#ifdef FLS_E_WRITE_FAILED    
    Fls_Device_UpdateDem(FLS_E_WRITE_FAILED, DEM_EVENT_STATUS_FAILED); /* [$Fls 105] [$Fls 316] */
#endif    
    DemError = TRUE;
    NotifyJobError(); /* [$Fls 347] */
    return;
  }

  if (m_FlsDevErrDetect == STD_ON) {
    Fls_AddressType byteCount = 0;
    do {
      if (FlsErasedValue != m_Store->peek(m_FlashAddress + byteCount) || (WriteTimeoutError)) { /* [$Fls 55] */
        if (WriteTimeoutError) { /* Faking an Write Time out error */
          ErrorCode = FLS_E_TIMEOUT; /* [$Fls 360] [$Fls 361] */
        } else {
          ErrorCode = FLS_E_VERIFY_ERASE_FAILED; /* [$Fls 55] */
        }
        RaiseDetError(0, FLS_MAINFUNCTION_API_ID, ErrorCode, fromAction);
        JobResult = MEMIF_JOB_FAILED; /* [$Fls 55] */
      }
      byteCount++;
    } while ((byteCount < m_Length) && (JobResult != MEMIF_JOB_FAILED));
  }

  if (JobResult == MEMIF_JOB_PENDING) {
    m_Store->memcpy(m_FlashAddress, m_sourceDataBufferPtr, m_Length);

    if (WriteVerifyError) {
      m_Store->poke(m_FlashAddress, m_Store->peek(m_FlashAddress) + 1); /* Faking a write verify error */
    }
    if (m_FlsDevErrDetect == STD_ON) {
      Fls_AddressType byteCount = 0;
      do {
        if (*(m_sourceDataBufferPtr + byteCount) != m_Store->peek(m_FlashAddress + byteCount)) {
          JobResult = MEMIF_JOB_FAILED; /* [$Fls 56] */
          ErrorCode = FLS_E_VERIFY_WRITE_FAILED; /* [$Fls 56] [$Fls 314] */
          RaiseDetError(0, FLS_MAINFUNCTION_API_ID, ErrorCode, fromAction);
        }
        byteCount++;
      } while ((byteCount < m_Length) && (JobResult != MEMIF_JOB_FAILED));
    }

    m_Store->Flush(m_FlashAddress, m_Length);

    if (JobResult == MEMIF_JOB_PENDING) { /* [$Fls 345] */
      JobResult = MEMIF_JOB_OK; /* [$Fls 345] */
      Status = MEMIF_IDLE; /* [$Fls 345] */
      NotifyJobEnd(); /* [$Fls 167] */
    } else {
      Status = MEMIF_IDLE; /* [$Fls 346] */
      NotifyJobError(); /* [$Fls 347] */
    }
  } else {
    Status = MEMIF_IDLE; /* [$Fls 346] */
    NotifyJobError(); /* [$Fls 347] */
  }
}
/*******************************************************************************/
void Fls_FakeHW::DoRead(boolean fromAction) {
  if (HardwareError) {
    JobResult = MEMIF_JOB_FAILED; /* [$Fls 106] */
    Status = MEMIF_IDLE; /* [$Fls 106] */
#ifdef FLS_E_READ_FAILED    
    Fls_Device_UpdateDem(FLS_E_READ_FAILED, DEM_EVENT_STATUS_FAILED); /* [$Fls 106] [$Fls 317] */
#endif    
    DemError = TRUE;
    NotifyJobError(); /* [$Fls 347] */
    return;
  }
  if (ReadTimeoutError) { /* Faking a Read Time out error */
    if (m_FlsDevErrDetect == STD_ON) {
      JobResult = MEMIF_JOB_FAILED;
      Status = MEMIF_IDLE;
      ErrorCode = FLS_E_TIMEOUT; /* [$Fls 362] [$Fls 361] */
      RaiseDetError(0, FLS_MAINFUNCTION_API_ID, ErrorCode, fromAction);
      NotifyJobError(); /* [$Fls 347] */
    }
    return;
  }
  m_Store->memcpy(m_targetDataBufferPtr, m_FlashAddress, m_Length);  /* [$Fls 238] */

  JobResult = MEMIF_JOB_OK; /* [$Fls 345] */
  Status = MEMIF_IDLE; /* [$Fls 346] */
  NotifyJobEnd(); /* [$Fls 347] */
}
/*******************************************************************************/
void Fls_FakeHW::DoCompare(boolean fromAction) {
  if (HardwareError) {
    JobResult = MEMIF_JOB_FAILED; /* [$Fls 154] */
    Status = MEMIF_IDLE; /* [$Fls 154] */
#ifdef FLS_E_COMPARE_FAILED    
    Fls_Device_UpdateDem(FLS_E_COMPARE_FAILED, DEM_EVENT_STATUS_FAILED); /* [$Fls 154] [$Fls 318] */
#endif    
    DemError = TRUE;
    NotifyJobError(); /* [$Fls 347] */
    return;
  }
  Fls_AddressType byteCount = 0;
  if (CompareTimeoutError) { /* Faking a Compare Time out error */
    if (m_FlsDevErrDetect == STD_ON) {
      JobResult = MEMIF_JOB_FAILED;
      Status = MEMIF_IDLE;
      ErrorCode = FLS_E_TIMEOUT; /* [$Fls 362] [$Fls 361] */
      RaiseDetError(0, FLS_MAINFUNCTION_API_ID, ErrorCode, fromAction);
      NotifyJobError(); /* [$Fls 347] */
    }
    return;
  }
  do {
    if (*(m_DataBufferPtr + byteCount) != m_Store->peek(m_FlashAddress + byteCount)) { /* [$Fls 200] [$Fls 241] */
      JobResult = MEMIF_BLOCK_INCONSISTENT; /* [$Fls 200] */
    }
    byteCount++;
  } while ((byteCount < m_Length) && (JobResult != MEMIF_BLOCK_INCONSISTENT));
  if (JobResult == MEMIF_JOB_PENDING) { /* if (byteCount == m_Length)*/
    JobResult = MEMIF_JOB_OK; /* [$Fls 345] */
    Status = MEMIF_IDLE; /* [$Fls 346] */
    NotifyJobEnd(); /* [$Fls 167] */
  } else {
    Status = MEMIF_IDLE; /* [$Fls 346] */
    NotifyJobError(); /* [$Fls 347] [$Fls 349] */
  }
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::MainFunction
 *Description:
 *Step1: If any of the FLASH Read, Write, Erase and Compare job is found pending, the pending job is
 *identified and processed using the pointer 'FlsInternalMap'.
 *Step2: A pending Erase job is processed by writing the specified erase value for size 'Length' in
 *the 'FlsInternalMap' pointer starting from the specified address. If DET is enabled, the content of the
 *addressed memory area is compared against the value of an erased flash cell to check that the block has
 *been completely erased. If this check fails, the job result is set to MEMIF_JOB_FAILED and development
 *error code FLS_E_VERIFY_ERASE_FAILED is set.
 *Step3: If DET is enabled, the content of the specified memory area is compared against the value of
 *an erased flash cell to check that the block has been completely erased. If this check fails, the job
 *result is set to MEMIF_JOB_FAILED and development error code FLS_E_VERIFY_ERASE_FAILED is set. Otherwise,
 *a pending Write job is processed by copying a data block of size 'Length' from the 'SourceAddressPtr' to
 *the specified address of the 'FlsInternalMap' pointer. If DET is enabled, the contents of the
 *reprogrammed memory area are compared against the contents of the provided application buffer to check
 *that the block has been completely reprogrammed. If this check fails, the job result is set to
 *MEMIF_JOB_FAILED and development error code FLS_E_VERIFY_WRITE_FAILED is set.
 *Step4: A pending Read job is processed by copying a data block of size 'Length' from the specified
 *address of 'FlsInternalMap' pointer to the 'TargetAddressPtr'.
 *Step5: A pending Compare job is processed by comparing the 'FlsInternalMap' pointer's data block at
 *the specified address of size Length with the data block at TargetAddressPtr of the same length.
 *Step6: When a job is finished successfully, the FLASH module state is set to MEMIF_IDLE and the job
 *result is set to MEMIF_JOB_OK (or MEMIF_BLOCK_INCONSISTENT, in case of differing data Compare job or
 *MEMIF_JOB_FAILED, in case of failed erase/write job). If configured, the notification function defined
 *in the configuration parameter 'FlsJobEndNotification' is called.
 *Step7: No action is taken if no job is currently pending.
 *Inputs:
 * Argument 1	None
 *Return Value:	None
 *
 ***********************************************************************************************************/
void Fls_FakeHW::MainFunction(boolean fromAction) { /* [$Fls 37] */ /* [$Fls 38] */
  if (JobResult == MEMIF_JOB_PENDING) { /* [$Fls 38] */ /* [$Fls 39] */
    switch (m_currentJob) {
      case FLS_ERASE: /* [$Fls 37] [$Fls 220] */
        DoErase(fromAction);
        break;

      case FLS_WRITE: /* [$Fls 37] [$Fls 225] */
        DoWrite(fromAction);
        break;

      case FLS_READ: /* [$Fls 37] [$Fls 236] */
        DoRead(fromAction);
        break;

      case FLS_COMPARE: /* [$Fls 37] [$Fls 243] */
        DoCompare(fromAction);
        break;
      case FLS_BLANKCHECK: 
        DoBlankCheck(fromAction);
        break;
		
      default:
        break;
    }
  }
}

/**********************************************************************************************************
 *Function Name:	Fls_FakeHW::~Fls_FakeHW
 *Description:
 *
 *Inputs:
 * Argument 1	None
 *Return Value:	None
 *
 ***********************************************************************************************************/
Fls_FakeHW::~Fls_FakeHW() {
}

void Fls_FakeHW::DeAllocateInternalMemory(void) { /* [$Fls 1254] */
  if (m_Store) {
    if (m_Store->Exists()) {
      m_Store->MemoryDeAllocation();
      delete m_Store;
      m_Store = ((NonVolatileStore*) NULL_PTR);
    }
  }
}

/**********************************************************************************************************
 * GetFlsBaseAddress
 ***********************************************************************************************************/
uint8 *Fls_FakeHW::GetBaseAddress(void) {
  return this->m_Store->BaseAddress();
}

extern "C" {

void Fls_InjectHardwareError(int on)            { fls_hw.HardwareError = on; }
void Fls_InjectEraseVerifyError(int on)         { fls_hw.EraseVerifyError = on; }
void Fls_InjectBlankCheckVerifyError(int on)    { fls_hw.BlankCheckVerifyError = on; }
void Fls_InjectWriteVerifyError(int on)         { fls_hw.WriteVerifyError = on; }
void Fls_InjectReadTimeoutError(int on)         { fls_hw.ReadTimeoutError = on; }
void Fls_InjectWriteTimeoutError(int on)        { fls_hw.WriteTimeoutError = on; }
void Fls_InjectCompareTimeoutError(int on)      { fls_hw.CompareTimeoutError = on; }
void Fls_InjectEraseTimeoutError(int on)        { fls_hw.EraseTimeoutError = on; }

int Fls_InternalHardwareErrorState(void)            { return fls_hw.HardwareError; }
int Fls_InternalEraseVerifyErrorState(void)         { return fls_hw.EraseVerifyError; }
int Fls_InternalBlankCheckVerifyErrorState(void)    { return fls_hw.BlankCheckVerifyError; }
int Fls_InternalWriteVerifyErrorState(void)         { return fls_hw.WriteVerifyError; }
int Fls_InternalReadTimeoutErrorState(void)         { return fls_hw.ReadTimeoutError; }
int Fls_InternalWriteTimeoutErrorState(void)        { return fls_hw.WriteTimeoutError; }
int Fls_InternalCompareTimeoutErrorState(void)      { return fls_hw.CompareTimeoutError; }
int Fls_InternalEraseTimeoutErrorState(void)        { return fls_hw.EraseTimeoutError; }

MemIf_JobResultType Fls_InternalJobResult(void) { return fls_hw.JobResult; }
MemIf_StatusType Fls_InternalMemStatus(void) { return fls_hw.Status; }
void Fls_SetInternalMemStatus(MemIf_StatusType s) { fls_hw.Status = s; }

const Fls_ConfigType* Fls_GetInternalConfig(void) { return fls_hw.Config; }
MemIf_ModeType Fls_GetInternalMode(void) { return fls_hw.Mode; }

void Fls_DeAllocateMemory(void) {
  fls_hw.DeAllocateInternalMemory(); /* [$Fls 1254] */
}

}

